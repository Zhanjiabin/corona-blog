<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Redis | Corona&#39;s blog</title>
    <meta name="generator" content="VuePress 1.5.2">
    <link rel="icon" href="/img/avatar.jpg">
    <meta name="description" content="Corona个人博客，主要与大家分享Java后端技术，近期也在学习前端，同时还在学习英语与日语。学习是一件令人兴奋且幸福的事。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    <link rel="preload" href="/assets/css/0.styles.c1104ed1.css" as="style"><link rel="preload" href="/assets/js/app.2d002c64.js" as="script"><link rel="preload" href="/assets/js/2.1de4f9a9.js" as="script"><link rel="preload" href="/assets/js/3.388dfb37.js" as="script"><link rel="preload" href="/assets/js/28.c46e3d81.js" as="script"><link rel="prefetch" href="/assets/js/10.34851ffe.js"><link rel="prefetch" href="/assets/js/11.5ffc6bd2.js"><link rel="prefetch" href="/assets/js/12.448d82f3.js"><link rel="prefetch" href="/assets/js/13.0df1d19b.js"><link rel="prefetch" href="/assets/js/14.3ce8abc0.js"><link rel="prefetch" href="/assets/js/15.44b99afa.js"><link rel="prefetch" href="/assets/js/16.47b87757.js"><link rel="prefetch" href="/assets/js/17.c8c49238.js"><link rel="prefetch" href="/assets/js/18.5eb1a5a3.js"><link rel="prefetch" href="/assets/js/19.8324312a.js"><link rel="prefetch" href="/assets/js/20.2220d9cf.js"><link rel="prefetch" href="/assets/js/21.a25d7145.js"><link rel="prefetch" href="/assets/js/22.774ff777.js"><link rel="prefetch" href="/assets/js/23.00b84088.js"><link rel="prefetch" href="/assets/js/24.e53bd3c9.js"><link rel="prefetch" href="/assets/js/25.c2ef043e.js"><link rel="prefetch" href="/assets/js/26.7a3f1eb1.js"><link rel="prefetch" href="/assets/js/27.21adb53d.js"><link rel="prefetch" href="/assets/js/29.01225843.js"><link rel="prefetch" href="/assets/js/30.f7f6f486.js"><link rel="prefetch" href="/assets/js/31.82d35a63.js"><link rel="prefetch" href="/assets/js/32.203ad538.js"><link rel="prefetch" href="/assets/js/33.3eb84e0f.js"><link rel="prefetch" href="/assets/js/34.acab3992.js"><link rel="prefetch" href="/assets/js/35.af872eef.js"><link rel="prefetch" href="/assets/js/36.0b2a7ce0.js"><link rel="prefetch" href="/assets/js/37.15e36418.js"><link rel="prefetch" href="/assets/js/38.4b437a0d.js"><link rel="prefetch" href="/assets/js/39.f3256764.js"><link rel="prefetch" href="/assets/js/4.44a581f6.js"><link rel="prefetch" href="/assets/js/40.675c0a13.js"><link rel="prefetch" href="/assets/js/41.5dd5ca02.js"><link rel="prefetch" href="/assets/js/42.45e13174.js"><link rel="prefetch" href="/assets/js/43.a2c54600.js"><link rel="prefetch" href="/assets/js/44.0b4d65c9.js"><link rel="prefetch" href="/assets/js/45.21f33da4.js"><link rel="prefetch" href="/assets/js/46.7d3e0f68.js"><link rel="prefetch" href="/assets/js/47.51036c9c.js"><link rel="prefetch" href="/assets/js/48.bd9a13c7.js"><link rel="prefetch" href="/assets/js/49.443f269f.js"><link rel="prefetch" href="/assets/js/5.4357a863.js"><link rel="prefetch" href="/assets/js/50.fe5fb77f.js"><link rel="prefetch" href="/assets/js/51.b3f5df98.js"><link rel="prefetch" href="/assets/js/52.6a62b744.js"><link rel="prefetch" href="/assets/js/53.c9464477.js"><link rel="prefetch" href="/assets/js/54.89ebc2bb.js"><link rel="prefetch" href="/assets/js/6.23a9f59f.js"><link rel="prefetch" href="/assets/js/7.847b7cb1.js"><link rel="prefetch" href="/assets/js/8.dc54036a.js"><link rel="prefetch" href="/assets/js/9.31509603.js">
    <link rel="stylesheet" href="/assets/css/0.styles.c1104ed1.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/img/avatar.jpg" alt="Corona's blog" class="logo"> <span class="site-name can-hide">Corona's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/server/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java_base/" class="nav-link">Java基础</a></li><li class="dropdown-subitem"><a href="/pages/spring/" class="nav-link">Spring</a></li><li class="dropdown-subitem"><a href="/pages/spring_boot/" class="nav-link">Spring Boot</a></li><li class="dropdown-subitem"><a href="/pages/spring_cloud/" class="nav-link">Spring Cloud</a></li><li class="dropdown-subitem"><a href="/pages/netty/" class="nav-link">Netty</a></li><li class="dropdown-subitem"><a href="/pages/redis/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Redis</a></li></ul></li><li class="dropdown-item"><h4>Go</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/go_base/" class="nav-link">Go基础语法</a></li><li class="dropdown-subitem"><a href="/pages/iris/" class="nav-link">Iris</a></li></ul></li><li class="dropdown-item"><h4>Python</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/python_base/" class="nav-link">Python基础语法</a></li><li class="dropdown-subitem"><a href="/pages/flask/" class="nav-link">Flask</a></li><li class="dropdown-subitem"><a href="/pages/pandas/" class="nav-link">Pandas</a></li><li class="dropdown-subitem"><a href="/pages/numpy/" class="nav-link">Numpy</a></li><li class="dropdown-subitem"><a href="/pages/tensor_flow/" class="nav-link">TensorFlow</a></li><li class="dropdown-subitem"><a href="/pages/pytorch/" class="nav-link">Pytorch</a></li></ul></li><li class="dropdown-item"><h4>HTTP</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/http/" class="nav-link">HTTP</a></li><li class="dropdown-subitem"><a href="/pages/tcp/" class="nav-link">TCP</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/mysql/base/" class="nav-link">MySQL基础知识</a></li><li class="dropdown-subitem"><a href="/pages/mysql/how_to_run/" class="nav-link">MySQL是怎样运行的学习笔记</a></li><li class="dropdown-subitem"><a href="/pages/mongodb/" class="nav-link">MongoDB</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>HTML</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/html_base/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/pages/html_mobile/" class="nav-link">移动端</a></li><li class="dropdown-subitem"><a href="/pages/html_optimize_log1.html" class="nav-link">工作随手记</a></li></ul></li><li class="dropdown-item"><h4>CSS</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/css_base/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>JavaScript</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/js_base/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>Vue</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/vue_base/" class="nav-link">Vue</a></li></ul></li><li class="dropdown-item"><h4>React</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/react_base/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>小程序</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/miniprogram_base/" class="nav-link">小程序</a></li></ul></li><li class="dropdown-item"><h4>React Native</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/react_native_base/" class="nav-link">React Native</a></li></ul></li><li class="dropdown-item"><h4>Flutter</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/flutter_base/" class="nav-link">Flutter</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="动漫" class="dropdown-title"><a href="/acg/" class="link-title">动漫</a> <span class="title" style="display:none;">动漫</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>吹响吧！上低音号</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/cxbsdyh_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/cxbsdyh_summarize/" class="nav-link">故事梗概</a></li></ul></li><li class="dropdown-item"><h4>进击の巨人</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/jjdjr_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/jjdjr_summarize/" class="nav-link">故事梗概</a></li></ul></li><li class="dropdown-item"><h4>Clannad</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/clannad_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/clannad_summarize/" class="nav-link">故事梗概</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>日记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/diary_20200816/" class="nav-link">2020-08-16</a></li></ul></li><li class="dropdown-item"><h4>旅游</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/travel_wugongshan/" class="nav-link">江西武功山</a></li></ul></li><li class="dropdown-item"><h4>随笔</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/mystorywithxiuxiu/" class="nav-link">我和一个图书馆管理员的故事</a></li></ul></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/collection_web/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/collection_web/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/collection_source/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/collection_vue_source/" class="nav-link">Vue资源</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/zhanjiabin/corona-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="https://avatars0.githubusercontent.com/u/69713569?s=460&amp;u=0126cd3a34a49d9a4ae4cecc189e359f4cba2529&amp;v=4"> <div class="blogger-info"><h3>詹佳斌</h3> <span>
        一枚菜鸡程序员
      </span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/" class="nav-link">首页</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/server/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Java</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/java_base/" class="nav-link">Java基础</a></li><li class="dropdown-subitem"><a href="/pages/spring/" class="nav-link">Spring</a></li><li class="dropdown-subitem"><a href="/pages/spring_boot/" class="nav-link">Spring Boot</a></li><li class="dropdown-subitem"><a href="/pages/spring_cloud/" class="nav-link">Spring Cloud</a></li><li class="dropdown-subitem"><a href="/pages/netty/" class="nav-link">Netty</a></li><li class="dropdown-subitem"><a href="/pages/redis/" aria-current="page" class="nav-link router-link-exact-active router-link-active">Redis</a></li></ul></li><li class="dropdown-item"><h4>Go</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/go_base/" class="nav-link">Go基础语法</a></li><li class="dropdown-subitem"><a href="/pages/iris/" class="nav-link">Iris</a></li></ul></li><li class="dropdown-item"><h4>Python</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/python_base/" class="nav-link">Python基础语法</a></li><li class="dropdown-subitem"><a href="/pages/flask/" class="nav-link">Flask</a></li><li class="dropdown-subitem"><a href="/pages/pandas/" class="nav-link">Pandas</a></li><li class="dropdown-subitem"><a href="/pages/numpy/" class="nav-link">Numpy</a></li><li class="dropdown-subitem"><a href="/pages/tensor_flow/" class="nav-link">TensorFlow</a></li><li class="dropdown-subitem"><a href="/pages/pytorch/" class="nav-link">Pytorch</a></li></ul></li><li class="dropdown-item"><h4>HTTP</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/http/" class="nav-link">HTTP</a></li><li class="dropdown-subitem"><a href="/pages/tcp/" class="nav-link">TCP</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/mysql/base/" class="nav-link">MySQL基础知识</a></li><li class="dropdown-subitem"><a href="/pages/mysql/how_to_run/" class="nav-link">MySQL是怎样运行的学习笔记</a></li><li class="dropdown-subitem"><a href="/pages/mongodb/" class="nav-link">MongoDB</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="前端" class="dropdown-title"><a href="/web/" class="link-title">前端</a> <span class="title" style="display:none;">前端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>HTML</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/html_base/" class="nav-link">HTML</a></li><li class="dropdown-subitem"><a href="/pages/html_mobile/" class="nav-link">移动端</a></li><li class="dropdown-subitem"><a href="/pages/html_optimize_log1.html" class="nav-link">工作随手记</a></li></ul></li><li class="dropdown-item"><h4>CSS</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/css_base/" class="nav-link">CSS</a></li></ul></li><li class="dropdown-item"><h4>JavaScript</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/js_base/" class="nav-link">JavaScript</a></li></ul></li><li class="dropdown-item"><h4>Vue</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/vue_base/" class="nav-link">Vue</a></li></ul></li><li class="dropdown-item"><h4>React</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/react_base/" class="nav-link">React</a></li></ul></li><li class="dropdown-item"><h4>小程序</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/miniprogram_base/" class="nav-link">小程序</a></li></ul></li><li class="dropdown-item"><h4>React Native</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/react_native_base/" class="nav-link">React Native</a></li></ul></li><li class="dropdown-item"><h4>Flutter</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/flutter_base/" class="nav-link">Flutter</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="动漫" class="dropdown-title"><a href="/acg/" class="link-title">动漫</a> <span class="title" style="display:none;">动漫</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>吹响吧！上低音号</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/cxbsdyh_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/cxbsdyh_summarize/" class="nav-link">故事梗概</a></li></ul></li><li class="dropdown-item"><h4>进击の巨人</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/jjdjr_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/jjdjr_summarize/" class="nav-link">故事梗概</a></li></ul></li><li class="dropdown-item"><h4>Clannad</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/clannad_introduce/" class="nav-link">人物介绍</a></li><li class="dropdown-subitem"><a href="/pages/clannad_summarize/" class="nav-link">故事梗概</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="更多" class="dropdown-title"><a href="/more/" class="link-title">更多</a> <span class="title" style="display:none;">更多</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>日记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/diary_20200816/" class="nav-link">2020-08-16</a></li></ul></li><li class="dropdown-item"><h4>旅游</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/travel_wugongshan/" class="nav-link">江西武功山</a></li></ul></li><li class="dropdown-item"><h4>随笔</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/pages/mystorywithxiuxiu/" class="nav-link">我和一个图书馆管理员的故事</a></li></ul></li><li class="dropdown-item"><!----> <a href="/friends/" class="nav-link">友情链接</a></li></ul></div></div><div class="nav-item"><a href="/about/" class="nav-link">关于</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="收藏" class="dropdown-title"><a href="/pages/collection_web/" class="link-title">收藏</a> <span class="title" style="display:none;">收藏</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/pages/collection_web/" class="nav-link">网站</a></li><li class="dropdown-item"><!----> <a href="/pages/collection_source/" class="nav-link">资源</a></li><li class="dropdown-item"><!----> <a href="/pages/collection_vue_source/" class="nav-link">Vue资源</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="索引" class="dropdown-title"><a href="/archives/" class="link-title">索引</a> <span class="title" style="display:none;">索引</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/categories/" class="nav-link">分类</a></li><li class="dropdown-item"><!----> <a href="/tags/" class="nav-link">标签</a></li><li class="dropdown-item"><!----> <a href="/archives/" class="nav-link">归档</a></li></ul></div></div> <a href="https://github.com/zhanjiabin/corona-blog" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></nav>  <ul class="sidebar-links"><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Java</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Go</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>Python</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>HTTP</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading"><span>数据库</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading open"><span>Redis</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/pages/redis/" aria-current="page" class="active sidebar-link">Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#第一章-初识redis" class="sidebar-link">第一章 初识Redis</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-盛赞redis" class="sidebar-link">1. 盛赞Redis</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-redis特性" class="sidebar-link">2. Redis特性</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-redis使用场景" class="sidebar-link">3. Redis使用场景</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-用好redis的建议" class="sidebar-link">4. 用好Redis的建议</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-正确安装并启动redis" class="sidebar-link">5. 正确安装并启动Redis</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-redis重大版本" class="sidebar-link">6. Redis重大版本</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_7-总结" class="sidebar-link">7. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第二章-api的理解和使用" class="sidebar-link">第二章 API的理解和使用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-预备" class="sidebar-link">1. 预备</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-字符串" class="sidebar-link">2. 字符串</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-哈希" class="sidebar-link">3. 哈希</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-列表" class="sidebar-link">4. 列表</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-集合" class="sidebar-link">5. 集合</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-有序集合" class="sidebar-link">6. 有序集合</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_7-键管理" class="sidebar-link">7. 键管理</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第三章-小功能大用处" class="sidebar-link">第三章 小功能大用处</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-慢查询分析" class="sidebar-link">1. 慢查询分析</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-redis-shell" class="sidebar-link">2. Redis Shell</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-pipeline" class="sidebar-link">3 Pipeline</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-事务与lua" class="sidebar-link">4. 事务与Lua</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-bitmaps" class="sidebar-link">5. Bitmaps</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-hyperloglog" class="sidebar-link">6. HyperLogLog</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_7-发布订阅" class="sidebar-link">7. 发布订阅</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_8-geo" class="sidebar-link">8. GEO</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_9-总结" class="sidebar-link">9. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第四章-客户端" class="sidebar-link">第四章 客户端</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-客户端通信协议" class="sidebar-link">1. 客户端通信协议</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-java客户端jedis" class="sidebar-link">2. Java客户端Jedis</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-客户端管理" class="sidebar-link">3. 客户端管理</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-总结" class="sidebar-link">4. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第五章-持久化" class="sidebar-link">第五章 持久化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-rdb" class="sidebar-link">1. RDB</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-aof" class="sidebar-link">2. AOF</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-问题定位与优化" class="sidebar-link">3. 问题定位与优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-多实例部署" class="sidebar-link">4. 多实例部署</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-总结" class="sidebar-link">5. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第六章-复制" class="sidebar-link">第六章 复制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-配置" class="sidebar-link">1. 配置</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-拓扑" class="sidebar-link">2. 拓扑</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-原理" class="sidebar-link">3. 原理</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-开发与运维中的问题" class="sidebar-link">4. 开发与运维中的问题</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-总结-2" class="sidebar-link">5. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第七章-redis的噩梦：阻塞" class="sidebar-link">第七章 Redis的噩梦：阻塞</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-发现阻塞" class="sidebar-link">1. 发现阻塞</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-内在原因" class="sidebar-link">2. 内在原因</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-外在原因" class="sidebar-link">3. 外在原因</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-总结-2" class="sidebar-link">4. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第八章-理解内存" class="sidebar-link">第八章 理解内存</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-内存消耗" class="sidebar-link">1. 内存消耗</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-内存管理" class="sidebar-link">2. 内存管理</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-内存优化" class="sidebar-link">3. 内存优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-总结-3" class="sidebar-link">4. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第九章-哨兵" class="sidebar-link">第九章 哨兵</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-基本概念" class="sidebar-link">1. 基本概念</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-安装和部署" class="sidebar-link">2. 安装和部署</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-api" class="sidebar-link">3. API</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-客户端连接" class="sidebar-link">4. 客户端连接</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-实现原理" class="sidebar-link">5. 实现原理</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-总结" class="sidebar-link">6. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第十章-集群" class="sidebar-link">第十章 集群</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-数据分布" class="sidebar-link">1. 数据分布</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-搭建集群" class="sidebar-link">2. 搭建集群</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-节点通信" class="sidebar-link">3. 节点通信</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-集群伸缩" class="sidebar-link">4. 集群伸缩</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-请求路由" class="sidebar-link">5. 请求路由</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-故障转移" class="sidebar-link">6. 故障转移</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_7-集群运维" class="sidebar-link">7. 集群运维</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_8-总结" class="sidebar-link">8. 总结</a></li></ul></li><li class="sidebar-sub-header"><a href="/pages/redis/#第十一章-缓存设计" class="sidebar-link">第十一章 缓存设计</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/pages/redis/#_1-缓存的收益和成" class="sidebar-link">1. 缓存的收益和成</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_2-缓存更新策略" class="sidebar-link">2. 缓存更新策略</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_3-缓存粒度控制" class="sidebar-link">3. 缓存粒度控制</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_4-穿透优化" class="sidebar-link">4. 穿透优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_5-无底洞优化" class="sidebar-link">5. 无底洞优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_6-雪崩优化" class="sidebar-link">6. 雪崩优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_7-热度key重建优化" class="sidebar-link">7. 热度key重建优化</a></li><li class="sidebar-sub-header"><a href="/pages/redis/#_8-总结-2" class="sidebar-link">8. 总结</a></li></ul></li></ul></li></ul></section></li></ul> </aside> <div><main class="page"> <div class="theme-vdoing-wrapper bg-style-1"><div class="articleInfo-wrap" data-v-f6108aee><div class="articleInfo" data-v-f6108aee><ul class="breadcrumbs" data-v-f6108aee><li data-v-f6108aee><a href="/" title="首页" class="iconfont icon-home router-link-active" data-v-f6108aee></a></li> <li data-v-f6108aee><a href="/server" title="后端-目录页" data-v-f6108aee>后端</a></li> <li data-v-f6108aee><a href="/server/#Redis" title="后端#Redis" data-v-f6108aee>Redis</a></li></ul> <div class="info" data-v-f6108aee><div title="作者" class="author iconfont icon-touxiang" data-v-f6108aee><a href="https://github.com/zhanjiabin" target="_blank" title="作者" class="beLink" data-v-f6108aee>詹佳斌</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-f6108aee><a href="javascript:;" data-v-f6108aee>2020-08-16</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-content"></div></div></div> <h1><img src="/img/acg.jpg">
          Redis
        </h1> <div class="theme-vdoing-content content__default"><h1 id="redis"><a href="#redis" class="header-anchor">#</a> Redis</h1> <p>Redis
</p> <h1 id="redis开发与运维"><a href="#redis开发与运维" class="header-anchor">#</a> Redis开发与运维</h1> <h2 id="第一章-初识redis"><a href="#第一章-初识redis" class="header-anchor">#</a> 第一章 初识Redis</h2> <h3 id="_1-盛赞redis"><a href="#_1-盛赞redis" class="header-anchor">#</a> 1. 盛赞Redis</h3> <p>Redis是一种基于键值对的NoSQL数据库，与很多键值对数据库不同的是，Redis中的值可以是由String（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）、Bitmaps（位图）、HyperLogLog、GEO（地理信息定位）等多种数据结构和算法组成，因此Redis可以满足很多的应用场景，而且因为Redis会将所有数据都存放在内存中，所以它的读写性能非常惊人。不仅如此，Redis还可以将内存的数据利用快照和日志的形式保存到硬盘上，这样在发生类似断电或者机器故障的时候，内存中的数据不会“丢失”。除了上述功能，Redis还提供了键过期、发布订阅、事务、流水线、Lua脚本等附加功能。</p> <h3 id="_2-redis特性"><a href="#_2-redis特性" class="header-anchor">#</a> 2. Redis特性</h3> <p>Redis的8个重要特性。</p> <ul><li><p>速度快</p> <ul><li>Redis的所有数据都是存放在内存中的。</li> <li>Redis是用C语言实现的。</li> <li>Redis使用了单线程架构。</li> <li>Redis是少有的集性能和优雅于一身的开源代码。</li></ul></li> <li><p>基于键值对的数据结构服务器</p> <ul><li>Redis的全称是Remote Dictionary Server，它主要提供了5种数据结构：字符串、哈希、列表、集合、有序集合，同时在字符串的基础之上演变出了位图（Bitmaps）和HyperLogLog两种神奇的“数据结构”，并且随着LBS（Location Based Service，基于位置服务）的不断发展，Redis3.2版本中加入有关GEO（地理信息定位）的功能。</li></ul></li> <li><p>丰富的功能</p> <ul><li>提供了键过期功能，可以用来实现缓存。</li> <li>提供了发布订阅功能，可以用来实现消息系统。</li> <li>支持Lua脚本功能，可以利用Lua创造出新的Redis命令。</li> <li>提供了简单的事务功能，能在一定程度上保证事务特性。</li> <li>提供了流水线（Pipeline）功能，这样客户端能将一批命令一次性传到Redis，减少了网络的开销。</li></ul></li> <li><p>简单稳定</p> <ul><li>Redis的源码很少。</li> <li>Redis使用单线程模型。</li> <li>Redis不需要依赖于操作系统中的类库，Redis自己实现了事件处理的相关功能。</li></ul></li> <li><p>客户端语言多</p> <ul><li>Redis提供了简单的TCP通信协议，很多编程语言可以很方便地接入Redis。所以支持Redis的客户端语言也非常多，几乎涵盖了主流的编程语言。</li></ul></li> <li><p>持久化</p> <ul><li>Redis提供了两种持久化方式：RDB和AOF，即可以用两种策略将内存的数据保存到硬盘中。</li></ul></li> <li><p>主从复制</p> <ul><li>Redis提供了复制功能，实现了多个相同数据的Redis副本，复制功能是分布式Redis的基础。</li></ul></li></ul> <h3 id="_3-redis使用场景"><a href="#_3-redis使用场景" class="header-anchor">#</a> 3. Redis使用场景</h3> <h4 id="_3-1-redis可以做什么"><a href="#_3-1-redis可以做什么" class="header-anchor">#</a> 3.1 Redis可以做什么</h4> <ul><li>缓存：键值过期时间设置</li> <li>排行榜系统：列表和有序集合数据结构</li> <li>计数器应用：Redis天然支持计数功能而且计算的性能也非常好</li> <li>社交网络：赞/踩、粉丝、共同友好/喜好、推送、下拉刷新。</li> <li>消息队列系统：Redis提供了发布订阅功能和阻塞队列的功能。</li></ul> <h4 id="_3-2-redis不可以做什么"><a href="#_3-2-redis不可以做什么" class="header-anchor">#</a> 3.2 Redis不可以做什么</h4> <p>数据量大、很少使用的数据。</p> <h3 id="_4-用好redis的建议"><a href="#_4-用好redis的建议" class="header-anchor">#</a> 4. 用好Redis的建议</h3> <ul><li>切勿当黑盒使用，开发与运维同样重要。</li> <li>阅读源码。</li></ul> <h3 id="_5-正确安装并启动redis"><a href="#_5-正确安装并启动redis" class="header-anchor">#</a> 5. 正确安装并启动Redis</h3> <h5 id="_5-1-安装redis"><a href="#_5-1-安装redis" class="header-anchor">#</a> 5.1 安装Redis</h5> <p>推荐使用源码安装</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>$ <span class="token function">wget</span> http://download.redis.io/releases/redis-3.0.7.tar.gz //下载Redis制定版本的源码压缩包到当前目录
$ <span class="token function">tar</span> xzf redis-3.0.7.tar.gz  //解压缩Redis源码压缩包
$ <span class="token function">ln</span> -s redis-3.0.7 redis //建立一个redis目录的软连接，指向redis-3.0.7
$ <span class="token builtin class-name">cd</span> redis //进入redis目录
$ <span class="token function">make</span> //编译（编译之前确保操作系统已经安装gcc）
$ <span class="token function">make</span> <span class="token function">install</span> //安装
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h5 id="_5-2-配置、启动、操作、关闭redis"><a href="#_5-2-配置、启动、操作、关闭redis" class="header-anchor">#</a> 5.2 配置、启动、操作、关闭Redis</h5> <p>Redis安装之后，src和/usr/local/bin目录下多了几个以redis开头的可执行文件，我们称之为Redis Shell，这些可执行文件可以做很多事情，例如可以启动和停止Redis、可以检测和修复Redis的持久化文件，还可以检测Redis的性能。</p> <p><img src="C:%5CUsers%5Cyasina%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210109205715914.png" alt="image-20210109205715914"></p> <p>redis可执行文件说明</p> <table><thead><tr><th style="text-align:center;">可执行文件</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">redis-server</td> <td style="text-align:center;">启动Redis</td></tr> <tr><td style="text-align:center;">redis-cli</td> <td style="text-align:center;">Redis命令行客户端</td></tr> <tr><td style="text-align:center;">redis-benchmark</td> <td style="text-align:center;">Redis基准测试工具</td></tr> <tr><td style="text-align:center;">redis-check-aof</td> <td style="text-align:center;">Redis AOF持久化文件检测和修复工具</td></tr> <tr><td style="text-align:center;">redis-check-rdb</td> <td style="text-align:center;">Redis RDB持久化文件检测和修复工具</td></tr> <tr><td style="text-align:center;">redis-sentinel</td> <td style="text-align:center;">启动Redis Sentinel</td></tr></tbody></table> <h6 id="_5-2-1-启动redis"><a href="#_5-2-1-启动redis" class="header-anchor">#</a> 5.2.1 启动Redis</h6> <p>有三种方法启动Redis：默认配置、运行配置、配置文件启动。</p> <ul><li><p>默认配置：会使用Redis的默认配置来启动。默认端口是6379。不推荐使用这种。</p></li> <li><p>运行启动：redis-server加上要修改的配置名和值（可以是多对）。不推荐使用这种。</p> <ul><li><div class="language-sheLl line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-server --configKey1 configValue1 --configKey2 configValue2</span>
<span class="token comment"># redis-server --port 6380</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li> <li><p>配置文件启动：将配置写到指定文件里，推荐使用这种。Redis有60多个配置，这里只介绍一些重要的配置。</p> <ul><li><table><thead><tr><th style="text-align:center;">配置名</th> <th style="text-align:center;">配置说明</th></tr></thead> <tbody><tr><td style="text-align:center;">port</td> <td style="text-align:center;">端口</td></tr> <tr><td style="text-align:center;">logfile</td> <td style="text-align:center;">日志文件</td></tr> <tr><td style="text-align:center;">dir</td> <td style="text-align:center;">Redis工作目录（存放持久化文件和日志文件）</td></tr> <tr><td style="text-align:center;">daemonize</td> <td style="text-align:center;">是否以守护进程的方式启动Redis</td></tr></tbody></table></li></ul></li></ul> <h6 id="_5-2-2-redis命令客户端"><a href="#_5-2-2-redis命令客户端" class="header-anchor">#</a> 5.2.2 Redis命令客户端</h6> <p>redis-cli可以使用两种方式连接Redis服务器。</p> <ul><li><p>第一种是交互式方式：通过redis-cli-h {host} -p {port}的方式连接Redis服务。</p> <ul><li><div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-cli -h 127.0.0.1 -p 6379</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li> <li><p>第二种是命令方式：用redis-cli-h {host} -p {port} {command}就可以直接得到命令的返回结果。</p> <ul><li><div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-cli -h 127.0.0.1 -p 6379 get hello</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li></ul> <h6 id="_5-2-3-停止redis服务"><a href="#_5-2-3-停止redis服务" class="header-anchor">#</a> 5.2.3 停止Redis服务</h6> <p>Redis提供了shutdown命令来停止Redis服务。</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-cli shutdown</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>有三点要注意：</p> <ul><li><p>Redis关闭的过程：断开与客户端的连接、持久化文件生成，是一种相对优雅的关闭方式。</p></li> <li><p>kill -9 也可以关闭redis，但是会造成Redis不会做持久化服务，还会造成缓冲区等资源不能被优雅关闭，极端情况会造成AOF和复制丢失数据的情况。</p></li> <li><p>shutdown还有一个参数，代表是是否在关闭Redis前，生成持久化文件：</p> <ul><li><div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token comment"># redis-cli shutdown nosave | save</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul></li></ul> <h3 id="_6-redis重大版本"><a href="#_6-redis重大版本" class="header-anchor">#</a> 6. Redis重大版本</h3> <h3 id="_7-总结"><a href="#_7-总结" class="header-anchor">#</a> 7. 总结</h3> <ul><li>redis的8个特性：速度快、基于键值对的数据结构服务器、功能丰富、简单稳定、客户端语言多、持久化、主从复制、支持高可用和分布式。</li> <li>redis并不是万金油，有些场景不适合使用Redis进行开发。</li> <li>开发运维结合以及阅读源码是用好Redis的重要方法。</li> <li>生产环境中使用配置文件启动Redis。</li> <li>生产环境选取稳定版本的Redis。</li> <li>Redis3.0是重要的里程碑，发布了Redis官方的分布式实现Redis Cluster。</li></ul> <h2 id="第二章-api的理解和使用"><a href="#第二章-api的理解和使用" class="header-anchor">#</a> 第二章 API的理解和使用</h2> <h3 id="_1-预备"><a href="#_1-预备" class="header-anchor">#</a> 1. 预备</h3> <h4 id="_1-1-全局命令"><a href="#_1-1-全局命令" class="header-anchor">#</a> 1.1 全局命令</h4> <ul><li><p>查看所有键：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> keys *
<span class="token number">1</span><span class="token punctuation">)</span> <span class="token string">&quot;eeiy&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>键总数：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> dbsize
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>dbsize命令在计算键总数时不会遍历所有键，而是直接获取Redis内置的键总数变量，所以dbsize命令的时间复杂度是O(1)。而keys命令会遍历所有键，所以它的时间复杂度是O(n)，当Redis保存了大量键时，线上环境禁止使用。</p></li> <li><p>检查键是否存在：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">127.0</span><span class="token number">.0</span><span class="token number">.1</span><span class="token operator">:</span><span class="token number">6379</span><span class="token operator">&gt;</span> exists eeiy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>如果存在返回1，不存在返回0</p></li> <li><p>删除键：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> del eeiy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>del是一个通用命令，无论值是什么数据结构类型，del命令都可以将其删除，del 命令可以删除多个键</p></li> <li><p>键过期：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl eeiy
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">596</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl eeiy2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -2
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> eeiy3 <span class="token number">1</span>
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl eeiy3
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> -1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>ttl命令会返回键的剩余过期时间，它有3种返回值：</p> <ul><li>大于等于0的整数：键剩余的过期时间。</li> <li>-1：键没设置过期时间。</li> <li>-2：键不存在。</li></ul></li> <li><p>键的数据结构类型：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">set</span> key1 value1
OK
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key1
string
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> rpush key2 a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key2
list
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> hset key3 eeiy corona eeiy2 corona2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key3
<span class="token builtin class-name">hash</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> sadd key4 a b c d e f
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">6</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key4
<span class="token builtin class-name">set</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> zadd key5 <span class="token number">1</span> a <span class="token number">2</span> b <span class="token number">3</span> c <span class="token number">4</span> d <span class="token number">5</span> e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key5
zset
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div></li></ul> <h4 id="_1-2-数据结构和内部编码"><a href="#_1-2-数据结构和内部编码" class="header-anchor">#</a> 1.2 数据结构和内部编码</h4> <p>type命令实际返回的就是当前键的数据结构类型，它们分别是：string（字符串）、hash（哈希）、list（列表）、set（集合）、zset（有序集合）。</p> <p>但这些只是Redis对外的数据结构。实际上每种数据结构都有自己底层的内部编码实现。</p> <p>每种数据结构都有两种以上的内部编码实现，例如list数据结构包含了linkedlist和ziplist两种内部编码。</p> <p>可以通过object encoding命令查询内部编码：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key1
string
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key2
list
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key3
<span class="token builtin class-name">hash</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key4
<span class="token builtin class-name">set</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> <span class="token builtin class-name">type</span> key5
zset
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key1
<span class="token string">&quot;embstr&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key2
<span class="token string">&quot;quicklist&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key3
<span class="token string">&quot;ziplist&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key4
<span class="token string">&quot;hashtable&quot;</span>
<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> object encoding key5
<span class="token string">&quot;ziplist&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">内部编码</th></tr></thead> <tbody><tr><td style="text-align:center;">string</td> <td style="text-align:center;">raw、int、embstr</td></tr> <tr><td style="text-align:center;">hash</td> <td style="text-align:center;">hashtable、ziplist</td></tr> <tr><td style="text-align:center;">lish</td> <td style="text-align:center;">linkedlist、ziplist</td></tr> <tr><td style="text-align:center;">set</td> <td style="text-align:center;">hashtable、intset</td></tr> <tr><td style="text-align:center;">zset</td> <td style="text-align:center;">skiplist、ziplist</td></tr></tbody></table> <h4 id="_1-3-单线程结构"><a href="#_1-3-单线程结构" class="header-anchor">#</a> 1.3 单线程结构</h4> <p>redis使用了单线程架构和I/O多路复用模型来实现高性能的内存数据库服务。</p> <p>为什么单线程还能这么快？</p> <ul><li>纯内存访问</li> <li>非阻塞I/O，Redis使用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为事件，不在网络I/O上浪费过多的时间。</li> <li>单线程避免了线程切换和竞态产生的消耗。</li></ul> <h3 id="_2-字符串"><a href="#_2-字符串" class="header-anchor">#</a> 2. 字符串</h3> <h4 id="_2-1-命令"><a href="#_2-1-命令" class="header-anchor">#</a> 2.1 命令</h4> <h5 id="_2-1-1-常用命令"><a href="#_2-1-1-常用命令" class="header-anchor">#</a> 2.1.1 常用命令</h5> <ul><li><p>设置值：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>set key value [ex seconds] [px milliseconds] [nx|xx]
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>set命令有几个选项：</p> <ul><li><p>ex seconds：为键设置秒级过期时间。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>set ex_key1 string1 ex 60
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>px milliseconds：为键设置毫秒级过期时间。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>set px_key1 string1 px 6000
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>nx：键必须不存在，才可以设置成功，用于添加。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>set px_key1 string1 px 6000 nx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>xx：与nx相反，键必须存在，才可以设置成功，用于更新。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>set px_key1 string1 px 6000 xx
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <p>除了set选项，Redis还提供了setex和setnx两个命令：</p> <ul><li><p>setex：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; setex ex_key1 60 ex_value1
OK
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>setnx：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; setnx ex_key1 60 nx_value1
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR wrong number of arguments for <span class="token string">'setnx'</span> command
127.0.0.1<span class="token punctuation">:</span>6379&gt; setnx ex_key1 nx_value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setnx nx_key1 nx_value1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li></ul> <p>setnx和setex在实际使用中有什么应用场景？以setnx命令为例子，由于Redis的单线程命令处理机制，如果有多个客户端同时执行setnx key value，根据setnx的特性只有一个客户端能设置成功，setnx可以作为分布式锁的一种实现方案，Redis官方给出了使用setnx实现分布式锁的方法:http://redis.io/topics/distlock。</p></li> <li><p>批量设置值：</p> <ul><li><p>mset：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>mset key1 value1 key2 value2 key3 value3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li> <li><p>mget：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>mget key1 key2 key3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; mset mkey1 mvalue1 mkey2 mvalu2 mkey3 mvalue3
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; mget mkey1 mkey2 mkey3
1<span class="token punctuation">)</span> <span class="token string">&quot;mvalue1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;mvalu2&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;mvalue3&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>计数：</p> <ul><li>incr：incr命令用于对值做自增操作，返回结果分为三种情况：
<ul><li>值不是整数，返回错误。</li> <li>值是整数，返回自增后的结果。</li> <li>键不存在，按照值为0自增，返回结果为1。</li></ul></li> <li>decr：自减。</li> <li>incrby：自增指定数字。</li> <li>decrby：自减指定数字。</li> <li>incrbyfloat：自增浮点数。</li></ul> <p>很多存储系统和编程语言内部使用CAS机制实现计数功能，会有一定的CPU开销，但在Redis中完全不存在这个问题，因为Redis是单线程架构，任何命令到了Redis服务端都要顺序执行。</p></li></ul> <h5 id="_2-1-2-不常用命令"><a href="#_2-1-2-不常用命令" class="header-anchor">#</a> 2.1.2 不常用命令</h5> <ul><li><p>追加值：append key value</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; append key1 world
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10
127.0.0.1<span class="token punctuation">:</span>6379&gt; get key1
<span class="token string">&quot;helloworld&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>字符串长度：strlen key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; strlen key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>设置并返回值：getset key value</p></li> <li><p>设置指定位置的字符：setrange key offeset value</p></li> <li><p>获取部分字符串：getrange key start end</p></li></ul> <h4 id="_2-2-内部编码"><a href="#_2-2-内部编码" class="header-anchor">#</a> 2.2 内部编码</h4> <p>字符串类型的内部编码有3种：</p> <ul><li>int：8个字节的长整型。</li> <li>embstr：小于等于39个字节的字符串。</li> <li>raw：大于39个字节的字符串。</li></ul> <p>Redis会根据当前值的类型和长度决定使用哪种内部编码实现。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; set string_key1 1234
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; object encoding string_key1
<span class="token string">&quot;int&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; set string_key1 <span class="token string">&quot;hello,world&quot;</span>
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; object encoding string_key1
<span class="token string">&quot;embstr&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; set string_key1 asihdasdiahsdahsdiabshdbahbdabsdadbsuasbdbadsasdjabdbaghsdvavsduvasduavusdasvdasdhasdhjahsda
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; object encoding string_key1
<span class="token string">&quot;raw&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h4 id="_2-3-典型使用场景"><a href="#_2-3-典型使用场景" class="header-anchor">#</a> 2.3 典型使用场景</h4> <h5 id="_2-3-1-缓存功能"><a href="#_2-3-1-缓存功能" class="header-anchor">#</a> 2.3.1 缓存功能</h5> <p>由于Redis具有支撑高 并发的特性，所以缓存通常能起到加速读写和降低后端压力的作用。</p> <p>设计合理的键名，有利于防止键冲突和项目的可维护性，比较推荐的方式是使用“业务名: 对象名: id: [属性]”作为键名。</p> <p>例如MySQL的数据库名为vs，用户表名为user，那么对应的键可以用“vs: user: 1”,&quot;vs: user: 1: name&quot;来表示。可以在描述键含义的前提下适当减少键的长度，从而减少键过长的内存浪费。</p> <h5 id="_2-3-2-计数"><a href="#_2-3-2-计数" class="header-anchor">#</a> 2.3.2 计数</h5> <p>用redis的incr功能。</p> <p>一个真实的计数系统要考虑的问题会很多：防作弊、按照不同维度计数，数据持久化到底层数据源等。</p> <h5 id="_2-3-3-共享session"><a href="#_2-3-3-共享session" class="header-anchor">#</a> 2.3.3 共享session</h5> <p>可以使用Redis将用户的Session进行集中管理，每次用户更新或者查询登录信息都直接从Redis中集中获取。</p> <h5 id="_2-3-4-限速"><a href="#_2-3-4-限速" class="header-anchor">#</a> 2.3.4 限速</h5> <p>比如短信防刷，网站限制一个IP地址不能在一秒钟之内访问超过n次。</p> <h3 id="_3-哈希"><a href="#_3-哈希" class="header-anchor">#</a> 3. 哈希</h3> <p>哈希即键值对的数据结构。</p> <h4 id="_3-1-命令"><a href="#_3-1-命令" class="header-anchor">#</a> 3.1 命令</h4> <ul><li><p>设置值：hset key field value</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hset user1 name1 corona
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>获取值：hget key field</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hget user1 name1
<span class="token string">&quot;corona&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>删除field：hdel key field</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hset user1 name corona
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; hset user1 age 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; hset user1 gender man
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; hdel user1 gender
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; hget user1 gender
<span class="token punctuation">(</span>nil<span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>计算field个数：hlen key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hlen user1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>批量设置或获取field-value：hmget key field [field ...]，hmset key field value [field value ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hmset user1 name corona age 20 gender man
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; hmget user1 name age gender
1<span class="token punctuation">)</span> <span class="token string">&quot;corona&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;20&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;man&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>判断field是否存在：hexists key field</p></li> <li><p>获取所有field：hkeys key，hkeys命令应该叫hfields更为恰当，它返回指定哈希键所有的field。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hkeys user1
1<span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;gender&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>获取所有value：hvals key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hvals user1
1<span class="token punctuation">)</span> <span class="token string">&quot;corona&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;20&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;man&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>获取所有的field-value：hgetall key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hgetall user1
1<span class="token punctuation">)</span> <span class="token string">&quot;name&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;corona&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;age&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;20&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;gender&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;man&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul> <p>在使用hgetall时，如果哈希元素个数比较多，会存在阻塞Redis的可能，如果开发人员只需要获取部分field，可以使用hmget，如果一定要获取全部field-value，可以使用hscan命令，该命令会渐进式遍历哈希类型。</p> <ul><li>hincrby：hincrby key field</li> <li>hincrbyfloat：hincrbyfloat key field</li> <li>hstrlen：hstrlen key field，计算value的字符串长度</li></ul> <h4 id="_3-2-内部编码"><a href="#_3-2-内部编码" class="header-anchor">#</a> 3.2 内部编码</h4> <p>哈希类型的内部编码有两种：</p> <ul><li>ziplist（压缩列表）：当哈希类型元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于hash-max-ziplist-value配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</li> <li>hashtable（哈希表）：当哈希类型无法满足ziplist的条件时，Redis会使用hashtable作为哈希的内部实现，因为此时ziplist的读写效率会下降，而hashtable的读写时间复杂度为O(1)。</li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; hset h_key1 name corona age 20
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1<span class="token punctuation">:</span>6379&gt; object encoding h_key1
<span class="token string">&quot;ziplist&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; hset h_key2 name coroanasdadhahdsasdasdbajsdajdhabsdabhsdhjasbdahbjsdbsdbahjsdhavdjhavbdjvajsdvjasdvajdvgahjsgdajsdhjagdsjavsgdjahsjvdhajbvsdjavdhbavsghjvhagsdhhsdhasjdhavghjdasdhavdhashdvahsdahdasdbasdkabsjdjabsdjajdhvajsvdavjsdvajvsdjavsjdvasjdajsdvjavdajsdvjasdajvdjavsdjavsdjasvjdajvsdjavsdgavdvavsgdvgavgsdvashvgdavghdsvavjsdvajdsajvsdajdsvajdajvdghavsjdbavdbjakbsdkajbdbasbdbasdbhasdasdbjkabskdasabkjdabkdbakbashdakhsdahdhaskdhaksdhkahsdjsahkdhakhsdahdhasdaksdhaksdhaksudhaushduiahisdhuasdhuaisdahisdhiashdiasidahsdhsdhadhjkajsdlhjalsdhajsdjsaldhjasdljsadalhdoadjasjdjasjdlahsdhlashldhasdhasdhiasihdlasdhilhasdhliashdhalsndamsdnsjldjappsjpajdpasdadnadoaodoahudnasldlnasdnalsdandaidaljsdlsadnalsnldjasdjlhalasdjajdl
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; object encoding h_key2
<span class="token string">&quot;hashtable&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_3-3-使用场景"><a href="#_3-3-使用场景" class="header-anchor">#</a> 3.3 使用场景</h4> <ul><li>记录实体信息。</li></ul> <p>哈希类型和关系型数据库有两点不同之处：</p> <ul><li>哈希类型是稀疏的，而关系型数据库是完全结构化的，例如哈希类型每个键都可以有不同的field，而关系型数据库一旦添加新的列，所有行都要为其设置值（即使为NULL）。</li> <li>关系型数据库可以做复杂的关系查询，而Redis去模拟关系型复杂查询开发困难，维护成本高。</li></ul> <p>三种方法缓存用户信息：</p> <ul><li>原生字符串类型，每个属性一个键。（不推荐）占用过多的键，内存占用量比较大。</li> <li>序列化字符串类型：将用户信息序列化后用一个键保存。
<ul><li>优点：简化变成，如果合理地使用序列化可以提高内存的使用效率。</li> <li>缺点：序列化和反序列化都有一定的开销，同时每次更新属性都需要把全部数据取出进行反序列化，更新后再序列化到Redis中。</li></ul></li> <li>哈希类型：每个用户属性使用一对field-value，但是只用一个键保存。
<ul><li>优点：简单直观，如果使用合理可以减少内存空间的使用。</li> <li>缺点：要控制哈希在ziplist和hashtable两种内部编码的转换，hashtable会消耗更多内存。</li></ul></li></ul> <h3 id="_4-列表"><a href="#_4-列表" class="header-anchor">#</a> 4. 列表</h3> <p>列表（list）类型是用来存储多个有序的字符串，列表中的每个字符串称为元素，一个列表最多可以存储2^32-1个元素。</p> <p>在Redis中，可以对列表两端插入（push）和弹出（pop），还可以获取指定范围的元素列表、获取指定索引下标的元素等。</p> <p>列表是一种比较灵活的数据结构，它可以充当栈和队列的角色，在实际开发上有很多应用场景。</p> <p>列表类型有两个特点：有序、可重复。</p> <h4 id="_4-1-命令"><a href="#_4-1-命令" class="header-anchor">#</a> 4.1 命令</h4> <table><thead><tr><th style="text-align:center;">操作类型</th> <th style="text-align:center;">操作</th></tr></thead> <tbody><tr><td style="text-align:center;">添加</td> <td style="text-align:center;">rpush lpush linsert</td></tr> <tr><td style="text-align:center;">查询</td> <td style="text-align:center;">lrange lindex llen</td></tr> <tr><td style="text-align:center;">删除</td> <td style="text-align:center;">lpop rpop lrem ltrim</td></tr> <tr><td style="text-align:center;">修改</td> <td style="text-align:center;">lset</td></tr> <tr><td style="text-align:center;">阻塞操作</td> <td style="text-align:center;">blpop brpop</td></tr></tbody></table> <h5 id="_4-1-1-添加操作"><a href="#_4-1-1-添加操作" class="header-anchor">#</a> 4.1.1 添加操作</h5> <ul><li><p>rpush：从右边插入元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; rpush list_key1 a b c d e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>lpush：从左边插入元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; lpush list_key1 a b c d e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>linsert：向某个元素前或者后插入元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; rpush list_key1 b c d 
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; linsert list_key1 before b a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; linsert list_key1 after d e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;e&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div></li></ul> <h5 id="_4-1-2-查找"><a href="#_4-1-2-查找" class="header-anchor">#</a> 4.1.2 查找</h5> <ul><li><p>lrange key start end ：获取指定范围内的元素列表</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;e&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>lindex key index：获取列表指定索引下标的元素</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; lindex list_key1 0
<span class="token string">&quot;a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>llen：获取列表长度</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; llen list_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul> <h5 id="_4-1-3-删除"><a href="#_4-1-3-删除" class="header-anchor">#</a> 4.1.3 删除</h5> <ul><li><p>lpop key：从列表左侧弹出元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; lpop list_key1
<span class="token string">&quot;a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>rpop key：从列表右侧弹出元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; rpop list_key1
<span class="token string">&quot;e&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>lrem key count value：删除指定元素。lrem命令会从列表中找到等于value的元素进行删除，根据count的不同分为三种情况：</p> <ul><li><p>count &gt; 0 ，从左到右，删除最多count个元素。</p></li> <li><p>count &lt; 0 ，从右到左，删除最多count绝对值个元素。</p></li> <li><p>count = 0 ，删除所有。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; lrem list_key1 1 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul></li> <li><p>ltrim key start end：按照索引范围修剪列表。只保留start 到 end的元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; ltrim list_key1 0 0
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <h5 id="_4-1-4-修改"><a href="#_4-1-4-修改" class="header-anchor">#</a> 4.1.4 修改</h5> <ul><li><p>lset key index newValue：修改指定索引下标的元素。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; rpush list_key1 a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; lset list_key1 2 d
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; lrange list_key1 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li></ul> <h5 id="_4-1-5-阻塞操作"><a href="#_4-1-5-阻塞操作" class="header-anchor">#</a> 4.1.5 阻塞操作</h5> <ul><li>blpop key [key ...] timeout</li> <li>brpop key [key ...] timeout</li></ul> <p>blpop和brpop是lpop和rpop的阻塞版本，它们除了弹出方向不同，使用方法基本相同，所以下面以brpop命令进行说明，brpop命令包含两个参数：</p> <ul><li>key[key ...]：多个列表的键。</li> <li>timeout：阻塞时间（单位：秒）。</li></ul> <ol><li><p>列表为空：如果timeout=3，那么客户端要等到3秒后返回，如果timeout=0，那么客户端一直阻塞下去。</p></li> <li><p>列表不为空：客户端会立即返回。</p></li></ol> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; brpop bl_key1 bl_key2 bl_key3 0
1<span class="token punctuation">)</span> <span class="token string">&quot;bl_key1&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
<span class="token punctuation">(</span>9.37s<span class="token punctuation">)</span>

127.0.0.1<span class="token punctuation">:</span>6379&gt; rpush bl_key1 a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="_4-2-内部编码"><a href="#_4-2-内部编码" class="header-anchor">#</a> 4.2 内部编码</h4> <p>列表类型的内部编码有两种：</p> <ul><li>ziplist（压缩列表）：当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</li> <li>linkedlist（链表）：当列表类型无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</li> <li>quicklist：Redis3.2版本提供了quicklist内部编码，简单地说它是以一个ziplist为节点的linkedlist，它结合了ziplist和linkedlist两者的优势，为列表类型提供了一种更为优秀的内部编码实现。</li></ul> <h4 id="_4-3-使用场景"><a href="#_4-3-使用场景" class="header-anchor">#</a> 4.3 使用场景</h4> <h5 id="_4-3-1-消息队列"><a href="#_4-3-1-消息队列" class="header-anchor">#</a> 4.3.1 消息队列</h5> <p>redis的lpush+brpop命令组合即可实现阻塞队列，生产者客户端使用lrpush从列表左侧插入元素，多个消费者客户端使用brpop命令阻塞式的“抢”列表尾部的元素，多个客户端保证了消费的负载均衡和高可用性。</p> <h5 id="_4-3-2-文章列表"><a href="#_4-3-2-文章列表" class="header-anchor">#</a> 4.3.2 文章列表</h5> <p>每个用户都有属于自己的文章列表，现需要分页展示文章列表。此时可以考虑使用列表，因为列表不是有序的，同时支持按照索引范围获取元素。</p> <p>实际上列表的使用场景很多，在选择时可以参考以下口诀：</p> <ul><li>lpush+lpop=Stack（栈）</li> <li>lpush+rpop=Queue（队列）</li> <li>lpush+ltrim=Capped Collection（有限集合）</li> <li>lpush+brpop=Message Queue（消息队列）</li></ul> <h3 id="_5-集合"><a href="#_5-集合" class="header-anchor">#</a> 5. 集合</h3> <p>集合（set）类型也是用来保存多个的字符串元素，但和列表类型不一样的是，集合中不允许有重复元素，并且集合中的元素是无序的，不能通过索引下标获取元素。</p> <p>Redis除了支持集合内的增删改查，同时还支持多个集合取交集、并集、差集，合理地使用好集合类型，能在实际开发中解决很多实际问题。</p> <h4 id="_5-1-命令"><a href="#_5-1-命令" class="header-anchor">#</a> 5.1 命令</h4> <h5 id="_5-1-1-集合内操作"><a href="#_5-1-1-集合内操作" class="header-anchor">#</a> 5.1.1 集合内操作</h5> <ul><li><p>添加元素：sadd key element [element ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd set_key1 a a b c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1<span class="token punctuation">:</span>6379&gt; smembers set_key1
1<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>删除元素：srem key element [element ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; srem set_key1 a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; smembers set_key1
1<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>计算元素个数：scard key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; scard set_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>scard的时间复杂度为O（1），它不会遍历集合所有元素，而是直接用 Redis内部的变量</p></li> <li><p>判断元素是否在集合中：sismember key element</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sismember set_key1 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>随机从集合返回指定个数元素：srandmember key [count]，[count]是可选参数，如果不写默认为1</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; srandmember set_key1
<span class="token string">&quot;c&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>从集合随机弹出元素：spop key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd set_key2 a b c d e f g h i j
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10
127.0.0.1<span class="token punctuation">:</span>6379&gt; spop set_key2
<span class="token string">&quot;e&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; 
127.0.0.1<span class="token punctuation">:</span>6379&gt; spop set_key2 3
1<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;i&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;j&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>获取所有元素：smembers key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; smembers set_key2
1<span class="token punctuation">)</span> <span class="token string">&quot;h&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;f&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;g&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div></li></ul> <p>smembers和lrange、hgetall都属于比较重的命令，如果元素过多存在阻塞Redis的可能性，这时候可以使用sscan来完成。</p> <h5 id="_5-1-2-集合间操作"><a href="#_5-1-2-集合间操作" class="header-anchor">#</a> 5.1.2 集合间操作</h5> <ul><li><p>求多个集合的交集：sinter key [key ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd s_key1 dog cat animal
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd s_key2 dog sit sh
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
127.0.0.1<span class="token punctuation">:</span>6379&gt; sinter s_key1 s_key2
1<span class="token punctuation">)</span> <span class="token string">&quot;dog&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>求多个集合的并集：sunion key [key ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sunion s_key1 s_key2
1<span class="token punctuation">)</span> <span class="token string">&quot;dog&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;cat&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;animal&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;sit&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;sh&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>求多个集合的差集：sdiff key [key ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; sdiff s_key1 s_key2
1<span class="token punctuation">)</span> <span class="token string">&quot;animal&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;cat&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>将交集、并集、差集的结果保存：sinterstore、sunionstore、sdiffstore</p> <ul><li>sinterstore destination key [key ...]</li> <li>sunionstore destination key [key ...]</li> <li>sdiffstore destination key [key ...]</li></ul></li></ul> <p>集合间的运算在元素较多的情况下会比较耗时，所以Redis提供了上面三个命令（原命令+store）将集合间交集、并集、差集的结果保存在destination key中。</p> <h4 id="_5-2-内部编码"><a href="#_5-2-内部编码" class="header-anchor">#</a> 5.2 内部编码</h4> <p>集合类型的内部编码有两种：</p> <ul><li>intset（整数集合）：当集合中的元素都是整数且元素个数小于set-max-intset-entries配置（默认512个）时，Redis会选用intset来作为集合的内部实现，从而减少内存的使用。</li> <li>hashtable（哈希表）：当集合类型无法满足intset的条件时，Redis会使用hashtable作为集合的内部实现。</li></ul> <h4 id="_5-3-使用场景"><a href="#_5-3-使用场景" class="header-anchor">#</a> 5.3 使用场景</h4> <p>标签。给用户添加标签，给标签添加用户。</p> <ul><li>sadd = Tagging（标签）</li> <li>spop/srandmember=Random item（生成随机数，比如抽奖）</li> <li>sadd+sinter=Social Graph（社交需求）</li></ul> <h3 id="_6-有序集合"><a href="#_6-有序集合" class="header-anchor">#</a> 6. 有序集合</h3> <p>有序集合保留了集合不能有重复成员的特性，但不同的是，有序集合中的元素可以排序，但是它和列表使用索引下标作为排序依据不同的是，它给每个元素设置一个分数（score）作为排序的依据。</p> <table><thead><tr><th style="text-align:center;">数据结构</th> <th style="text-align:center;">是否允许重复元素</th> <th style="text-align:center;">是否有序</th> <th style="text-align:center;">有序实现方式</th> <th style="text-align:center;">应用场景</th></tr></thead> <tbody><tr><td style="text-align:center;">列表</td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td> <td style="text-align:center;">索引下标</td> <td style="text-align:center;">时间轴、消息队列</td></tr> <tr><td style="text-align:center;">集合</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td> <td style="text-align:center;">无</td> <td style="text-align:center;">标签、社交</td></tr> <tr><td style="text-align:center;">有序集合</td> <td style="text-align:center;">否</td> <td style="text-align:center;">是</td> <td style="text-align:center;">分值</td> <td style="text-align:center;">排行榜系统、社交</td></tr></tbody></table> <h4 id="_6-1-命令"><a href="#_6-1-命令" class="header-anchor">#</a> 6.1 命令</h4> <h5 id="_6-1-1-集合内的操作"><a href="#_6-1-1-集合内的操作" class="header-anchor">#</a> 6.1.1 集合内的操作</h5> <ul><li><p>添加成员：zadd key score member [score member ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zadd z_key1 10 a 20 b 30 c
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>有关zadd命令有两点需要注意：Redis3.2为zadd命令添加了nx、xx、ch、incr四个选项：</p> <ul><li>nx：member必须不存在，才可以设置成功，用于添加。</li> <li>xx：member必须存在，才可以设置成功，用于更新。</li> <li>ch：返回此次操作后，有序集合元素和分数发生变化的个数。</li> <li>incr：对score做增加后，相当于后面介绍的zincrby。</li> <li>有序集合相比集合提供了排序字段，但是也产生了代价，zadd的时间复杂度为O(log(n))，sadd的时间复杂度为O(1)。</li></ul></li> <li><p>计算成员个数：zcard key</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zcard z_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>和集合类型的scard命令一样，zcard的时间复杂度为O(1)。</li></ul></li> <li><p>计算某个成员的分数：zscore key member</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zscore z_key1 a
<span class="token string">&quot;10&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>计算成员的排名：zrank key member / zrevrank key member</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zrank z_key1 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; zrevrank z_key1 b
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>删除成员：zrem key member [member ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zrem z_key1 a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>增加成员的分数：zincrby key increment member</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zincrby z_key1 10 c
<span class="token string">&quot;40&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>返回指定排名范围的成员：zrange key start end [withscores] / zrevrange key start end [withscores]</p> <ul><li><p>有序集合是按照分值排名的，zrange是从低到高返回，zrevrange反之。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zrange z_key2 0 -1 withscores
1<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;-10&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;10&quot;</span>
5<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
6<span class="token punctuation">)</span> <span class="token string">&quot;15&quot;</span>
7<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
8<span class="token punctuation">)</span> <span class="token string">&quot;20&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; zrange z_key2 0 -1
1<span class="token punctuation">)</span> <span class="token string">&quot;d&quot;</span>
2<span class="token punctuation">)</span> <span class="token string">&quot;b&quot;</span>
3<span class="token punctuation">)</span> <span class="token string">&quot;a&quot;</span>
4<span class="token punctuation">)</span> <span class="token string">&quot;c&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div></li></ul></li> <li><p>返回指定分数范围的成员：zrangebyscore key min max [withscores] [limi offset count] / zrevrangebyscore key min max [withscores] [limit offset count]</p> <ul><li>其中zrangebyscore按照分数从低到高返回，zrevrangebyscore反之。withscores选项会同时返回每个成员的分数。[limit offset count]选项可以限制输出的起始位置和个数。同时min和max还支持开区间（小括号）和闭区间（中括号），-inf和+inf分别代表无限小和无限大。</li></ul></li> <li><p>返回指定分数范围成员个数：zcount key min max</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zcount z_key2 -inf +inf
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 4
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>删除指定排名内的升序元素：zremrangebyrank key start end</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zremrangebyrank z_key2 0 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>删除指定分数范围的成员：zremrangebyscore key min max</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; zremrangebyscore z_key2 -100 100
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li></ul> <h5 id="_6-1-2-集合间的操作"><a href="#_6-1-2-集合间的操作" class="header-anchor">#</a> 6.1.2 集合间的操作</h5> <ul><li>交集：zinterstore destination numkeys key [key ...] [weights weight [weight ...]]：
<ul><li>这个命令参数较多，下面分别进行说明：</li> <li>destination：交集计算结果保存到这个键。</li> <li>numkeys：需要做交集计算键的个数。</li> <li>key[key ...]：需要做交集计算的键。</li> <li>weights weight[weight ...]：每个键的权重，在做交集计算时，每个键中的每个member会将自己分数乘以这个权重，每个键的权重默认是1。</li> <li>aggregate sum|min|max：计算成员交集后，分值可以按照sum（和）、min（最小值）、max（最大值）做汇总，默认值是sum。</li></ul></li> <li>并集：zunionstore destination numkeys key [key ...] [weights weight [weight ...]]：</li></ul> <h4 id="_6-2-内部编码"><a href="#_6-2-内部编码" class="header-anchor">#</a> 6.2 内部编码</h4> <p>有序集合类型的内部编码有两种：</p> <ul><li>ziplist（压缩列表）：当有序集合的元素个数小于zset-max-ziplist-entries配置（默认128个），同时每个元素的值都小于zset-max-ziplist-value配置（默认64字节）时，Redis会用ziplist来作为有序集合的内部实现，ziplist可以有效减少内存的使用。</li> <li>skiplist（跳跃表）：当ziplist条件不满足时，有序集合会使用skiplist作为内部实现，因为此时ziplist的读写效率会下降。</li></ul> <h4 id="_6-3-使用场景"><a href="#_6-3-使用场景" class="header-anchor">#</a> 6.3 使用场景</h4> <p>有序集合比较典型的使用场景就是排行榜系统。</p> <ul><li>添加用户赞数：zadd和zincrby</li> <li>取消用户赞数：zrem</li> <li>展示获取赞数最多的十个用户：zrevrange</li> <li>展示用户信息以及用户分数：zscore和zrank</li></ul> <h3 id="_7-键管理"><a href="#_7-键管理" class="header-anchor">#</a> 7. 键管理</h3> <h4 id="_7-1-单个键管理"><a href="#_7-1-单个键管理" class="header-anchor">#</a> 7.1 单个键管理</h4> <ul><li>rename key newkey：键重命名</li> <li>renamenx key newkey：键重命名</li> <li>randomkey：随机返回一个键</li> <li>expire key seconds：键在seconds秒后过期</li> <li>expireat key timestamp：键在秒级时间戳timestamp后过期</li> <li>ttl命令和pttl都可以查询键的剩余过期时间，但是pttl精度更高可以达到毫秒级别</li> <li>pexpire key milliseconds：键在milliseconds毫秒后过期。</li> <li>prexpireat key milliseconds-timestamp键在毫秒级时间戳timestamp后过期。</li></ul> <p>在使用Redis相关过期命令时，需要注意以下几点。</p> <ul><li>如果expire key的键不存在，返回结果为0。</li> <li>如果过期时间为负值，键会立即被删除，犹如使用del命令一样。</li> <li>persist命令可以将键的过期时间清除</li> <li>对于字符串类型键，执行set命令会去掉过期时间。</li> <li>Redis不支持二级数据结构（例如哈希、列表）内部元素的过期功能，例如不能对列表类型的一个元素做过期时间设置。</li> <li>setex命令作为set+expire的组合，不但是原子执行，同时减少了一次网络通讯的时间。</li></ul> <p>迁移键：move，dump+restore，migrate</p> <ul><li>move：move key db，命令用于在Redis内部进行数据迁移。</li> <li>dump+restore：dump key restore key ttl value，dump+restore可以实现在不同的Redis实例之间进行数据迁移的功能，整个迁移的过程分为两步：
<ul><li>在源Redis上，dump命令会将键值序列化，格式采用的是RDB格式。</li> <li>在目标Redis上，restore命令将上面序列化的值进行复原，其中ttl参数代表过期时间，如果ttl=0代表没有过期时间。</li> <li>有关dump+restore有两点需要注意：第一，整个迁移过程并非原子性的，而是通过客户端分布完成的。第二， 迁移过程是开启了两个客户端连接，所以dump的结果不是在源Redis和目标Redis之间进行传输。</li></ul></li> <li>migrate：migrate host port key|&quot;&quot; destination-db timeout [copy] [replace] [keys key [key ...]]
<ul><li>migrate 命令也是用于在Redis实例间进行数据迁移的，实际上migrate命令就是将dump、restore、del三个命令进行组合，从而简化了操作流程。migrate命令具有原子性，而且从Redis3.0.6版本以后已经支持迁移多个键的功能，有效地提高了迁移效率。</li> <li>migrate实现过程和dump+restore基本类似，但是有3点不太相同：第一，整个过程是原子执行的，不需要在多个Redis实例上开启客户端的，只需要在源Redis执行migrate命令即可。第二，migrate命令的数据传输直接在源Redis和目标Redis上完成的。第三，目标Redis完成restore后会发送OK给源Redis，源Redis接收后会根据migrate对应的选项来决定是否在源Redis上删除对应的键。</li></ul></li></ul> <table><thead><tr><th style="text-align:center;">命令</th> <th style="text-align:center;">作用域</th> <th style="text-align:center;">原子性</th> <th style="text-align:center;">支持多个键</th></tr></thead> <tbody><tr><td style="text-align:center;">move</td> <td style="text-align:center;">Redis实例内部</td> <td style="text-align:center;">是</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">dump + restore</td> <td style="text-align:center;">Redis实例之间</td> <td style="text-align:center;">否</td> <td style="text-align:center;">否</td></tr> <tr><td style="text-align:center;">migrate</td> <td style="text-align:center;">Redis实例之间</td> <td style="text-align:center;">是</td> <td style="text-align:center;">是</td></tr></tbody></table> <h4 id="_7-2-遍历键"><a href="#_7-2-遍历键" class="header-anchor">#</a> 7.2 遍历键</h4> <ul><li><p>全量遍历键：keys pattern</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; keys *
 1<span class="token punctuation">)</span> <span class="token string">&quot;key4&quot;</span>
 2<span class="token punctuation">)</span> <span class="token string">&quot;mkey1&quot;</span>
 3<span class="token punctuation">)</span> <span class="token string">&quot;ziplist&quot;</span>
 4<span class="token punctuation">)</span> <span class="token string">&quot;mkey3&quot;</span>
 5<span class="token punctuation">)</span> <span class="token string">&quot;h_key1&quot;</span>
 6<span class="token punctuation">)</span> <span class="token string">&quot;h_key2&quot;</span>
 7<span class="token punctuation">)</span> <span class="token string">&quot;key5&quot;</span>
 8<span class="token punctuation">)</span> <span class="token string">&quot;string_key1&quot;</span>
 9<span class="token punctuation">)</span> <span class="token string">&quot;s_key2&quot;</span>
10<span class="token punctuation">)</span> <span class="token string">&quot;key2&quot;</span>
11<span class="token punctuation">)</span> <span class="token string">&quot;set_key2&quot;</span>
12<span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
13<span class="token punctuation">)</span> <span class="token string">&quot;key1&quot;</span>
14<span class="token punctuation">)</span> <span class="token string">&quot;set_key1&quot;</span>
15<span class="token punctuation">)</span> <span class="token string">&quot;list_ziplist&quot;</span>
16<span class="token punctuation">)</span> <span class="token string">&quot;bl_key1&quot;</span>
17<span class="token punctuation">)</span> <span class="token string">&quot;z_key1&quot;</span>
18<span class="token punctuation">)</span> <span class="token string">&quot;user1&quot;</span>
19<span class="token punctuation">)</span> <span class="token string">&quot;list_key1&quot;</span>
20<span class="token punctuation">)</span> <span class="token string">&quot;s_key1&quot;</span>
21<span class="token punctuation">)</span> <span class="token string">&quot;nx_key1&quot;</span>
22<span class="token punctuation">)</span> <span class="token string">&quot;mkey2&quot;</span>
23<span class="token punctuation">)</span> <span class="token string">&quot;eeiy3&quot;</span>
24<span class="token punctuation">)</span> <span class="token string">&quot;key3&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div></li> <li><p>渐进式遍历：scan，和keys命令执行时会遍历所有键不同，scan采用渐进式遍历的方式来解决keys命令可能带来的阻塞问题，每次scan命令的时间复杂度是O(1)，但是要真正实现keys的功能，需要执行多次scan。</p> <ul><li><p>scan的使用方法如下：scan cursor [match pattern] [count number]</p></li> <li><p>cursor是必需参数，实际上cursor是一个游标，第一次遍历从0开始，每次scan遍历完都会返回当前游标的值，直到游标值为0，表示遍历结束。</p></li> <li><p>match pattern是可选参数，它的作用的是做模式的匹配，这点和keys的模式匹配很像。</p></li> <li><p>count number是可选参数，它的作用是表明每次要遍历的键个数，默认值是10，此参数可以适当增大。</p></li> <li><div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; scan 0
1<span class="token punctuation">)</span> <span class="token string">&quot;10&quot;</span>
2<span class="token punctuation">)</span>  1<span class="token punctuation">)</span> <span class="token string">&quot;mkey3&quot;</span>
    2<span class="token punctuation">)</span> <span class="token string">&quot;h_key1&quot;</span>
    3<span class="token punctuation">)</span> <span class="token string">&quot;h_key2&quot;</span>
    4<span class="token punctuation">)</span> <span class="token string">&quot;nx_key1&quot;</span>
    5<span class="token punctuation">)</span> <span class="token string">&quot;mkey1&quot;</span>
    6<span class="token punctuation">)</span> <span class="token string">&quot;set_key2&quot;</span>
    7<span class="token punctuation">)</span> <span class="token string">&quot;key3&quot;</span>
    8<span class="token punctuation">)</span> <span class="token string">&quot;key4&quot;</span>
    9<span class="token punctuation">)</span> <span class="token string">&quot;z_key1&quot;</span>
   10<span class="token punctuation">)</span> <span class="token string">&quot;user1&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; scan 10
1<span class="token punctuation">)</span> <span class="token string">&quot;29&quot;</span>
2<span class="token punctuation">)</span>  1<span class="token punctuation">)</span> <span class="token string">&quot;string_key1&quot;</span>
    2<span class="token punctuation">)</span> <span class="token string">&quot;list_key1&quot;</span>
    3<span class="token punctuation">)</span> <span class="token string">&quot;set_key1&quot;</span>
    4<span class="token punctuation">)</span> <span class="token string">&quot;list_ziplist&quot;</span>
    5<span class="token punctuation">)</span> <span class="token string">&quot;bl_key1&quot;</span>
    6<span class="token punctuation">)</span> <span class="token string">&quot;key5&quot;</span>
    7<span class="token punctuation">)</span> <span class="token string">&quot;mkey2&quot;</span>
    8<span class="token punctuation">)</span> <span class="token string">&quot;eeiy3&quot;</span>
    9<span class="token punctuation">)</span> <span class="token string">&quot;ziplist&quot;</span>
   10<span class="token punctuation">)</span> <span class="token string">&quot;hello&quot;</span>
   11<span class="token punctuation">)</span> <span class="token string">&quot;key1&quot;</span>
127.0.0.1<span class="token punctuation">:</span>6379&gt; scan 29
1<span class="token punctuation">)</span> <span class="token string">&quot;0&quot;</span>
2<span class="token punctuation">)</span> 1<span class="token punctuation">)</span> <span class="token string">&quot;s_key2&quot;</span>
   2<span class="token punctuation">)</span> <span class="token string">&quot;key2&quot;</span>
   3<span class="token punctuation">)</span> <span class="token string">&quot;s_key1&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br></div></div><p>除了scan以外，Redis提供了面向哈希类型、集合类型、有序集合的扫描遍历命令，解决诸如hgetall、smembers、zrange可能会产生的阻塞问题，对应的命令分别是hscan、sscan、zscan，它们的用法和scan基本类似。渐进式遍历可以有效地解决keys命令可能产生的阻塞问题，但是scan并非完美无瑕，如果在scan的过程中如果有键的变化（增加、删除、修改），那么遍历效果可能会碰到如下问题：新增的键可能没有遍历到，遍历出了重复的键等情况，也就是说scan并不能保证完整地遍历出来所有的键。</p></li></ul></li></ul> <h4 id="_7-3-数据库管理"><a href="#_7-3-数据库管理" class="header-anchor">#</a> 7.3 数据库管理</h4> <p>dbsize、select、flushdb/flushall。</p> <ul><li>切换数据库：select dbIndex。
<ul><li>Redis默认配置中是有16个数据库。Redis3.0中已经逐渐弱化这个功能，例如Redis的分布式实现Redis Cluster只允许使用0号数据库，只不过为了向下兼容老版本的数据库功能，该功能没有完全废弃掉。为什么要废弃这个功能？
<ul><li>redis是单线程的，如果使用多个数据库，这些数据库依然是使用一个CPU，彼此之间还是会受影响。</li> <li>多数据库的使用方式，会让调试和运维不同业务的数据库变得困难，加入有一个慢查询存在，依然会影响其他数据库。</li> <li>部分Redis的客户端根本就不支持这种方式。</li></ul></li></ul></li> <li>清除数据库：flushdb/flushall命令用于清除数据库，两者的区别是flushdb只清除当前数据库，flushall会清除所有数据库。如果当前数据库键值数量比较多，flushdb/flushall存在阻塞Redis的可能性。</li></ul> <h4 id="_7-4-总结"><a href="#_7-4-总结" class="header-anchor">#</a> 7.4 总结</h4> <ul><li>Redis提供5种数据结构，每种数据结构都有多种内部编码实现。</li> <li>纯内存存储、IO多路复用技术、单线程架构是造就Redis高性能的三个因素。</li> <li>由于Redis的单线程架构，所以需要每个命令能被快速执行完，否则会存在阻塞Redis的可能，理解Redis单线程命令处理机制是开发和运维Redis的核心之一。</li> <li>批量操作（例如mget、mset、hmset等）能够有效提高命令执行的效率，但要注意每次批量操作的个数和字节数。</li> <li>了解每个命令的时间复杂度在开发中至关重要，例如在使用keys、hgetall、smembers、zrange等时间复杂度较高的命令时，需要考虑数据规模对Redis的影响。</li> <li>persist命令可以删除任意类型键的过期时间，但是set命令也会删除字符串类型键的过期时间。</li> <li>move、dump+restore、migrate是Redis发展过程中迁移键的方式，其中move命令基本废弃，migrate命令用原子性的方式实现了dump+restore，并且支持批量操作，是Redis Cluster实现水平扩容的重要工具。</li> <li>scan命令可以解决keys命令可能带来的阻塞问题，同时Redis还提供了hscan、sscan、zscan渐进式遍历hash、set、zset。</li></ul> <h2 id="第三章-小功能大用处"><a href="#第三章-小功能大用处" class="header-anchor">#</a> 第三章 小功能大用处</h2> <p>Redis提供的5种数据结构已经足够强大，但除此之外，Redis还提供了诸如慢查询分析、功能强大的Redis Shell、Pipeline、事务与Lua脚本、Bitmaps、HyperLogLog、发布订阅、GEO等附加功能。</p> <ul><li>慢查询分析：通过慢查询分析，找到有问题的命令进行优化。</li> <li>Redis Shell：功能强大的Redis Shell会有意想不到的实用功能。</li> <li>Pipeline：通过Pipeline（管道或者流水线）机制有效提高客户端性能。</li> <li>事务与Lua：制作自己的专属原子命令。</li> <li>Bitmaps：通过在字符串数据结构上使用位操作，有效节省内存，为开发提供新的思路。</li> <li>HyperLogLog：一种基于概率的新算法，难以想象地节省内存空间。</li> <li>发布订阅：基于发布订阅模式的消息通信机制。</li> <li>GEO：Redis3.2提供了基于地理位置信息的功能。</li></ul> <h3 id="_1-慢查询分析"><a href="#_1-慢查询分析" class="header-anchor">#</a> 1. 慢查询分析</h3> <p>许多存储系统提供慢查询日志。所谓慢查询日志就是系统在命令执行前后计算每条命令的执行时间，当超过预设阈值，就将这条命令的相关信息记录下来，Redis也提供了类似的功能。</p> <p>一条客户端命令的生命周期为：</p> <ul><li>发送命令</li> <li>命令排队</li> <li>命令执行：慢查询只统计这一步的时间，所以没有慢查询并不代表客户端没有超时。</li> <li>返回结果</li></ul> <h4 id="_1-1-慢查询的两个配置参数"><a href="#_1-1-慢查询的两个配置参数" class="header-anchor">#</a> 1.1 慢查询的两个配置参数</h4> <p>对于慢查询功能，需要明确两件事：</p> <ul><li>预设阈值怎么设置？</li> <li>慢查询记录存放在哪？</li></ul> <p>showlog-log-lower-than：预设阈值，单位是微妙，默认值是10000，如果执行时间超过了10000微妙，那么它将被记录在慢查询日志中。</p> <p>如果showlog-log-lower-than：0，会记录所有的日志，&lt;0，对于任何命令都不会进行记录。</p> <p>showlog-max-len：Redis使用了一个列表来存储慢查询日志，slowlog-max-len就是列表的最大长度。一个新的命令满足慢查询条件时被插入到这个列表中，当慢查询日志列表已处于其最大长度时，最早插入的一个命令将从列表中移出。</p> <p>在Redis中有两种修改配置的方法，一直那是修改配置文件，另一种是使用config set命令动态修改。</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>config <span class="token builtin class-name">set</span> slowlog-log-slower-than <span class="token number">20000</span>
config <span class="token builtin class-name">set</span> slowlog-max-len <span class="token number">1000</span>
config rewrite
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>如果要Redis将配置持久化到本地配置文件，需要执行config reset命令。</p> <ul><li><p>获取慢查询日志：slowlog get [n]</p> <ul><li>慢查询日志由四个属性组成：
<ul><li>标识id</li> <li>发生时间戳</li> <li>命令耗时</li> <li>执行命令和参数</li></ul></li></ul></li> <li><p>获取慢查询日志当前的长度：slowlog len</p></li> <li><p>慢查询日志重置：slowlog reset</p></li></ul> <h4 id="_1-2-最佳实践"><a href="#_1-2-最佳实践" class="header-anchor">#</a> 1.2 最佳实践</h4> <ul><li>showlog-max-len配置建议：建议调大慢查询列表，不会占很多内存，线上可以设置为1000以上。</li> <li>showlog-log-slower-than配置建议：默认值超过10毫秒判定为慢查询，需要根据Redis并发量调整该值。由于Redis采用单线程响应命令，对于高流量的场景，如果命令执行时间在1毫秒以上，那么Redis最多可支撑QPS不到1000。因此对于高QPS场景的Redis建议设置为1毫秒。</li> <li>慢查询只记录命令执行时间，并不包括命令排队和网络传输时间。因此客户端执行命令的时间会大于命令实际执行时间。因为命令执行排队机制，慢查询会导致其他命令级联阻塞，因此客户端出现请求超时，需要检查该时间点是否有对应的慢查询，从而分析出是否为慢查询导致的命令级联阻塞。</li> <li>由于慢查询日志是一个先进先出的队列，也就是说如果慢查询比较多的情况下，可能会丢失部分慢查询命令，为了防止这种情况发生，可以定期执行slow get命令将慢查询日志持久化到其他存储中，然后可以制作可视化界面进行查询。</li></ul> <h3 id="_2-redis-shell"><a href="#_2-redis-shell" class="header-anchor">#</a> 2. Redis Shell</h3> <p>Redis提供了redis-cli、redis-server、redis-benchmark等shell工具。</p> <h4 id="_2-1-redis-cli"><a href="#_2-1-redis-cli" class="header-anchor">#</a> 2.1 redis-cli</h4> <ul><li><p>-r：代表命令会被执行多次</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314 -r 3 ping
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
PONG
PONG
PONG
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>-i（interval）：每隔几秒执行一次命令，-i必须和-r一起使用。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314 -r 3 -i 1 ping
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
PONG
PONG
PONG
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>-x：-x选项代表从标准输入（stdin）读取数据作为redis-cli的最后一个参数。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# echo world | redis-cli -a hqjmz5201314 -x set hello
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
OK
[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314 get hello
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
<span class="token string">&quot;world\n&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>-c（cluster）：连接Redis Cluster节点时需要使用的，-c选项可以防止moved和ask异常。</p></li> <li><p>-a：如果Redis配置了密码，可以用-a（auth）选项，有了这个选项就不需要再手动输入auth命令。</p></li> <li><p>--scan和--pattern：--scan选项和--pattern选项用于扫描指定模式的键，相当于使用scan命令。</p></li> <li><p>--slave：把当前客户端模拟成当前Redis节点的从节点，可以用来获取当前Redis节点的更新操作。ping命令是由于主从复制产的。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314 --slave
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
SYNC with master<span class="token punctuation">,</span> discarding 1452 bytes of bulk transfer...
SYNC done. Logging commands from master.
<span class="token string">&quot;PING&quot;</span>
<span class="token string">&quot;SELECT&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;0&quot;</span>
<span class="token string">&quot;set&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;world&quot;</span>
<span class="token string">&quot;PING&quot;</span>
<span class="token string">&quot;incr&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span>
<span class="token string">&quot;incr&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span>
<span class="token string">&quot;incr&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;a&quot;</span>
<span class="token string">&quot;PING&quot;</span>
<span class="token string">&quot;PING&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
127.0.0.1<span class="token punctuation">:</span>6379&gt; set hello world
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; incr a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; incr a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1<span class="token punctuation">:</span>6379&gt; incr a
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div></li> <li><p>--rdb：--rdb选项会请求Redis实例生成并发送RDB持久化文件，保存在本地，可使用它做持久化文件的定期备份。</p></li> <li><p>--pipe：--pipe选项用于将命令封装成Redis通信协议定义的数据格式，批量发送给Redis执行。</p></li> <li><p>--bigkeys：--bigkeys选项使用scan命令对Redis的键进行采样，从中找到内存占用比较大的值。</p></li> <li><p>--eval：--eval选项用于执行指定Lua脚本。</p></li> <li><p>--latency：latency有三个选项，分别是--latency、--latency-history、--latency-dist。它们都可以检测网络延迟，对于Redis的开发和运维非常有帮助。</p> <ul><li><p>--latency：测试客户端到目标Redis的网络延迟。</p></li> <li><p>--latency-history：--latency的执行结果只有一条，如果想以分时段的形式了解延迟信息，可以使用--latency-history选项。</p></li> <li><p>--latency-dist：该选项会使用统计图标的形式从控制台输出延迟统计信息。</p></li> <li><p>--stat：实时获取Redis的重要统计信息。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-cli -a hqjmz5201314 --stat
<span class="token property">Warning</span><span class="token punctuation">:</span> Using a password with <span class="token string">'-a'</span> or <span class="token string">'-u'</span> option on the command line interface may not be safe.
------- data ------ --------------------- load -------------------- - child -
keys       mem      clients blocked requests            connections          
25         1.84M    1       0       7747 <span class="token punctuation">(</span>+0<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7748 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7749 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7750 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7751 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7752 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741        
25         1.84M    1       0       7753 <span class="token punctuation">(</span>+1<span class="token punctuation">)</span>           1741  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div></li> <li><p>--raw和--no-raw：--no-raw选项是要求命令的返回结果必须是原始的格式，--raw恰恰相反，返回格式化后的结果。</p></li></ul></li></ul> <h4 id="_2-2-redis-server"><a href="#_2-2-redis-server" class="header-anchor">#</a> 2.2 redis-server</h4> <p>redis-server除了启动Redis外，还有一个--test-memory，redis-server --test-memory可以用来检测当前操作系统能否稳定地分配指定容量的内存给Redis。通过这种检测可以有效避免因为内存问题造成redis崩溃。当输出passed this test时，说明内存检测完毕。</p> <h4 id="_2-3-redis-benchmark"><a href="#_2-3-redis-benchmark" class="header-anchor">#</a> 2.3 redis-benchmark</h4> <p>redis-benchmark可以为Redis做基准性能测试。</p> <ul><li>-c（clients）：代表客户端的并发数量（默认是50）。</li> <li>-n<quests>：-n（num）代表客户端请求总量（默认是100000）。</quests></li></ul> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-benchmark -c 100 -n 20000
====== MSET <span class="token punctuation">(</span>10 keys<span class="token punctuation">)</span> ======
  20000 requests completed in 0.22 seconds
  100 parallel clients
  3 bytes payload
  keep <span class="token property">alive</span><span class="token punctuation">:</span> 1

99.90% &lt;= 1 milliseconds
100.00% &lt;= 1 milliseconds
88888.89 requests per second
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><ul><li><p>-q：-q选项仅仅显示redis-benchmark的requests per second信息</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-benchmark -c 100 -n 20000 -q
<span class="token property">PING_INLINE</span><span class="token punctuation">:</span> 85470.09 requests per second
<span class="token property">PING_BULK</span><span class="token punctuation">:</span> 84033.61 requests per second
<span class="token property">SET</span><span class="token punctuation">:</span> 84033.61 requests per second
<span class="token property">GET</span><span class="token punctuation">:</span> 83682.01 requests per second
<span class="token property">INCR</span><span class="token punctuation">:</span> 84388.19 requests per second
<span class="token property">LPUSH</span><span class="token punctuation">:</span> 82987.55 requests per second
<span class="token property">RPUSH</span><span class="token punctuation">:</span> 83333.34 requests per second
<span class="token property">LPOP</span><span class="token punctuation">:</span> 83682.01 requests per second
<span class="token property">RPOP</span><span class="token punctuation">:</span> 82987.55 requests per second
<span class="token property">SADD</span><span class="token punctuation">:</span> 82987.55 requests per second
<span class="token property">HSET</span><span class="token punctuation">:</span> 83333.34 requests per second
<span class="token property">SPOP</span><span class="token punctuation">:</span> 82304.52 requests per second
LPUSH <span class="token punctuation">(</span>needed to benchmark LRANGE<span class="token punctuation">)</span><span class="token punctuation">:</span> 84033.61 requests per second
LRANGE_100 <span class="token punctuation">(</span>first 100 elements<span class="token punctuation">)</span><span class="token punctuation">:</span> 81967.21 requests per second
LRANGE_300 <span class="token punctuation">(</span>first 300 elements<span class="token punctuation">)</span><span class="token punctuation">:</span> 83682.01 requests per second
LRANGE_500 <span class="token punctuation">(</span>first 450 elements<span class="token punctuation">)</span><span class="token punctuation">:</span> 83682.01 requests per second
LRANGE_600 <span class="token punctuation">(</span>first 600 elements<span class="token punctuation">)</span><span class="token punctuation">:</span> 82644.62 requests per second
MSET <span class="token punctuation">(</span>10 keys<span class="token punctuation">)</span><span class="token punctuation">:</span> 85470.09 requests per second
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div></li> <li><p>-r：-r（random）选项</p></li> <li><p>-p：代表每个请求pipeline的数据量（默认为1）</p></li> <li><p>-k<boolean>：-k代表客户端是否使用keepalive，1为使用，0为不使用，默认值为1。</boolean></p></li> <li><p>-t：-t选项可以对指定命令进行基准测试。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ ~]# redis-benchmark -t get<span class="token punctuation">,</span>set -q
<span class="token property">SET</span><span class="token punctuation">:</span> 87565.68 requests per second
<span class="token property">GET</span><span class="token punctuation">:</span> 87642.41 requests per second
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div></li> <li><p>--csv：--csv选项会将结果按照csv格式输出，便于后续处理，如导出到excel等。</p></li></ul> <h3 id="_3-pipeline"><a href="#_3-pipeline" class="header-anchor">#</a> 3 Pipeline</h3> <h4 id="_3-1-概念"><a href="#_3-1-概念" class="header-anchor">#</a> 3.1 概念</h4> <p>Redis客户端执行一条命令分为如下四个过程：</p> <p>1 发送命令</p> <p>2 命令排队</p> <p>3 命令执行</p> <p>4 返回</p> <p>其中1、4称为Round Trip Time（RTT，往返时间）</p> <p>Redis提供了批量操作命令（例如mget、mset等），有效地节约RTT。但大部分命令是不支持批量操作的，例如hgetall命令，需要消耗n次RTT。</p> <p>Pipeline（流水线）机制能改善这类问题。它能将一组Redis命令进行组装，通过一次RTT传输给Redis，再将这组Redis命令的执行结果按顺序返回给客户端。redis-cli的--pipe选项实际上就是使用Pipeline机制。</p> <h4 id="_3-2-性能测试"><a href="#_3-2-性能测试" class="header-anchor">#</a> 3.2 性能测试</h4> <ul><li>Pipeline执行速度一般比逐条执行要快。</li> <li>客户端和服务端的网络延时越大，Pipeline的效果越明显。</li></ul> <h4 id="_3-3-原生批量命令与pipeline对比"><a href="#_3-3-原生批量命令与pipeline对比" class="header-anchor">#</a> 3.3 原生批量命令与Pipeline对比</h4> <ul><li>原生批量命令是原子的，Pipeline是非原子的。</li> <li>原生批量命令是一个命令对应多个key，Pipeline支持多个命令。</li> <li>原生批量命令是Redis服务端支持实现的，而Pipeline需要服务端和客户端的共同实现。</li></ul> <h4 id="_3-4-最佳实践"><a href="#_3-4-最佳实践" class="header-anchor">#</a> 3.4 最佳实践</h4> <p>Pipeline组装的命令个数不能没有限制，可以将一次包含大量命令的Pipeline拆分成多次较小的Pipeline来完成。</p> <p>Pipeline只能操作一个Redis实例，但是即使在分布式Redis场景中，也可以作为批量操作的重要优化手段。</p> <h3 id="_4-事务与lua"><a href="#_4-事务与lua" class="header-anchor">#</a> 4. 事务与Lua</h3> <p>为了保证多条命令组合的原子性，Redis提供了简单的事务功能以及集成Lua脚本来解决这个问题。</p> <h4 id="_4-1-事务"><a href="#_4-1-事务" class="header-anchor">#</a> 4.1 事务</h4> <p>Redis提供了简单的事务功能，将一组需要一起执行的命令放到multi和exec两个命令之间。multi命令代表事务开始，exec命令代表事务结束，它们之间的命令是原子顺序执行的。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; multi
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd s_key1 a
QUEUED
127.0.0.1<span class="token punctuation">:</span>6379&gt; sadd s_key1 b
QUEUED
127.0.0.1<span class="token punctuation">:</span>6379&gt; sismember s_key1 a
QUEUED
127.0.0.1<span class="token punctuation">:</span>6379&gt; exec
1<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
2<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
3<span class="token punctuation">)</span> <span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>QUEUED，代表命令没有真正被执行，而是暂时保存在Redis中。</p> <p>如果要停止事务的执行，可以使用discard命令代替exec命令即可。</p> <p>如果事务中的命令出现错误，Redis的处理机制是不同的。</p> <ul><li>命令错误：把set写成了sett，属于语法错误，会造成整个事务无法执行。</li> <li>运行时错误：比如误把sadd命令写成了zadd命令，这种就是运行时命令，因为语法是正确的。可以看到Redis并不支持回滚功能。</li></ul> <p>有些应用场景需要在事务之前，确保事务中的key没有被其他客户端修改过，才执行事务，否则不执行（类似乐观锁）。Redis提供了watch命令来解决这类问题。</p> <p>事务中watch命令演示时序</p> <table><thead><tr><th style="text-align:center;">时间点</th> <th style="text-align:center;">客户端-1</th> <th style="text-align:center;">客户端-2</th></tr></thead> <tbody><tr><td style="text-align:center;">T1</td> <td style="text-align:center;">set key &quot;java&quot;</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">T2</td> <td style="text-align:center;">watch key</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">T3</td> <td style="text-align:center;">multi</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">T4</td> <td style="text-align:center;"></td> <td style="text-align:center;">append key python</td></tr> <tr><td style="text-align:center;">T5</td> <td style="text-align:center;">append key jedis</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">T6</td> <td style="text-align:center;">exec</td> <td style="text-align:center;"></td></tr> <tr><td style="text-align:center;">T7</td> <td style="text-align:center;">get key</td> <td style="text-align:center;"></td></tr></tbody></table> <p>这个事务不会执行。</p> <h4 id="_4-2-lua"><a href="#_4-2-lua" class="header-anchor">#</a> 4.2 Lua</h4> <p>在Redis中执行Lua脚本有两种方法：eval和evalsha。</p> <ul><li><p>eval：eval 脚本内容 key个数 key列表 参数列表</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; eval <span class="token string">'return &quot;hello &quot; ..KEYS[1] ..ARGV[1]'</span> 1 redis world
<span class="token string">&quot;hello redisworld&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>如果Lua脚本较长，还可以使用redis-cli--eval直接执行文本。</p></li> <li><p>eval命令和--eval参数本质是一样的，客户端如果想执行Lua脚本，首先在客户端编写好Lua脚本代码，然后把脚本作为字符串发送给服务端，服务端会将执行结果返回给客户端。</p></li> <li><p>evalsha：除了使用eval，redis还提供了evalsha命令来执行Lua脚本，首先要将Lua脚本加载到Redis服务端，得到该脚本的SHA1校验和，evalsha命令使用SHA1作为参数可以直接执行对应Lua脚本，避免每次发送Lua脚本的开销，而脚本也会常驻在服务端，脚本功能得到了复用。</p></li> <li><p>加载脚本：script load命令可以将脚本内容加载到Redis内存中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; redis-cli script load <span class="token string">&quot;$(cat lua_get.lua)&quot;</span>
<span class="token string">&quot;123123ghdageg1gj2g3uj1ih81g7823781g7823&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>执行脚本：evalsha 脚本SHA1值 key个数 key列表 参数列表</p></li> <li><p>Lua的Redis API</p> <ul><li><p>eval 'return redis.call(&quot;get&quot;, KEYS[1])' 1 hello</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; eval <span class="token string">'return redis.call(&quot;get&quot;, KEYS[1])'</span> 1 hello
<span class="token string">&quot;world&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>redis.pcall函数和redis.call函数的区别在于：如果redis.call执行失败，那么脚本执行结束会直接返回错误，而redis.pcall会忽略错误继续执行脚本。</p></li></ul></li></ul> <p>Lua脚本功能带来的好处：</p> <ul><li>Lua脚本在Redis中是原子执行的，执行过程中间不会插入其他命令。</li> <li>Lua脚本可以用来定制命令，并将这些命令常驻在Redis内存中，实现复用的效果。</li> <li>Lua脚本可以将多条命令一次性打包，有效地减少网络开销。</li></ul> <p>redis提供了4个命令实现对Lua脚本的管理</p> <ul><li>script load：此命令用于将Lua脚本加载到Redis内存中。</li> <li>script exists：此命令用于判断sha1是否已经加载到Redis内存中。返回被加载到Redis内存的个数</li> <li>script flush：用于清除Redis内存已经加载的所有Lua脚本。</li> <li>script kill：用于杀掉正在执行的Lua脚本。如果当前Lua脚本正在执行写操作，那么script kill将不会生效。</li></ul> <h3 id="_5-bitmaps"><a href="#_5-bitmaps" class="header-anchor">#</a> 5. Bitmaps</h3> <h4 id="_5-1-数据结构模型"><a href="#_5-1-数据结构模型" class="header-anchor">#</a> 5.1 数据结构模型</h4> <p>Redis提供了Bitmaps这个“数据结构”可以实现对位的操作。</p> <ul><li>Bitmaps本身不是一种数据结构，实际上它就是字符串，但是它可以对字符串的位进行操作。</li> <li>Bitmaps单独提供了一套命令，所以在Redis中使用Bitmaps和使用字符串的方法不太相同，可以把Bitmaps想象成一个以位为单位的数组，数组的每个单元只能存储0和1，数组的下标在Bitmaps中叫做偏移量。</li></ul> <h4 id="_5-2-命令"><a href="#_5-2-命令" class="header-anchor">#</a> 5.2 命令</h4> <p>本节将每个独立用户是否访问过网站放在Bitmaps中，将访问的用户记做1，没有访问的用户记做0，用偏移量作为用户的id。</p> <ul><li><p>设置值：setbit key offset value：设置键的第offset个位的值。在第一次初始化Bitmaps时，假如偏移量非常大，那么整个初始化过程执行会比较慢，可能会造成Redis的阻塞。</p></li> <li><p>获取值：getbit key offset：获取键的第offset位的值。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 1 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 1 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 2 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; getbit bit_key1 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; getbit bit_key1 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; getbit bit_key1 2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div></li> <li><p>获取Bitmaps指定范围值为1的个数：bitcount [start] [end]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; bitcount bit_key1 0 -1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
127.0.0.1<span class="token punctuation">:</span>6379&gt; bitcount bit_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li> <li><p>Bitmaps间的运算：bitop op destkey key[key ...]。bitop是一个复合操作，它可以做多个Bitmaps的and（交集）、or（并集）、not（非）、xor（异或）操作并将结果保存在destkey中。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 1 0
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 1 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key1 2 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key2 1 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key2 0 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; setbit bit_key2 2 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 0
127.0.0.1<span class="token punctuation">:</span>6379&gt; bitop and bit_destkey1 bit_key1 bit_key2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; bitcount bit_destkey1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 2
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div></li> <li><p>计算Bitmaps中第一个值位targetBit的偏移量：bitpos key targetBit [start] [end]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; bitpos bit_key1 1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; bitpos bit_key1 2
<span class="token punctuation">(</span>error<span class="token punctuation">)</span> ERR The bit argument must be 1 or 0.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <h4 id="_5-3-bitmaps分析"><a href="#_5-3-bitmaps分析" class="header-anchor">#</a> 5.3 Bitmaps分析</h4> <p>数据量越大，用Bitmaps能节省更多内存空间。但是如果数据量偏小，Bitmaps里大部分位都是0，反而不太合适了。</p> <h3 id="_6-hyperloglog"><a href="#_6-hyperloglog" class="header-anchor">#</a> 6. HyperLogLog</h3> <p>HyperLogLog并不是一种新的数据结构（实际类型为字符串类型），而是一种基数算法，通过HyperLogLog可以利用极小的内存空间完成独立总数的统计，数据集可以是IP、Email、ID等。HyperLogLog提供了3个命令：pfadd、pfcount、pfmerge。</p> <ul><li><p>添加：pfadd key element [element ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; pfadd hyper_log_log_key1 a b c d e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div></li> <li><p>计算独立用户数：pfcount key [key ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; pfadd hyper_log_log_key1 a b c d e
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; pfcount hyper_log_log_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 5
127.0.0.1<span class="token punctuation">:</span>6379&gt; pfadd hyper_log_log_key2 a b c d e f g h i k
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 1
127.0.0.1<span class="token punctuation">:</span>6379&gt; pfcount hyper_log_log_key1 hyper_log_log_key2
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div></li> <li><p>HyperLogLog内存占用量小得惊人，但是存在一定误差率，Redis官方给出的数字是0.81%的失误率。</p></li> <li><p>合并：pfmerge destkey sourcekey [sourcekey ...]</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; pfmerge pfmerge_key1 hyper_log_log_key1 hyper_log_log_key2
OK
127.0.0.1<span class="token punctuation">:</span>6379&gt; pfcount pfmerge_key1
<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> 10
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></li></ul> <p>HyperLogLog内存占用量非常小，但是存在错误率，开发者在进行数据结构选型时只需要确认如下两条即可：</p> <ul><li>只为了计算独立总数，不需要获取单条数据。</li> <li>可以容忍一定误差率，毕竟HyperLogLog在内存的占用量上有很大的优势。</li></ul> <h3 id="_7-发布订阅"><a href="#_7-发布订阅" class="header-anchor">#</a> 7. 发布订阅</h3> <h4 id="_7-1-命令"><a href="#_7-1-命令" class="header-anchor">#</a> 7.1 命令</h4> <p>Redis主要提供了发布消息、订阅频道、取消订阅以及按照模式订阅和取消订阅等命令。</p> <ul><li>发布消息：publish channel message</li> <li>订阅消息：subscribe channel [channel ...]</li> <li>有关订阅命令有两点需要注意：
<ul><li>客户端在执行订阅命令之后进入了订阅状态，只能接收subscribe、psubscribe、unsubscribe、punsubscribe的四个命令。</li> <li>新开启的订阅客户端，无法收到该频道之前的消息，因为Redis不会对发布的消息进行持久化。</li></ul></li> <li>取消订阅：unsubscribe [channel [channel ...]]</li> <li>按照模式订阅和取消订阅：
<ul><li>psubscribe pattern [pattern ...]</li> <li>punsubscribe [pattern [pattern ...]]</li></ul></li> <li>查询订阅：
<ul><li>查看活跃的频道：pubsub channels [pattern]，所谓活跃的频道是指当前频道至少有一个订阅者。</li> <li>查看频道订阅数：pubsub numsub [channel ...]</li> <li>查看模式订阅数：pubsub numpat</li></ul></li></ul> <h3 id="_8-geo"><a href="#_8-geo" class="header-anchor">#</a> 8. GEO</h3> <p>Redis3.2版本提供了GEO（地理信息定位）功能，支持存储地理位置信息用来实现诸如附近位置、摇一摇这类依赖于地理位置信息的功能。</p> <p>GEO功能是Redis借鉴NoSQL数据库Ardb实现的。</p> <ul><li><p>增加地理位置信息：geoadd key longitude latitude member [longitude latitude member ...]</p> <ul><li>longitude latitude member 分别是该地理位置的经度、纬度、成员。</li> <li>返回结果代表添加成功的个数，如果目标key没有包含对应的member返回1，否则返回0，虽然返回0但也会做更新。</li></ul></li> <li><p>获取地理位置信息：geopos key member [member ...]</p></li> <li><p>获取两个地理位置的距离：geodist key member1 member2 [unit]</p> <ul><li>其中unit代表返回结果的单位，包含以下四种：
<ul><li>m：代表米</li> <li>km：公里</li> <li>mi：英里</li> <li>ft：尺</li></ul></li></ul></li> <li><p>获取指定位置范围内的地理信息位置集合：</p> <ul><li>georadius key longitute latitude radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</li> <li>georadiusbymember key member radiusm|km|ft|mi [withcoord] [withdist] [withhash] [COUNT count] [asc|desc] [store key] [storedist key]</li> <li>georadius和georadiusbymember两个命令的作用是一样的，都是以一个地理位置为中心算出指定半径内的其他地理信息位置，不同的是georadius命令的中心位置给出了具体的经纬度，georadiusbymember只需给出成员即可。其中radiusm|km|ft|mi是必需参数，指定了半径（带单位）。这两个命令有很多可选参数，具体如下：
<ul><li>withcoord：返回结果中包含经纬度。</li> <li>withdist：返回结果中包含离中心节点位置的距离。</li> <li>withhash：返回结果中包含geohash。</li> <li>COUNT count：指定返回结果的数量。</li> <li>asc|desc：返回结果按照离中心节点的距离做升序或者降序。</li> <li>store key：将返回结果的地理位置信息保存到指定键。</li> <li>storedist key：将返回结果离中心节点的距离保存到指定键。</li></ul></li></ul></li> <li><p>获取geohash：geohash key member [member ...]</p> <ul><li><p>Redis使用geohash将二维经纬度转换为一维字符串，geohash有如下特点：</p> <ul><li>GEO的数据类型为zset，Redis将所有地理位置信息的geohash存放在zset中。</li> <li>字符串越长，表示的位置更精确。</li> <li>两个字符串越相似，它们之间的距离越近。</li> <li>geohash编码和经纬度是可以相互转换的。</li></ul> <p>Redis正是使用有序集合并结合geohash的特性实现了GEO的若干命令。</p></li></ul></li> <li><p>删除地理位置信息：zrem key member。</p> <ul><li>GEO没有提供删除成员的命令，但是因为GEO的底层实现是zset，所以可以借用zrem命令实现对地理位置信息的删除。</li></ul></li></ul> <h3 id="_9-总结"><a href="#_9-总结" class="header-anchor">#</a> 9. 总结</h3> <ul><li>慢查询中的两个重要参数showlog-log-slower-than和slowlog-max-len。</li> <li>慢查询不包含命令网络传输和排队时间。</li> <li>有必要将慢查询定期存放。</li> <li>redis-cli一些重要的选项，例如--latency、--bigkeys、-i和-r组合。</li> <li>redis-benchmark的使用方法和重要参数。</li> <li>Pipeline可以有效减少RTT次数，但每次Pipeline的命令数量不能无节制。</li> <li>Redis可以使用Lua脚本创造出原子、高效、自定义命令组合。</li> <li>Redis执行Lua脚本有两种方法：eval和evalsha。</li> <li>Bitmaps可以用来做独立用户统计，有效节省内存。</li> <li>Bitmaps中setbit一个大的偏移量，由于申请大量内存会导致阻塞。</li> <li>HyperLogLog虽然在统计独立总量时存在一定的误差，但是节省的内存量十分惊人。</li> <li>Redis的发布订阅机制相比许多专业的消息队列系统功能较弱，不具备堆积和回溯消息的能力，但胜在足够简单。</li> <li>Redis3.2提供了GEO功能，用来实现基于地理位置信息的应用，但底层实现是zset。</li></ul> <h2 id="第四章-客户端"><a href="#第四章-客户端" class="header-anchor">#</a> 第四章 客户端</h2> <h3 id="_1-客户端通信协议"><a href="#_1-客户端通信协议" class="header-anchor">#</a> 1. 客户端通信协议</h3> <p>Redis指定了RESP（Redis序列化协议）实现客户端与服务端的正常交互，这种协议简单高效，既能够被机器解析，又容易被人类识别。</p> <ul><li><p>发送命令格式：RESP规定一条命令的格式如下，CRLF代表&quot;\r\n&quot;。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>*&lt;参数数量&gt; CRLF
$&lt;参数1的字节数量&gt; CRLF
&lt;参数1&gt; CRLF
...
$&lt;参数N的字节数量&gt; CRLF
&lt;参数N&gt; CRLF
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>返回结果格式：Redis的返回结果类型分为以下五种</p> <ul><li>状态回复：在RESP中第一个字节为“+”。例如set</li> <li>错误回复：在RESP中第一个字节为“-”。例如错误命令setx</li> <li>整数回复：在RESP中第一个字节为“: ”。例如incr</li> <li>字符串回复：在RESP中第一个字节为“$”。例如get</li> <li>多条字符串回复：在RESP中第一个字节为“*”。例如mget</li></ul></li></ul> <h3 id="_2-java客户端jedis"><a href="#_2-java客户端jedis" class="header-anchor">#</a> 2. Java客户端Jedis</h3> <h3 id="_3-客户端管理"><a href="#_3-客户端管理" class="header-anchor">#</a> 3. 客户端管理</h3> <ul><li><p>client list：client list命令能列出与Redis服务端相连的所有客户端连接信息。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; client list
id=7463 addr=127.0.0.1<span class="token punctuation">:</span>60564 fd=7 name= age=15 idle=0 flags=N db=0 sub=0 psub=0 multi=-1 qbuf=26 qbuf-free=32742 obl=0 oll=0 omem=0 events=r cmd=client
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><ul><li>标识：id、addr、fd、name。这四个属性属于客户端的标识。
<ul><li>id：客户端连接的唯一标识，这个id是随着Redis的连接自增的，重启Redis后会重置为0。</li> <li>addr：客户端连接的ip和端口。</li> <li>fd：socket的文件描述符，与lsof命令结果中的fd是同一个，如果fd=-1代表当前客户端不是外部客户端，而是Redis内部伪装客户端。</li> <li>name：客户端的名字。</li></ul></li> <li>输入缓冲区：qbuf、qbuf-free。Redis为每个客户端分配了输入缓冲区，它的作用是将客户端发送的命令临时保存，同时Redis从会输入缓冲区拉取命令并执行，输入缓冲区为客户端发送命令到Redis执行命令提供了缓冲功能。
<ul><li>qbuf：缓冲区的总容量。</li> <li>qbuf-free：缓冲区的剩余容量。</li> <li>Redis没有提供相应的配置来规定每个缓冲区的大小，输入缓冲区会根据输入内容大小的不同动态调整，只是要求每个客户端缓冲区的大小不能超过1G，超过后客户端将会关闭。</li></ul></li></ul> <p>输入缓冲使用不当会产生两个问题：</p> <ul><li><p>一旦某个客户端的输入缓冲区超过1G，客户端将会关闭。</p></li> <li><p>输入缓冲区不受maxmemory控制，如果超过maxmemory限制，可能会产生数据丢失、键值淘汰、OOM等情况。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; info memory
# Memory
<span class="token property">used_memory</span><span class="token punctuation">:</span>859328
<span class="token property">used_memory_human</span><span class="token punctuation">:</span>839.19K
<span class="token property">used_memory_rss</span><span class="token punctuation">:</span>8593408
<span class="token property">used_memory_rss_human</span><span class="token punctuation">:</span>8.20M
<span class="token property">used_memory_peak</span><span class="token punctuation">:</span>8068488
<span class="token property">used_memory_peak_human</span><span class="token punctuation">:</span>7.69M
<span class="token property">used_memory_peak_perc</span><span class="token punctuation">:</span>10.65%
<span class="token property">used_memory_overhead</span><span class="token punctuation">:</span>842894
<span class="token property">used_memory_startup</span><span class="token punctuation">:</span>791416
<span class="token property">used_memory_dataset</span><span class="token punctuation">:</span>16434
<span class="token property">used_memory_dataset_perc</span><span class="token punctuation">:</span>24.20%
<span class="token property">allocator_allocated</span><span class="token punctuation">:</span>851448
<span class="token property">allocator_active</span><span class="token punctuation">:</span>1064960
<span class="token property">allocator_resident</span><span class="token punctuation">:</span>11890688
<span class="token property">total_system_memory</span><span class="token punctuation">:</span>3973373952
<span class="token property">total_system_memory_human</span><span class="token punctuation">:</span>3.70G
<span class="token property">used_memory_lua</span><span class="token punctuation">:</span>44032
<span class="token property">used_memory_lua_human</span><span class="token punctuation">:</span>43.00K
<span class="token property">used_memory_scripts</span><span class="token punctuation">:</span>256
<span class="token property">used_memory_scripts_human</span><span class="token punctuation">:</span>256B
<span class="token property">number_of_cached_scripts</span><span class="token punctuation">:</span>2
<span class="token property">maxmemory</span><span class="token punctuation">:</span>0
<span class="token property">maxmemory_human</span><span class="token punctuation">:</span>0B
<span class="token property">maxmemory_policy</span><span class="token punctuation">:</span>noeviction
<span class="token property">allocator_frag_ratio</span><span class="token punctuation">:</span>1.25
<span class="token property">allocator_frag_bytes</span><span class="token punctuation">:</span>213512
<span class="token property">allocator_rss_ratio</span><span class="token punctuation">:</span>11.17
<span class="token property">allocator_rss_bytes</span><span class="token punctuation">:</span>10825728
<span class="token property">rss_overhead_ratio</span><span class="token punctuation">:</span>0.72
<span class="token property">rss_overhead_bytes</span><span class="token punctuation">:</span>-3297280
<span class="token property">mem_fragmentation_ratio</span><span class="token punctuation">:</span>10.50
<span class="token property">mem_fragmentation_bytes</span><span class="token punctuation">:</span>7775096
<span class="token property">mem_not_counted_for_evict</span><span class="token punctuation">:</span>0
<span class="token property">mem_replication_backlog</span><span class="token punctuation">:</span>0
<span class="token property">mem_clients_slaves</span><span class="token punctuation">:</span>0
<span class="token property">mem_clients_normal</span><span class="token punctuation">:</span>49694
<span class="token property">mem_aof_buffer</span><span class="token punctuation">:</span>0
<span class="token property">mem_allocator</span><span class="token punctuation">:</span>jemalloc-5.1.0
<span class="token property">active_defrag_running</span><span class="token punctuation">:</span>0
<span class="token property">lazyfree_pending_objects</span><span class="token punctuation">:</span>0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br></div></div></li> <li><p>bigkeys过大，处理速度跟不上缓冲区的输入速度，redis发生了阻塞导致输入命令积压在了输入缓冲区等都有可能导致输入缓冲区过大。</p></li></ul> <p>监控输入缓冲区异常的方法有两种：</p> <ul><li><p>定期执行client list命令，收集qbuf和qbuf-free找到异常的连接记录。</p></li> <li><p>通过info命令的info clients模块，找到最大的输入缓冲区</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6379&gt; info clients
# Clients
<span class="token property">connected_clients</span><span class="token punctuation">:</span>1
<span class="token property">client_recent_max_input_buffer</span><span class="token punctuation">:</span>2
<span class="token property">client_recent_max_output_buffer</span><span class="token punctuation">:</span>0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>输出缓冲区：obl、oll、omem</p> <ul><li>输出缓冲区的容量可以通过参数client-output-buffer-limit来进行设置。</li> <li>输出缓冲区分为：普通客户端、发布订阅客户端、slave客户端（用于复制）。</li> <li>输出缓冲区由两部分组成：固定缓冲区（返回较小的结果）和动态缓冲区（返回较大的结果）。</li> <li>obl：固定缓冲区的长度。</li> <li>oll：动态缓冲区列表的长度。</li> <li>omem：使用的字节数。</li></ul></li> <li><p>客户端的存活状态：</p> <ul><li>age：当前客户端已经连接的时间。</li> <li>idle：最近一次的空闲时间。</li></ul></li> <li><p>客户端的限制：</p> <ul><li>maxclients：最大客户端连接数。一旦连接数超过maxclients，新的连接将被拒绝。默认值是10000。</li> <li>timeout：连接的最大空闲时间，一旦客户端连接的idle时间超过了timeout，连接将会被关闭。默认是0</li></ul></li> <li><p>客户端类型：</p> <ul><li>flag用于标识当前客户端的类型：
<ul><li>S：slave客户端</li> <li>N：普通客户端</li> <li>O：代表当前客户端正在执行monitor命令。</li></ul></li></ul></li></ul></li> <li><p>client setName和client getName：设置和获取客户端的名称</p></li> <li><p>client kill：client kill ip:port 用于杀掉指定IP地址和端口的客户端。</p></li> <li><p>client pause timeout（毫秒）：阻塞客户端timeout毫秒数。</p> <ul><li>client pause只对普通和发布订阅客户端有效，对于主从复制是无效的。所以此命令可以用来让主从复制保持一致。</li> <li>client pause可以用一种可控的方式将客户端连接从一个Redis节点切换到另一个Redis节点。</li></ul></li> <li><p>monitor：用于监控Redis正在执行的命令。</p></li></ul> <h3 id="_4-总结"><a href="#_4-总结" class="header-anchor">#</a> 4. 总结</h3> <ul><li>RESP保证客户端与服务端的正常通信，是各种编程语言开发客户端的基础。</li> <li>要用连接池。</li> <li>Jedis.close()在直连下是关闭连接，在连接池则是归还连接。</li> <li>Jedis客户端没有内置序列化，需要自己选用。</li> <li>客户端输入缓冲区不能配置，强制限制在1G之内，但是不会受到maxmemory限制。</li> <li>客户端输出缓冲区支持普通客户端、发布订阅客户端、复制客户端配置、同样会受到maxmemory限制。</li> <li>Redis的timeout配置可以自动关闭闲置客户端，tcp-keepalive参数可以周期性检查关闭无效TCP连接。</li> <li>monitor命令虽然好用，但是在大并发下存在输出缓冲区暴涨的可能性。</li> <li>info clients帮助开发和运维人员找到客户端可能存在的问题。</li></ul> <h2 id="第五章-持久化"><a href="#第五章-持久化" class="header-anchor">#</a> 第五章 持久化</h2> <p>Redis支持RDB和AOF两种持久化机制。</p> <h3 id="_1-rdb"><a href="#_1-rdb" class="header-anchor">#</a> 1. RDB</h3> <p>RDB持久化是把当前进程数据生成快照保存到硬盘的过程，触发RDB持久化过程分为手动触发和自动触发。</p> <h4 id="_1-1-触发机制"><a href="#_1-1-触发机制" class="header-anchor">#</a> 1.1 触发机制</h4> <p>手动触发分别对应save和bgsave命令：</p> <ul><li>save命令：阻塞当前Redis服务器，直到RDB过程完成为止，对于比较大的实例会造成长时间阻塞，线上环境不建议使用。
<ul><li>运行save命令对应的Redis日志如下：DB saved on dist</li></ul></li> <li>bgsave命令：Redis进程进行fork操作创建子进程，RDB持久化过程由子进程负责，完成后自动结束。阻塞只发生在fork阶段，一般时间很短。
<ul><li>运行bgsave命令对应的Redis日志如下</li></ul></li> <li>显然bgsave命令是针对save阻塞问题做的优化，因此Redis内部所有的涉及RDB的操作都采用bgsave的方式，而save命令已经废弃。</li></ul> <p>自动触发：</p> <ul><li>使用save相关配置，如“save m n”。表示m秒内数据集存在n次修改时，自动触发bgsave。</li> <li>如果从节点执行全量复制操作，主节点自动执行bgsave生成RDB文件并发送给从节点。</li> <li>执行debug reload命令重新加载Redis时，也会自动触发save操作。</li> <li>默认情况下执行shutdown命令时，如果没有开启AOF持久化功能则自动执行bgsave。</li></ul> <h4 id="_1-2-流程说明"><a href="#_1-2-流程说明" class="header-anchor">#</a> 1.2 流程说明</h4> <p>bgsave是主流的触发RDB持久化方式。</p> <p>bgsave依赖于父进程执行fork操作创建子进程，fork操作过程父进程会阻塞。</p> <h4 id="_1-3-rdb文件的处理"><a href="#_1-3-rdb文件的处理" class="header-anchor">#</a> 1.3 RDB文件的处理</h4> <p>RDB文件保存在dir配置指定的目录下，文件名通过dbfilename配置指定。可以通过执行config set dir {newDir}和config set dbfilename {newFileName}运行期动态执行，当下次运行时RDB文件会保存到新目录。</p> <p>压缩：Redis默认采用LZF算法对生成的RDB文件做压缩处理，压缩后的文件远远小于内存大小，默认开启，可以通过参数config set rdbcompression{yes|no}动态修改。虽然压缩RDB会消耗CPU，但可大幅度降低文件的体积，方便保存到硬盘或通过网络发送到从节点，因此线上建议开启。</p> <p>校验：如果Redis加载损坏的RDB文件时拒绝启动。可以使用Redis提供的redis-check-dump工具检测RDB文件并获取对应的错误报告。</p> <h4 id="_1-4-rdb的优缺点"><a href="#_1-4-rdb的优缺点" class="header-anchor">#</a> 1.4 RDB的优缺点</h4> <ul><li>优点：
<ul><li>RDB是一个紧凑压缩的二进制文件，代表Redis在某个时间点上的数据快照。非常适用于备份，全量复制等场景。比如每6小时执行bgsave备份，并把RDB文件拷贝到远程机器或者文件系统（如hdfs），用于灾难恢复。</li> <li>Redis加载RDB恢复数据远远快于AOF的方式。</li></ul></li> <li>缺点：
<ul><li>RDB方式数据没办法做到实时持久化/秒级持久化，因为bgsave每次运行都要执行fork操作创建子进程，属于重量级操作，频繁执行成本过高。</li> <li>RDB文件使用特定二进制格式保存，Redis版本演进过程中有多个格式的RDB版本，存在老版本Redis服务无法兼容新版RDB格式的问题。</li></ul></li> <li>针对RDB不适合实时持久化的问题，Redis提供了AOF持久化方式来解决。</li></ul> <h3 id="_2-aof"><a href="#_2-aof" class="header-anchor">#</a> 2. AOF</h3> <p>AOF(append only file)持久化：以独立日志的方式记录每次写命令，重启时再重新执行AOF文件中的命令达到恢复数据的目的。AOF的主要作用是解决了数据持久化的实时性，目前已经是Redis持久化的主流方式。</p> <h4 id="_2-1-使用aof"><a href="#_2-1-使用aof" class="header-anchor">#</a> 2.1 使用AOF</h4> <p>开启AOF功能需要设置配置：appendonly yes，默认不开启。AOF文件名通过appendfilename配置设置，默认文件名是appendonly.aof。保存路径和RDB持久化方式一致，通过dir配置指定。AOF的工作流程操作：命令写入（append）、文件同步（sync）、文件重写（rewrite）、重启加载（load）。</p> <p>流程如下：</p> <ul><li>所有的写入命令会追加到aof_buf（缓冲区）中。</li> <li>AOF缓冲区根据对应的策略向硬盘做同步操作。</li> <li>随着AOF文件越来越大，需要定期对AOF文件进行重写，达到压缩的目的。</li> <li>当Redis服务器重启时，可以加载AOF文件进行数据恢复。</li></ul> <h4 id="_2-2-命令写入"><a href="#_2-2-命令写入" class="header-anchor">#</a> 2.2 命令写入</h4> <p>AOF命令写入的内容直接是文本协议格式。</p> <ul><li>AOF为什么直接采用文本协议格式？
<ul><li>文本协议具有很好的兼容性。</li> <li>开启AOF后，所有写入命令都包含追加操作，直接采用协议格式，避免了二次处理开销。</li> <li>文本协议具有可读性，方便直接修改和处理。</li></ul></li> <li>AOF为什么把命令追加到aof_buf中？Redis使用单线程响应命令，如果每次写AOF文件命令都直接追加到硬盘，那么性能完全取决于当前硬盘负载。</li></ul> <h4 id="_2-3-文件同步"><a href="#_2-3-文件同步" class="header-anchor">#</a> 2.3 文件同步</h4> <p>Redis提供了多种AOF缓冲区同步文件策略，由参数appendfsync控制。</p> <table><thead><tr><th style="text-align:center;">可配置值</th> <th style="text-align:center;">说明</th></tr></thead> <tbody><tr><td style="text-align:center;">always</td> <td style="text-align:center;">命令写入aof_buf后调用系统fsync操作同步到AOF文件，fsync完成后线程返回</td></tr> <tr><td style="text-align:center;">everysec</td> <td style="text-align:center;">命令写入aof_buf后调用系统write操作，write完成后线程返回，fsync同步文件操作由专门线程每秒调用一次</td></tr> <tr><td style="text-align:center;">no</td> <td style="text-align:center;">命令写入aof_buf后调用系统write操作，不对AOF文件做fsync同步，同步硬盘操作由操作系统负责，通常同步周期最长30秒</td></tr></tbody></table> <ul><li>write：write操作会触发延迟写机制。Linux在内核提供页缓冲区来提高硬盘IO性能。write操作在写入系统缓冲区后直接返回。同步硬盘操作依赖于系统调度机制，例如：缓冲区页写满或达到特定时间周期。同步文件之前，如果系统宕机，缓冲区内数据会丢失。</li> <li>fsync：针对单个文件操作（比如AOF文件），做强制硬盘同步，fsync将阻塞直到写入硬盘完成后返回，保证了数据持久化。</li></ul> <p>建议配置为everysec的同步策略，也是默认配置，做到兼顾性能和数据安全性。</p> <h4 id="_2-4-重写机制"><a href="#_2-4-重写机制" class="header-anchor">#</a> 2.4 重写机制</h4> <p>Redis引入AOF重写机制压缩文件体积。</p> <ul><li>进程内已经超时的数据不再写入文件。</li> <li>新的AOF文件只保留最终数据的写入命令。</li> <li>多条写命令可以合并为一个。为了防止单挑命令过大造成客户端缓冲区溢出，以64个元素为界拆分为多条。</li></ul> <p>AOF重写降低了文件大小，更小的AOF文件可以更快地被Redis加载。</p> <p>AOF重写过程可以手动触发和自动触发：</p> <ul><li><p>手动：直接调用bgwriteaof命令。</p></li> <li><p>自动：根据auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数确定自动触发时机。</p> <ul><li>auto-aof-rewrite-min-size：表示运行AOF重写时文件最小体积，默认为64MB。</li> <li>auto-aof-rewrite-percentage：代表当前AOF文件空间（aof_current_size）和上一次重写后AOF文件空间（aof_base_size）的比值。</li></ul> <p>自动触发时机=aof_current_size &gt; auto-aof-rewrite-min-size &amp;&amp; (aof_current_size - aof_base_size) / aof_base_size &gt;= auto_aof_rewrite-percentage</p></li></ul> <h4 id="_2-5-重启加载"><a href="#_2-5-重启加载" class="header-anchor">#</a> 2.5 重启加载</h4> <p>AOF和RDB文件都可以用于服务器重启时的数据恢复。</p> <p>优先加载AOF然后是RDB，加载AOF/RDB文件成功后，Redis启动成功，AOF/RDB文件存在错误时，Redis启动失败并打印错误信息。</p> <h4 id="_2-6-文件校验"><a href="#_2-6-文件校验" class="header-anchor">#</a> 2.6 文件校验</h4> <p>记载损坏的AOF文件时会拒绝启动。</p> <p>对于错误格式的AOF文件，先进行备份，然后采用redis-check-aof-fix命令进行修复，修复后使用diff-u对比数据的差异，找出丢失的数据，有些可以人工修改补全。AOF文件可能存在结尾不完整的情况，redis提供了aof-load-truncated配置来兼容这种情况，默认开启。加载AOF时，当遇到此问题时会忽略并继续启动，同时打印警告日志。</p> <h3 id="_3-问题定位与优化"><a href="#_3-问题定位与优化" class="header-anchor">#</a> 3. 问题定位与优化</h3> <p>Redis持久化功能一直是影响Redis性能的高发地。</p> <h4 id="_3-1-fork操作"><a href="#_3-1-fork操作" class="header-anchor">#</a> 3.1 fork操作</h4> <p>fork操作耗时跟进程总内存量息息相关。</p> <ul><li>fork耗时问题定位：可以在info stats统计中查latest_fork_usec指标获取最近一次fork操作耗时，单位微妙。正常情况下fork耗时应该是每GB消耗20毫秒左右。</li> <li>如何改善fork操作的耗时：
<ul><li>优先使用物理机或者高效支持fork操作的虚拟化技术，避免使用Xen。</li> <li>控制Redis实例最大可用内存，fork耗时跟内存量成正比，线上建议每个Redis实例内存控制在10GB以内。</li> <li>合理配置Linux内存分配策略，避免物理内存不足导致fork失败。</li> <li>降低fork操作的频率，如适度放宽AOF自动触发时机，避免不必要的全量复制等。</li></ul></li></ul> <h4 id="_3-2-子进程开销监控和优化"><a href="#_3-2-子进程开销监控和优化" class="header-anchor">#</a> 3.2 子进程开销监控和优化</h4> <p>子进程负责AOF或者RDB文件的重写，它的运行过程主要涉及CPU、内存、硬盘三部分的消耗。</p> <h4 id="_3-3-aof追加阻塞"><a href="#_3-3-aof追加阻塞" class="header-anchor">#</a> 3.3 AOF追加阻塞</h4> <h3 id="_4-多实例部署"><a href="#_4-多实例部署" class="header-anchor">#</a> 4. 多实例部署</h3> <p>Redis单线程架构导致无法充分利用CPU多核特性，通常的做法是在一台机器上部署多个Redis实例。当多个实例开启AOF重写后，彼此之间会产生对CPU和IO的竞争。</p> <h3 id="_5-总结"><a href="#_5-总结" class="header-anchor">#</a> 5. 总结</h3> <ul><li>Redis提供了两种持久化方式：RDB和AOF。</li> <li>RDB使用一次性生成内存快照的方式，产生的文件紧凑压缩比更高，因此读取RDB恢复速度更快，由于每次生成RDB开销较大，无法做到实时持久化，一般用于数据冷备和复制传输。</li> <li>save命令会阻塞主线程不建议使用，bgsave命令通过fork操作创建子进程生成RDB避免阻塞。</li> <li>AOF通过追加写命令到文件实现持久化，通过appendfsync参数可以控制实时/秒级持久化。因为需要不断追加写命令，所以AOF文件体积主键变大，需要定期执行重写操作来降低文件体积。</li> <li>AOF重写可以通过auto-aof-rewrite-min-size和auto-aof-rewrite-percentage参数控制自动触发，也可以使用bgrewriteaof命令手动触发。</li> <li>子进程执行期间使用copy-on-write机制与父进程共享内存，避免内存消耗翻倍。AOF重写期间还需要维护重写缓冲区，保存新的写入命令避免数据丢失。</li> <li>持久化阻塞主线程场景有：fork阻塞和AOF追加阻塞。fork阻塞时间跟内存量和系统有关，AOF追加阻塞说明硬盘资源紧张。</li> <li>单机下部署多个实例时，为了防止出现多个子进程执行重写操作，建议做隔离控制，避免CPU和IO资源竞争。</li></ul> <h2 id="第六章-复制"><a href="#第六章-复制" class="header-anchor">#</a> 第六章 复制</h2> <p>复制是高可用Redis的基础，哨兵和集群都是在复制的基础上实现高可用的。</p> <h3 id="_1-配置"><a href="#_1-配置" class="header-anchor">#</a> 1. 配置</h3> <h4 id="_1-1-建立复制"><a href="#_1-1-建立复制" class="header-anchor">#</a> 1.1 建立复制</h4> <p>参与复制的Redis实例划分为主节点（master）和从节点（slave）。默认情况下，Redis都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。</p> <p>配置复制的方式有以下三种：</p> <ul><li>在配置文件中加入slaveof{masterHost}{masterPort}随Redis启动生效。</li> <li>在redis-server启动命令后加入--slaveof{masterHost}{masterPort}生效。</li> <li>直接使用命令：slaveof{masterHost}{masterPort}生效。</li></ul> <p>slaveof本身是异步命令，执行slaveof命令时，节点只保存在主节点信息后返回，后续复制流程在节点内部异步执行。</p> <h4 id="_1-2-断开复制"><a href="#_1-2-断开复制" class="header-anchor">#</a> 1.2 断开复制</h4> <p>slaveof命令不但可以建立复制，还可以在从节点执行slaveof no one来断开与主节点复制关系。</p> <p>主要流程：</p> <ul><li>断开与主节点复制关系。</li> <li>从节点晋升到主节点。</li></ul> <h4 id="_1-3-切换主节点"><a href="#_1-3-切换主节点" class="header-anchor">#</a> 1.3 切换主节点</h4> <p>slaveof {newMasterIp}{newMasterPort}</p> <p>切换主节点流程：</p> <ul><li>断开与旧主节点复制关系。</li> <li>与新主节点建立复制关系。</li> <li>删除从节点当前所有数据。</li> <li>对新主节点进行复制操作。</li></ul> <h4 id="_1-4-安全性"><a href="#_1-4-安全性" class="header-anchor">#</a> 1.4 安全性</h4> <p>要配置从节点的masterauth参数与主节点密码保持一致，这样从节点才可以正确地连接到主节点并发起复制流程。</p> <h4 id="_1-5-只读性"><a href="#_1-5-只读性" class="header-anchor">#</a> 1.5 只读性</h4> <p>默认情况下，从节点使用slave-read-only=yes配置为只读模式。</p> <h4 id="_1-6-传输延迟"><a href="#_1-6-传输延迟" class="header-anchor">#</a> 1.6 传输延迟</h4> <p>Redis提供了repl-disable-tcp-nodelay参数用于控制是否关闭TCP_NODELAY，默认关闭。</p> <p>关闭时延迟小，但网络带宽消耗大。（要求低延迟，同机房）</p> <p>开启时延迟大，一般为40毫秒，节省了带宽。（考虑到高容灾性）</p> <h3 id="_2-拓扑"><a href="#_2-拓扑" class="header-anchor">#</a> 2. 拓扑</h3> <p>Redis的复制拓扑结构可以支持单层或多层复制关系，可以分为三种：一主一从、一主多从、树状主从结构。</p> <ul><li>一主一从：用于主节点出现宕机时从节点提供故障转移支持。可以在从节点上开启AOF，这样既保证数据安全性同时也避免了持久化对主节点的性能干扰。不过需要注意的是当主节点要重启，应该在从节点上执行slaveof no one断开与主节点的复制关系，避免从节点的数据被清空。</li> <li>一主多从：使得应用端可以利用多个从节点实现读写分离。但对于写并发量较高的场景，多个从节点会导致主节点写命令的多次发送从而过度消耗网络带宽，同时也加重了主节点的负载影响服务稳定性。</li> <li>树状主从结构：使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。树状主从结构降低了主节点的压力。</li></ul> <h3 id="_3-原理"><a href="#_3-原理" class="header-anchor">#</a> 3. 原理</h3> <h4 id="_3-1-复制过程"><a href="#_3-1-复制过程" class="header-anchor">#</a> 3.1 复制过程</h4> <p>在从节点执行slaveof命令后，复制过程便开始运作。</p> <p>复制过程大致分为6个过程：</p> <ul><li>保存主节点（master）信息。</li> <li>主从建立socket连接。</li> <li>发送ping命令。</li> <li>权限验证。</li> <li>同步数据集。redis在2.8版本以后采用新复制命令psync进行数据同步，原来的sync命令依然支持。</li> <li>命令持续复制。</li></ul> <h4 id="_3-2-数据同步"><a href="#_3-2-数据同步" class="header-anchor">#</a> 3.2 数据同步</h4> <p>redis在2.8版本以后采用新复制命令psync进行数据同步，同步过程分为：全量复制和部分复制。</p> <ul><li>全量复制：一般用于初次复制场景，消耗很大。</li> <li>部分复制：用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。</li></ul> <p>psync命令运行需要以下组件支持：</p> <ul><li>主从节点各自复制偏移量。</li> <li>主节点复制积压缓冲区。</li> <li>主节点运行id。</li></ul> <h5 id="_3-2-1-复制偏移量"><a href="#_3-2-1-复制偏移量" class="header-anchor">#</a> 3.2.1 复制偏移量</h5> <p>参与复制的主从节点都会维护自身复制偏移量。主节点在处理完写入命令后，会把命令的字节长度做累加记录，统计信息在info replication的master_repl_offset指标中。</p> <p>从节点每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。</p> <h5 id="_3-2-2-复制积压缓冲区"><a href="#_3-2-2-复制积压缓冲区" class="header-anchor">#</a> 3.2.2 复制积压缓冲区</h5> <p>复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点时被创建，这时主节点响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区。</p> <p>缓冲区本质上是先进先出的定长队列，所以能实现保存最近已复制数据的功能，用于部分复制和复制命令丢失的数据补救。</p> <h5 id="_3-2-3-主节点运行id"><a href="#_3-2-3-主节点运行id" class="header-anchor">#</a> 3.2.3 主节点运行ID</h5> <p>每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是用来唯一识别Redis节点。</p> <h5 id="_3-2-4-psync命令"><a href="#_3-2-4-psync命令" class="header-anchor">#</a> 3.2.4 psync命令</h5> <p>从节点使用psync命令完成部分复制和全量复制功能，命令格式：psync {runId}{offset}，参数含义如下：</p> <ul><li>runId：从节点所复制主节点的运行id。</li> <li>offset：当前从节点已复制的数据偏移量。</li></ul> <h4 id="_3-3-全量复制"><a href="#_3-3-全量复制" class="header-anchor">#</a> 3.3 全量复制</h4> <p>sync、psync-1</p> <h4 id="_3-4-部分复制"><a href="#_3-4-部分复制" class="header-anchor">#</a> 3.4 部分复制</h4> <p>psync {rundId}{offset}</p> <h4 id="_3-5-心跳"><a href="#_3-5-心跳" class="header-anchor">#</a> 3.5 心跳</h4> <p>主从心跳判断机制：</p> <ul><li>主从节点彼此都有心跳检测机制。</li> <li>主节点默认每隔10秒对从节点发送ping命令，判断从节点的存活性和连接状态。可通过参数repl-ping-slave-period控制发送频率。</li> <li>从节点在主线程中每隔1秒发送replconf ack{offset}命令，给主节点上报自身当前的复制偏移量。</li></ul> <h4 id="_3-6-异步复制"><a href="#_3-6-异步复制" class="header-anchor">#</a> 3.6 异步复制</h4> <p>主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成的。</p> <h3 id="_4-开发与运维中的问题"><a href="#_4-开发与运维中的问题" class="header-anchor">#</a> 4. 开发与运维中的问题</h3> <h4 id="_4-1-读写分离"><a href="#_4-1-读写分离" class="header-anchor">#</a> 4.1 读写分离</h4> <ul><li>数据延迟</li> <li>读到过期数据：惰性删除、定时删除</li> <li>从节点故障问题</li></ul> <h4 id="_4-2-主从配置不一致"><a href="#_4-2-主从配置不一致" class="header-anchor">#</a> 4.2 主从配置不一致</h4> <h4 id="_4-3-规避全量复制"><a href="#_4-3-规避全量复制" class="header-anchor">#</a> 4.3 规避全量复制</h4> <ul><li>第一次建立复制：无法避免。</li> <li>节点运行ID不匹配：应该从架构上规避，比如提供故障转移功能。当主节点发生故障后，手动提升从节点为主节点或者采用支持自动故障转移的哨兵或集群方案。</li> <li>复制积压缓冲区不足。</li></ul> <h4 id="_4-4-规避复制风暴"><a href="#_4-4-规避复制风暴" class="header-anchor">#</a> 4.4 规避复制风暴</h4> <p>复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。</p> <p>用树状主从结构、分布式部署可规避。</p> <h3 id="_5-总结-2"><a href="#_5-总结-2" class="header-anchor">#</a> 5. 总结</h3> <ul><li>Redis通过复制功能实现主节点的多个副本。从节点可灵活地通过slaveof命令建立或断开复制流程。</li> <li>复制支持树状结构，从节点可以复制另一个从节点，实现一层层向下的复制流。复制分为全量复制和部分复制。</li> <li>主从节点之间维护心跳和偏移量检查机制，保证主从节点通信正常和数据一致。</li> <li>Redis为了保证高性能复制过程是异步的。因此从节点数据集会有延迟情况。</li> <li>当使用从节点用于读写分离时会存在数据延迟、过期数据、从节点可用性等问题。</li> <li>在运维过程中，主节点存在多个从节点或者一台机器上部署大量主节点的情况下，会有复制风暴的危险。</li></ul> <h2 id="第七章-redis的噩梦：阻塞"><a href="#第七章-redis的噩梦：阻塞" class="header-anchor">#</a> 第七章 Redis的噩梦：阻塞</h2> <p>内在原因：不合理地使用API或数据结构、CPU饱和、持久化阻塞等。</p> <p>外在原因：CPU竞争、内存交换、网络问题等。</p> <h3 id="_1-发现阻塞"><a href="#_1-发现阻塞" class="header-anchor">#</a> 1. 发现阻塞</h3> <p>通过异常日志监控。</p> <h3 id="_2-内在原因"><a href="#_2-内在原因" class="header-anchor">#</a> 2. 内在原因</h3> <ul><li><p>API或数据结构使用不合理。</p> <ul><li>慢查询。</li> <li>大对象</li></ul></li> <li><p>CPU饱和。</p> <ul><li>ziplist压缩编码后，hash结构内存占用虽然会变小，但是操作会变慢且更消耗CPU。所以ziplist虽然是Redis用来平衡空间和效率的优化手段，但不可能过度使用。</li></ul></li> <li><p>持久化阻塞</p> <ul><li>持久化引起主线程阻塞的操作主要有：fork阻塞、AOF刷盘阻塞、HugePage写操作阻塞。</li> <li>fork阻塞：fork操作发生在RDB和AOF重写时。</li> <li>AOF刷盘阻塞：文件刷盘的方式一般采用每秒一次，后台线程每秒对AOF文件做fsync操作。</li> <li>HugePage写操作阻塞：子进程在执行重写期间利用Linux写时复制技术降低内存开销，因此只有写操作时Redis才复制要修改的内存页。</li></ul></li></ul> <h3 id="_3-外在原因"><a href="#_3-外在原因" class="header-anchor">#</a> 3. 外在原因</h3> <p>CPU竞争、内存交换、网络问题</p> <ul><li>CPU竞争
<ul><li>进程竞争</li> <li>绑定CPU</li></ul></li> <li>内存交换</li> <li>网络问题
<ul><li>连接拒绝
<ul><li>网络闪断</li> <li>Redis连接拒绝：默认10000</li> <li>连接溢出</li></ul></li> <li>网络延迟</li> <li>网卡软中断</li></ul></li></ul> <h3 id="_4-总结-2"><a href="#_4-总结-2" class="header-anchor">#</a> 4. 总结</h3> <ul><li>客户端最先感知阻塞等Redis超时行为，加入日志监控报警工具可快速定位阻塞问题，同时需要对Redis进程和机器做全面监控。</li> <li>阻塞的内在原因：确认主线程是否存在阻塞，检查慢查询等信息，发现不合理使用API或数据结构的情况，如keys、sort、hgetall等。关注CPU使用率防止单核跑满。当硬盘IO资源紧张时，AOF追加也会阻塞主线程。</li> <li>阻塞的外在原因：从CPU竞争、内存交换、网络问题等方面入手排查是否因为系统层面问题引起阻塞。</li></ul> <h2 id="第八章-理解内存"><a href="#第八章-理解内存" class="header-anchor">#</a> 第八章 理解内存</h2> <h3 id="_1-内存消耗"><a href="#_1-内存消耗" class="header-anchor">#</a> 1. 内存消耗</h3> <p>内存消耗可以分为进程自身消耗和子进程消耗。</p> <h4 id="_1-1-内存使用统计"><a href="#_1-1-内存使用统计" class="header-anchor">#</a> 1.1 内存使用统计</h4> <h4 id="_1-2-内存消耗划分"><a href="#_1-2-内存消耗划分" class="header-anchor">#</a> 1.2 内存消耗划分</h4> <p>Redis进程内消耗主要包括：自身内存+对象内存+缓冲内存+内存碎片。</p> <ul><li>自身内存：消耗很少，可忽略不计。</li> <li>对象内存：是Redis内存占用最大的一块。</li> <li>缓冲内存。
<ul><li>客户端缓冲。</li> <li>复制积压缓冲区。</li> <li>AOF缓冲区。</li></ul></li> <li>内存碎片。</li></ul> <h4 id="_1-3-子进程内存消耗"><a href="#_1-3-子进程内存消耗" class="header-anchor">#</a> 1.3 子进程内存消耗</h4> <p>fork产生的子进程。</p> <p>当前系统如果支持并开启THP，copy-on-write期间内存过度消耗。</p> <h3 id="_2-内存管理"><a href="#_2-内存管理" class="header-anchor">#</a> 2. 内存管理</h3> <p>Redis主要通过控制内存上限和回收策略实现内存管理。</p> <ul><li>设置内存上限：maxmemory。</li> <li>动态调整内存上限：config set maxmemory</li> <li>内存回收策略：
<ul><li>删除过期键对象：
<ul><li>惰性删除</li> <li>定时任务删除</li></ul></li> <li>内存溢出控制策略：
<ul><li>noeviction：默认策略，不会删除任何数据，拒绝所有写入操作并返回客户端错误信息，只响应读操作。</li> <li>volatile-lru：根据LRU算法删除设置了超时属性（expire）的键。</li> <li>allkeys-lru：根据LRU算法删除键，不管数据有没有设置超时属性，直到腾出足够空间为止。</li> <li>allkeys-random：随机删除所有键，直到腾出足够空间。</li> <li>volatile-random：随机删除过期键，直到腾出足够空间。</li> <li>volatile-ttl：根据键值对象的ttl属性，删除最近将要过期数据，如果没有，回退到noeviction策略。</li></ul></li></ul></li></ul> <h3 id="_3-内存优化"><a href="#_3-内存优化" class="header-anchor">#</a> 3. 内存优化</h3> <ul><li><p>缩减键值对象：比如键名短一点。在内存紧张的情况下，可以使用通用压缩算法压缩json、xml后再存入Redis，从而降低内存占用。推荐使用Google的Snappy压缩工具，效率高于GZIP。</p></li> <li><p>共享对象池：共享对象池是指Redis内部维护[0-9999]的整数对象池，用于节约内存。整数对象池在Redis中通过变量REDIS_SHARED_INTEGERS定义，不能通过配置修改。</p></li> <li><p>字符串优化：</p> <ul><li><p>字符串结构：内部简单动态字符串（SDS）。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">struct</span> <span class="token class-name">SDS</span><span class="token punctuation">{</span>
	<span class="token keyword">int</span> len<span class="token punctuation">;</span><span class="token comment">//已用字节长度</span>
	<span class="token keyword">int</span> free<span class="token punctuation">;</span><span class="token comment">//未用字节长度</span>
	<span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//字节数组</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>O(1)时间复杂度获取。</p></li> <li><p>预分配机制，尽量减少字符串频繁修改操作如append、setrange，改为直接使用set修改字符串，降低预分配带来的内存浪费和内存碎片化。</p></li> <li><p>字符串重构：指不一定把每份数据作为字符串整体存储，像json这样的数据可以使用hash结构。</p></li></ul></li> <li><p>编码优化：type和encoding对应关系表</p> <ul><li>string：raw（动态字符串编码）、embstr（优化内存分配的字符串编码）、int（整数编码）</li> <li>hash：hashtable（散列表编码）、ziplist（压缩列表编码）</li> <li>list：linkedlist（双向链表编码）、ziplist（压缩列表编码）、quicklist（3.2版本新的列表编码）</li> <li>set：hashtable（散列表编码）、intset（整数集合编码）</li> <li>zset：skiplist（跳跃表编码）、ziplist（压缩列表编码）</li></ul></li></ul> <p><img src="C:%5CUsers%5C12272%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210117171721862.png" alt="image-20210117171721862"></p> <p><img src="C:%5CUsers%5C12272%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210117171730112.png" alt="image-20210117171730112"></p> <ul><li>控制键的数量。</li></ul> <h3 id="_4-总结-3"><a href="#_4-总结-3" class="header-anchor">#</a> 4. 总结</h3> <ul><li>Redis实际内存消耗主要包括：键值对象、缓冲区内存、内存碎片。</li> <li>通过调整maxmemory控制Redis最大可用内存，当内存使用超出时，根据maxmemory-policy控制内存回收策略。</li> <li>内存是相对宝贵的资源，通过合理的优化可以有效地降低内存的使用量，内存优化的思路包括：
<ul><li>精简键值对大小，键值字面量精简，使用高效二进制序列化工具。</li> <li>使用对象共享池优化小整数对象。</li> <li>数据优先使用整数，比字符串类型更节省空间。</li> <li>优化字符串使用，避免预分配造成的内存浪费。</li> <li>使用ziplist压缩编码优化hash、list等结构，注重效率和空间的平衡。</li> <li>使用intset编码优化整数集合。</li> <li>使用ziplist编码的hash结构降低小对象链规模。</li></ul></li></ul> <h2 id="第九章-哨兵"><a href="#第九章-哨兵" class="header-anchor">#</a> 第九章 哨兵</h2> <p>Redis的主从复制模式下，一旦主节点由于故障不能提供服务，需要人工将从节点提升为主节点，同时还要通知应用方更新主节点地址，对于很多应用场景这种故障处理的方式是无法接受的。</p> <p>可喜的是Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p> <h3 id="_1-基本概念"><a href="#_1-基本概念" class="header-anchor">#</a> 1. 基本概念</h3> <table><thead><tr><th style="text-align:center;">名词</th> <th style="text-align:center;">逻辑结构</th> <th style="text-align:center;">物理结构</th></tr></thead> <tbody><tr><td style="text-align:center;">主节点（master）</td> <td style="text-align:center;">Redis主服务/数据库</td> <td style="text-align:center;">一个独立的Redis进程</td></tr> <tr><td style="text-align:center;">从节点（slave）</td> <td style="text-align:center;">Redis从服务/数据库</td> <td style="text-align:center;">一个独立的Redis进程</td></tr> <tr><td style="text-align:center;">Redis数据节点</td> <td style="text-align:center;">主节点和从节点</td> <td style="text-align:center;">主节点和从节点的进程</td></tr> <tr><td style="text-align:center;">Sentinel节点</td> <td style="text-align:center;">监控Redis数据节点</td> <td style="text-align:center;">一个独立的Sentinel进程</td></tr> <tr><td style="text-align:center;">Sentinel节点集合</td> <td style="text-align:center;">若干Sentinel节点的抽象组合</td> <td style="text-align:center;">若干Sentinel节点进程</td></tr> <tr><td style="text-align:center;">Redis Sentinel</td> <td style="text-align:center;">Redis高可用实现方案</td> <td style="text-align:center;">Sentinel节点集合和Redis数据节点进程</td></tr> <tr><td style="text-align:center;">应用方</td> <td style="text-align:center;">泛指一个或多个客户端</td> <td style="text-align:center;">一个或者多个客户端进程或者线程</td></tr></tbody></table> <p>Redis Sentinel是Redis的高可用实现方案。</p> <h4 id="_1-1-主从复制的问题"><a href="#_1-1-主从复制的问题" class="header-anchor">#</a> 1.1 主从复制的问题</h4> <ul><li>一旦主节点由于故障不能提供服务，需要人工将从节点提升为主节点，同时还要通知应用方更新主节点地址，整个过程都需要人工干预。</li> <li>主节点的写能力受到单机的限制。</li> <li>主节点的存储能力受到单机的限制。</li></ul> <p>第一个是高可用问题，后面两个是分布式问题。</p> <h4 id="_1-2-高可用"><a href="#_1-2-高可用" class="header-anchor">#</a> 1.2 高可用</h4> <h4 id="_1-3-redis-sentinel的高可用性"><a href="#_1-3-redis-sentinel的高可用性" class="header-anchor">#</a> 1.3 Redis Sentinel的高可用性</h4> <p>当主节点出现故障时，Redis Sentinel能自动完成故障发现和故障转移，并通知应用方，从而实现真正的高可用。</p> <p>Redis Sentinel建议使用2.8以上版本。</p> <p>Redis Sentinel是一个分布式架构，其中包含若干个Sentinel节点和Redis数据节点，每个Sentinel节点会对数据节点和其余Sentinel节点进行监控，当它发现节点不可达时，会对节点做下线标识。如果被标识的是主节点，它还会和其他Sentinel节点进行“协商”，会选举出一个Sentinel节点来完成自动故障转移的工作，同时会将这个变化实时通知给Redis应用方。整个过程完全是自动的，不需要人工来介入。</p> <p>Redis Sentinel与Redis主从复制模式只是多了若干Sentinel节点，所以Redis Sentinel并没有针对Redis节点做了特殊处理。</p> <p>从逻辑结构上看，Sentinel节点集合会定期对所有节点进行监控，特别是对主节点的故障实现自动转移。</p> <p>Redis Sentinel具有以下几个功能：</p> <ul><li>监控：Sentinel节点会定期检测Redis数据节点，其余Sentinel节点是否可达。</li> <li>通知：Sentinel节点会将故障转移的结果通知给应用方。</li> <li>主节点故障转移：实现从节点晋升为主节点并维护后续正确的主从关系。</li> <li>配置提供者：在Redis Sentinel结构中，客户端在初始化的时候连接的是Sentinel节点集合，从中获取主节点信息。</li> <li>Sentinel节点本身就是独立的Redis节点，只不过它们不存储数据，只支持部分命令。</li></ul> <h3 id="_2-安装和部署"><a href="#_2-安装和部署" class="header-anchor">#</a> 2. 安装和部署</h3> <h4 id="_2-1-部署拓扑结构"><a href="#_2-1-部署拓扑结构" class="header-anchor">#</a> 2.1 部署拓扑结构</h4> <p>以1个主节点、2个从节点和3个Sentinel节点组成一个Redis Sentinel。</p> <h4 id="_2-2-部署节点"><a href="#_2-2-部署节点" class="header-anchor">#</a> 2.2 部署节点</h4> <ul><li><p>主节点配置：redis-6379.conf</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>port 6379
daemonize yes
logfile <span class="token string">&quot;6379.log&quot;</span>
dbfilename <span class="token string">&quot;dump-6379.rdb&quot;</span>
dir <span class="token string">&quot;/etc/redis/data/&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></li> <li><p>从节点配置1：redis-6380.conf，加了slaveof 127.0.0.1 6379</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>port 6380
daemonize yes
logfile <span class="token string">&quot;6380.log&quot;</span>
dbfilename <span class="token string">&quot;dump-6380.rdb&quot;</span>
dir <span class="token string">&quot;/etc/redis/data/&quot;</span>
slaveof 127.0.0.1 6379
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>从节点配置2：redis-6381.conf，加了slaveof 127.0.0.1 6379</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>port 6381
daemonize yes
logfile <span class="token string">&quot;6381.log&quot;</span>
dbfilename <span class="token string">&quot;dump-6381.rdb&quot;</span>
dir <span class="token string">&quot;/etc/redis/data/&quot;</span>
slaveof 127.0.0.1 6379
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div></li> <li><p>确认主从关系：info replication</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6378&gt; info replication
# Replication
<span class="token property">role</span><span class="token punctuation">:</span>master
<span class="token property">connected_slaves</span><span class="token punctuation">:</span>2
<span class="token property">slave0</span><span class="token punctuation">:</span>ip=127.0.0.1<span class="token punctuation">,</span>port=6380<span class="token punctuation">,</span>state=online<span class="token punctuation">,</span>offset=56<span class="token punctuation">,</span>lag=1
<span class="token property">slave1</span><span class="token punctuation">:</span>ip=127.0.0.1<span class="token punctuation">,</span>port=6381<span class="token punctuation">,</span>state=online<span class="token punctuation">,</span>offset=56<span class="token punctuation">,</span>lag=1
<span class="token property">master_replid</span><span class="token punctuation">:</span>05ebb9bbc0c03056b001591108181ee12d0199f2
<span class="token property">master_replid2</span><span class="token punctuation">:</span>0000000000000000000000000000000000000000
<span class="token property">master_repl_offset</span><span class="token punctuation">:</span>56
<span class="token property">second_repl_offset</span><span class="token punctuation">:</span>-1
<span class="token property">repl_backlog_active</span><span class="token punctuation">:</span>1
<span class="token property">repl_backlog_size</span><span class="token punctuation">:</span>1048576
<span class="token property">repl_backlog_first_byte_offset</span><span class="token punctuation">:</span>1
<span class="token property">repl_backlog_histlen</span><span class="token punctuation">:</span>56

127.0.0.1<span class="token punctuation">:</span>6380&gt; info replication
# Replication
<span class="token property">role</span><span class="token punctuation">:</span>slave
<span class="token property">master_host</span><span class="token punctuation">:</span>127.0.0.1
<span class="token property">master_port</span><span class="token punctuation">:</span>6378
<span class="token property">master_link_status</span><span class="token punctuation">:</span>up
<span class="token property">master_last_io_seconds_ago</span><span class="token punctuation">:</span>9
<span class="token property">master_sync_in_progress</span><span class="token punctuation">:</span>0
<span class="token property">slave_repl_offset</span><span class="token punctuation">:</span>98
<span class="token property">slave_priority</span><span class="token punctuation">:</span>100
<span class="token property">slave_read_only</span><span class="token punctuation">:</span>1
<span class="token property">connected_slaves</span><span class="token punctuation">:</span>0
<span class="token property">master_replid</span><span class="token punctuation">:</span>05ebb9bbc0c03056b001591108181ee12d0199f2
<span class="token property">master_replid2</span><span class="token punctuation">:</span>0000000000000000000000000000000000000000
<span class="token property">master_repl_offset</span><span class="token punctuation">:</span>98
<span class="token property">second_repl_offset</span><span class="token punctuation">:</span>-1
<span class="token property">repl_backlog_active</span><span class="token punctuation">:</span>1
<span class="token property">repl_backlog_size</span><span class="token punctuation">:</span>1048576
<span class="token property">repl_backlog_first_byte_offset</span><span class="token punctuation">:</span>1
<span class="token property">repl_backlog_histlen</span><span class="token punctuation">:</span>98
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div></li> <li><p>部署sentinel节点：redis-sentinel-26379.conf</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>port 26379
daemonize yes
logfile <span class="token string">&quot;26379.log&quot;</span>
dir <span class="token string">&quot;/etc/redis/data&quot;</span>
sentinel monitor mymaster 127.0.0.1 6378 2
sentinel down-after-milliseconds mymaster 30000
sentinel parallel-syncs mymaster 1
sentinel failover-timeout mymaster 180000
sentinel auth-pass mymaster hqjmz5201314


# sentinel monitor mymaster 127.0.0.1 6378 &lt;quorum&gt;2代表判断主节点失败至少需要2个Sentinel节点同意<span class="token punctuation">,</span>一般将其设置为Sentinel节点的一半加1
# mymaster是主节点的别名
# 每个sentinel节点都要通过定期发送ping命令来判断Redis数据节点和其余Sentinel节点是否可达，如果超过了
# sentinel down-after-milliseconds &lt;times&gt; 配置的时间且没有有效的回复，则判定节点不可达。&lt;times&gt;就是超时时间，单位为毫秒。
# sentinel parallel-syncs &lt;master-name&gt; &lt;nums&gt; ：当Sentinel节点集合对主节点故障判定达成一致时，sentinel领导者节点会做故障转移操作，选出
# 新的主节点，原来的从节点会向新的主节点发起复制操作，parallel-syncs就是用来限制在一次故障转移之后，每次向新的主节点发起复制操作的从节点个数。
# sentinel failover-timeout &lt;master-name&gt; &lt;times&gt; 
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div></li> <li><p>启动sentinel节点：</p> <ul><li>redis-sentinel redis-sentinel-26379.conf</li> <li>redis-server redis-sentinel-26379.conf --sentinel 两种方法本质上是一样的</li></ul></li> <li><p>info sentinel：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ redis]# redis-cli -h 127.0.0.1 -p 26379
127.0.0.1<span class="token punctuation">:</span>26379&gt; info sentinel
# Sentinel
<span class="token property">sentinel_masters</span><span class="token punctuation">:</span>1
<span class="token property">sentinel_tilt</span><span class="token punctuation">:</span>0
<span class="token property">sentinel_running_scripts</span><span class="token punctuation">:</span>0
<span class="token property">sentinel_scripts_queue_length</span><span class="token punctuation">:</span>0
<span class="token property">sentinel_simulate_failure_flags</span><span class="token punctuation">:</span>0
<span class="token property">master0</span><span class="token punctuation">:</span>name=mymaster<span class="token punctuation">,</span>status=ok<span class="token punctuation">,</span>address=127.0.0.1<span class="token punctuation">:</span>6378<span class="token punctuation">,</span>slaves=2<span class="token punctuation">,</span>sentinels=3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div></li> <li><p>failover-timeout通常被解释成故障转移超时时间，但实际上它作用于故障转移的各个阶段：</p> <ul><li>a.选出合适从节点。</li> <li>b.晋升选出的从节点为主节点。</li> <li>c.命令其余从节点复制新的主节点。</li> <li>d.等待原主节点恢复后命令它去复制新的主节点。</li></ul></li> <li><p>调整配置：sentinel set </p><param> <value><p></p> <ul><li>sentinel set mymaster quorum 2</li> <li>有几点需要注意是：
<ul><li>sentinel set 命令只对当前sentinel节点有效。</li> <li>sentinel set 命令如果执行成功会立即刷新配置文件，这点和Redis普通数据节点设置配置需要执行config rewrite刷新到配置文件不同。</li> <li>建议所有sentinel节点的配置尽可能一致。</li></ul></li></ul></value></li></ul> <h4 id="_2-3-部署技巧"><a href="#_2-3-部署技巧" class="header-anchor">#</a> 2.3 部署技巧</h4> <ul><li>sentinel节点不应该部署在一台物理“机器”上。怕物理机器有什么故障。</li> <li>部署至少三个且奇数个的sentinel节点。因为领导者选举需要至少一半加1个节点，奇数个节点可以在满足该条件的基础上节省一个节点。</li> <li>只有一套sentinel，还是每个主节点配置一套sentinel？sentinel节点集合可以只监控一个主节点，也可以监控多个主节点。</li></ul> <h3 id="_3-api"><a href="#_3-api" class="header-anchor">#</a> 3. API</h3> <p>sentinel节点是一个特殊的redis节点，有自己专属的API。</p> <ul><li>sentinel masters：展示所有被监控的主节点状态以及相关的统计信息。</li> <li>sentinel master<master name=""> ：展示指定的主节点的信息。</master></li> <li>sentinel slaves <master name="">：展示指定的主节点的从节点的信息</master></li> <li>sentinel sentinels<master name="">：展示指定的主节点的sentinel节点集合信息</master></li></ul> <h3 id="_4-客户端连接"><a href="#_4-客户端连接" class="header-anchor">#</a> 4. 客户端连接</h3> <p>Jedis针对Redis Sentinel给出了一个JedisSentinelPool。</p> <h3 id="_5-实现原理"><a href="#_5-实现原理" class="header-anchor">#</a> 5. 实现原理</h3> <ul><li>三个定时监控任务：
<ul><li>每隔10秒，每个Sentinel节点会向主节点和从节点发送info命令获取最新的拓扑结构。</li> <li>每隔2秒，每个Sentinel节点会向Redis数据节点的_sentinel_: hello频道上发送该Sentinel节点对于主节点的判断以及当前Sentinel节点的信息，同时每个Sentinel节点也会订阅该频道，来了解其他Sentinel节点以及它们对主节点的判断。</li> <li>每隔1秒，每个Sentinel节点会向主节点、从节点、其余Sentinel节点发送一条ping命令做一次心跳检测，来确认这些节点是否可达。</li></ul></li> <li>主观下线和客户下线：
<ul><li>主观下线：每个Sentinel节点会每隔1秒对主节点、从节点、其他Sentinel节点发送ping命令做心跳检测，当这些节点超过down-after-milliseconds没有进行有效回复，Sentinel节点就会对该节点做失败判定，这个行为叫做主观下线。</li> <li>客观下线：当Sentinel主观下线的节点是主节点时，该Sentinel节点会通过sentinel is-master-down-by-addr命令向其他Sentinel节点询问对主节点的判断，当超过<quorum>个数，Sentinel节点会认为主节点确实有问题，这时该Sentinel节点会做出客观下线的决定，这样客观下线的含义是比较明显了，也就是大部分Sentinel节点都对主节点的下线做了同意的判定，那么这个判定就是客观的。</quorum></li></ul></li> <li>领导者Sentinel节点选举：
<ul><li>实际上故障转移的工作只需要一个Sentinel节点来完成即可，所以Sentinel节点之间会做一个领导者选举的工作，选出一个Sentinel节点作为领导者进行故障转移的工作。Redis使用了Raft算法实现领导者选举。</li></ul></li> <li>故障转移：
<ul><li>领导者选举出的Sentinel节点负责故障转移，具体步骤如下：
<ul><li>在从节点列表中选出一个节点作为新的主节点：选择在线的、slave-priority（从节点优先级）最高的从节点列表、复制偏移量最大的从节点（复制的最完整）、runId最小的从节点。</li> <li>Sentinel领导者节点会对第一步选出来的从节点执行slave of no one命令让其成为主节点。</li> <li>Sentinel领导者节点会向剩余的从节点发送命令，让他们成新主节点的从节点，复制规则和parallel-syncs参数有关。</li> <li>Sentinel节点集合会将原来的主节点更新为从节点，并保持着对其关注，当其恢复后命令它去复制新的主节点。</li></ul></li></ul></li></ul> <h3 id="_6-总结"><a href="#_6-总结" class="header-anchor">#</a> 6. 总结</h3> <ul><li>Redis Sentinel是Redis的高可用实现方案：故障发现、故障自动转移、配置中心、客户端通知。</li> <li>Redis Sentinel从Redis2.8版本开始才正式生产可用，之前版本生产不可用。</li> <li>尽可能在不同物理机上部署Redis Sentinel所有节点。</li> <li>Redis Sentinel中的Sentinel节点个数应该大于等于3且最好为奇数。</li> <li>Redis Sentinel中的数据节点与普通数据节点没有区别。</li> <li>客户端初始化时连接的是Sentinel节点集合，不再是具体的Redis节点，但Sentinel只是配置中心不是代理。</li> <li>Redis Sentinel通过三个定时任务实现了Sentinel节点对于主节点、从节点、其余Sentinel节点的监控。</li> <li>Redis Sentinel在对节点做失败判定时分为主观下线和客观下线。</li> <li>Redis Sentinel实现读写分离高可用可以依赖Sentinel节点的消息通知，获取Redis数据节点的状态变化。</li></ul> <h2 id="第十章-集群"><a href="#第十章-集群" class="header-anchor">#</a> 第十章 集群</h2> <p>Redis Cluster是Redis的分布式解决方案，在3.0版本正式推出，有效得解决了Redis分布式方面的需求。</p> <p>以前Redis分布式方案一般是两种：客户端分区方案，代理方案。</p> <h3 id="_1-数据分布"><a href="#_1-数据分布" class="header-anchor">#</a> 1. 数据分布</h3> <h4 id="_1-1-数据分布理论"><a href="#_1-1-数据分布理论" class="header-anchor">#</a> 1.1 数据分布理论</h4> <p>常见的分区规则：哈希分区、顺序分区。</p> <table><thead><tr><th style="text-align:center;">分区方式</th> <th style="text-align:center;">特点</th> <th style="text-align:center;">代表产品</th></tr></thead> <tbody><tr><td style="text-align:center;">哈希分区</td> <td style="text-align:center;">离散度好，数据分布业务无关，无法顺序访问</td> <td style="text-align:center;">Redis Cluster、Cassandra</td></tr> <tr><td style="text-align:center;">顺序分区</td> <td style="text-align:center;">离散度易倾斜、数据分布业务相关、可顺序访问</td> <td style="text-align:center;">Bigtable、HBase、Hypertable</td></tr></tbody></table> <p>常见的哈希分区规则有几种：</p> <ul><li>节点取余分区：使用特定的数据，如Redis的键或用户ID，再根据节点数量N使用公式：hash(key)%N计算出哈希值，用来决定数据映射到哪一个节点上。这种方案存在一个问题：当节点数量变化时，如扩容或收缩节点，数据节点映射关系需要重新计算，会导致数据的重新迁移。这种方式的突出优点是简单性，常用语数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数，比如划分为512或1024张表，保证可支撑未来一段时间的数据量，再根据负载情况将表迁移到其他数据库中。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。</li> <li>一致性哈希分区：一致性哈希分区（Distributed Hash Table）实现思路是为系统中每个节点分配一个token，范围一般在0~2^32，这些token构成一个哈希环。数据读写执行节点查找操作时，先根据key计算hash值，然后顺时针找到第一个大于等于该哈希值的token节点。这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响，但一致性哈希分区存在几个问题：
<ul><li>加减节点会造成哈希环中部分数据无法命中。</li> <li>当使用少量节点时，节点变化将大范围影响哈希环中数据映射。</li> <li>普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。</li></ul></li> <li>虚拟槽分区：正因为一致性哈希分区的缺点，一些分布式系统采用虚拟槽对一致性哈希进行改进，比如Dynamo系统。
<ul><li>虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，比如Redis Cluster槽范围是0~16383，槽是集群内数据管理和迁移的基本单位。采用大范围槽的主要目的是为了方便数据拆分和集群扩展。</li> <li>当前集群有5个节点，每个节点平均大约负责3276个槽。由于采用高质量的哈希算法，每个槽所映射的数据通常比较均匀，将数据平均划分到5个节点进行数据分区。Redis Cluster就是采用虚拟槽分区。</li></ul></li></ul> <h4 id="_1-2-redis数据分区"><a href="#_1-2-redis数据分区" class="header-anchor">#</a> 1.2 Redis数据分区</h4> <p>Redis Cluster采用虚拟槽分区，所有的键根据哈希函数映射到0~16383整数槽内，计算公式：slot=CRC16(key)&amp;16383。每一个节点负责维护一部分槽以及槽所映射的键值数据。</p> <p>Redis虚拟槽分区的特点：</p> <ul><li>解耦数据和节点之间的关系，简化了节点扩容和收缩难度。</li> <li>节点自身维护槽的映射关系，不需要客户端或者代理服务维护维护槽分区元数据。</li> <li>支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景。</li></ul> <p>数据分区是分布式存储的核心，理解和灵活运用数据分区规则对于掌握Redis Cluster非常有帮助。</p> <h4 id="_1-3-集群功能限制"><a href="#_1-3-集群功能限制" class="header-anchor">#</a> 1.3 集群功能限制</h4> <p>Redis集群相对单机在功能上存在一些限制。</p> <ul><li>key批量操作支持有限，如mset、mget，目前只支持具有相同slot值的key执行批量操作。</li> <li>key事务操作支持有限，同理只支持多key在同一节点上的事务操作，当多个key分布在不同的节点上时无法使用事务功能。</li> <li>key作为数据分区的最小粒度，因此不能将一个大的键值对象如hash、list等映射到不同的节点。</li> <li>集群规模下只能使用一个数据空间，即db0。</li> <li>复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。</li></ul> <h3 id="_2-搭建集群"><a href="#_2-搭建集群" class="header-anchor">#</a> 2. 搭建集群</h3> <p>搭建集群需要三个步骤：准备节点，节点握手，分配槽。</p> <h4 id="_2-1-准备节点"><a href="#_2-1-准备节点" class="header-anchor">#</a> 2.1 准备节点</h4> <p>Redis集群一般由多个节点组成，节点数量至少为6个才能保证组成完整高可用的集群。每个节点需要开启配置cluster-enabled yes，让Redis运行在集群模式下。建议为集群内所有节点统一目录，一般划分三个目录：conf、data、log，分布存放配置、数据和日志相关文件。把6个节点配置统一放在conf目录下，集群相关配置如下：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ conf]# cat redis-6378.conf 
port 6378
daemonize yes
logfile <span class="token string">&quot;/etc/redis-cluster/log/6378.log&quot;</span>
dbfilename <span class="token string">&quot;dump-6378.rdb&quot;</span>
dir <span class="token string">&quot;/etc/redis-cluster/data/&quot;</span>
requirepass hqjmz5201314
cluster-enabled yes
cluster-node-timeout 15000
cluster-config-file <span class="token string">&quot;nodes-6378.conf&quot;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>节点6378首次启动后生成集群配置如下：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ data]# cat nodes-6378.conf 
<span class="token property">a228b36017918bd962f26764f39f9a46df3e7c36</span> <span class="token punctuation">:</span>0@0 myself<span class="token punctuation">,</span>master - 0 0 0 connected
vars currentEpoch 0 lastVoteEpoch 0
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li><p>节点ID：a228b36017918bd962f26764f39f9a46df3e7c36，节点ID，40位16进制字符串，用于唯一标识集群内一个节点。与运行id不同，运行id每次重启都会变，而节点id只在初始化时创建一次。</p></li> <li><p>cluster nodes：获取集群节点状态。</p> <div class="language- line-numbers-mode"><pre class="language-text"><code>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div></li></ul> <h4 id="_2-2-节点握手"><a href="#_2-2-节点握手" class="header-anchor">#</a> 2.2 节点握手</h4> <p>节点握手是指一批运行在集群模式下的节点通过Gossip协议彼此通信，达到感知对方的过程。节点握手是集群彼此通信的第一步，由客户端发起命令：cluster meet{ip} {port}。</p> <p>cluster meet 命令是一个异步命令，执行之后立刻返回。内部发起与目标节点进行握手通信。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6380
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6381
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6381
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6382
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6383
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster meet 127.0.0.1 6384
OK
127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster nodes
cc85b0b121020f767fae7b46bc23b79774a54af2 127.0.0.1<span class="token punctuation">:</span>6381@16381 master - 0 1611297128000 4 connected
fc6335f4f0b6bfca8885cd8aefca9d592b9409df 127.0.0.1<span class="token punctuation">:</span>6384@16384 master - 0 1611297127454 0 connected
efe9ddb7e7239dd84dd10e3ed7b5def9636221f0 127.0.0.1<span class="token punctuation">:</span>6383@16383 master - 0 1611297129558 5 connected
a54cb0e357f67905e62ad8680495c1c0e7e22619 127.0.0.1<span class="token punctuation">:</span>6380@16380 master - 0 1611297128557 2 connected
3bb01c17b589bf454e4056e401659f64deaf6649 127.0.0.1<span class="token punctuation">:</span>6382@16382 master - 0 1611297128000 3 connected
a228b36017918bd962f26764f39f9a46df3e7c36 127.0.0.1<span class="token punctuation">:</span>6378@16378 myself<span class="token punctuation">,</span>master - 0 1611297127000 1 connected
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br></div></div><p>ping、pong、ping、pong。</p> <p>只需要在集群内任意节点上执行cluster meet 命令加入新节点，握手状态会通过消息在集群内传播，这样其他节点会自动发现新节点并发起握手流程。</p> <p>节点建立握手之后集群还不能正常工作，这时集群处于下线状态，所有的数据读写都被禁止。</p> <p>cluster info 命令可以获取集群当前状态。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster info
<span class="token property">cluster_state</span><span class="token punctuation">:</span>fail
<span class="token property">cluster_slots_assigned</span><span class="token punctuation">:</span>0
<span class="token property">cluster_slots_ok</span><span class="token punctuation">:</span>0
<span class="token property">cluster_slots_pfail</span><span class="token punctuation">:</span>0
<span class="token property">cluster_slots_fail</span><span class="token punctuation">:</span>0
<span class="token property">cluster_known_nodes</span><span class="token punctuation">:</span>6
<span class="token property">cluster_size</span><span class="token punctuation">:</span>0
<span class="token property">cluster_current_epoch</span><span class="token punctuation">:</span>5
<span class="token property">cluster_my_epoch</span><span class="token punctuation">:</span>1
<span class="token property">cluster_stats_messages_ping_sent</span><span class="token punctuation">:</span>21
<span class="token property">cluster_stats_messages_pong_sent</span><span class="token punctuation">:</span>29
<span class="token property">cluster_stats_messages_meet_sent</span><span class="token punctuation">:</span>6
<span class="token property">cluster_stats_messages_sent</span><span class="token punctuation">:</span>56
<span class="token property">cluster_stats_messages_ping_received</span><span class="token punctuation">:</span>29
<span class="token property">cluster_stats_messages_pong_received</span><span class="token punctuation">:</span>27
<span class="token property">cluster_stats_messages_received</span><span class="token punctuation">:</span>56
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>从输出内容可以看到，被分配的槽（cluster_slots_assgined）是0，由于目前所有的槽没有分配到节点，因此集群无法完成槽到节点的映射，只有当16384个槽全部分配给节点后，集群才进入在线状态。</p> <h4 id="_2-3-分配槽"><a href="#_2-3-分配槽" class="header-anchor">#</a> 2.3 分配槽</h4> <p>Redis集群把所有的数据映射到16384个槽中，每个key会映射为一个固定的槽，只有当节点分配了槽，才能响应和这些槽关联的键命令。通过cluster addslots命令为节点分配槽，这里利用bash特性批量设置槽（slots）：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root<span class="token atrule"><span class="token rule">@iZwz9ioqjurm6uydyxxjqnZ</span> redis-cluster]#  redis-cli -h 127.0.0.1 -p 6378 -a hqjmz5201314 cluster addslots</span> <span class="token punctuation">{</span>0..5461<span class="token punctuation">}</span>
OK
[root<span class="token atrule"><span class="token rule">@iZwz9ioqjurm6uydyxxjqnZ</span> redis-cluster]#  redis-cli -h 127.0.0.1 -p 6380 -a hqjmz5201314 cluster addslots</span> <span class="token punctuation">{</span>5462..10922<span class="token punctuation">}</span>
OK
[root<span class="token atrule"><span class="token rule">@iZwz9ioqjurm6uydyxxjqnZ</span> redis-cluster]#  redis-cli -h 127.0.0.1 -p 6381 -a hqjmz5201314 cluster addslots</span> <span class="token punctuation">{</span>10923..16383<span class="token punctuation">}</span>
OK
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>当前集群状态是OK，集群进入在线状态，所有的槽已经分配给节点：</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster info
<span class="token property">cluster_state</span><span class="token punctuation">:</span>ok
<span class="token property">cluster_slots_assigned</span><span class="token punctuation">:</span>16384
<span class="token property">cluster_slots_ok</span><span class="token punctuation">:</span>16384
<span class="token property">cluster_slots_pfail</span><span class="token punctuation">:</span>0
<span class="token property">cluster_slots_fail</span><span class="token punctuation">:</span>0
<span class="token property">cluster_known_nodes</span><span class="token punctuation">:</span>6
<span class="token property">cluster_size</span><span class="token punctuation">:</span>3
<span class="token property">cluster_current_epoch</span><span class="token punctuation">:</span>5
<span class="token property">cluster_my_epoch</span><span class="token punctuation">:</span>1
<span class="token property">cluster_stats_messages_ping_sent</span><span class="token punctuation">:</span>1594
<span class="token property">cluster_stats_messages_pong_sent</span><span class="token punctuation">:</span>1586
<span class="token property">cluster_stats_messages_meet_sent</span><span class="token punctuation">:</span>6
<span class="token property">cluster_stats_messages_sent</span><span class="token punctuation">:</span>3186
<span class="token property">cluster_stats_messages_ping_received</span><span class="token punctuation">:</span>1586
<span class="token property">cluster_stats_messages_pong_received</span><span class="token punctuation">:</span>1600
<span class="token property">cluster_stats_messages_received</span><span class="token punctuation">:</span>3186

127.0.0.1<span class="token punctuation">:</span>6378&gt; cluster nodes
cc85b0b121020f767fae7b46bc23b79774a54af2 127.0.0.1<span class="token punctuation">:</span>6381@16381 master - 0 1611298779000 4 connected 10923-16383
fc6335f4f0b6bfca8885cd8aefca9d592b9409df 127.0.0.1<span class="token punctuation">:</span>6384@16384 master - 0 1611298780000 0 connected
efe9ddb7e7239dd84dd10e3ed7b5def9636221f0 127.0.0.1<span class="token punctuation">:</span>6383@16383 master - 0 1611298780000 5 connected
a54cb0e357f67905e62ad8680495c1c0e7e22619 127.0.0.1<span class="token punctuation">:</span>6380@16380 master - 0 1611298781500 2 connected 5462-10922
3bb01c17b589bf454e4056e401659f64deaf6649 127.0.0.1<span class="token punctuation">:</span>6382@16382 master - 0 1611298780497 3 connected
a228b36017918bd962f26764f39f9a46df3e7c36 127.0.0.1<span class="token punctuation">:</span>6378@16378 myself<span class="token punctuation">,</span>master - 0 1611298781000 1 connected 0-5461
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>目前还有三个节点没有使用，作为一个完整的集群，每个负责处理槽的节点应该具有从节点，保证当它出现故障时可以自动进行故障转移。集群模式下，Redis节点角色分为主节点和从节点。首次启动的节点和被分配槽的节点都是主节点，从节点负责复制主节点槽信息和相关的数据。</p> <p>使用cluster replicate {nodeId}命令让一个节点成为从节点。其中命令执行必须在对应的从节点上执行，nodeId是要复制主节点的节点ID。</p> <p>Redis集群模式下的主从复制使用了之前介绍的Redis复制流程，依然支持全量和部分支持。</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>[root@iZwz9ioqjurm6uydyxxjqnZ redis-cluster]# redis-cli -h 127.0.0.1 -p 6382 -a hqjmz5201314 cluster replicate a228b36017918bd962f26764f39f9a46df3e7c36
OK
[root@iZwz9ioqjurm6uydyxxjqnZ redis-cluster]# redis-cli -h 127.0.0.1 -p 6383 -a hqjmz5201314 cluster replicate a54cb0e357f67905e62ad8680495c1c0e7e22619
OK
[root@iZwz9ioqjurm6uydyxxjqnZ redis-cluster]# redis-cli -h 127.0.0.1 -p 6384 -a hqjmz5201314 cluster replicate cc85b0b121020f767fae7b46bc23b79774a54af2
OK
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>目前为止，我们依照Redis协议手动建立了一个集群，它由6个节点构成，3个主节点负责处理槽和相关数据，3个从节点负责故障转移。</p> <p>Redis官方提供了redis-trib.rb工具方便快速搭建集群。</p> <h4 id="_2-4-用redis-trib-rb搭建集群"><a href="#_2-4-用redis-trib-rb搭建集群" class="header-anchor">#</a> 2.4 用redis-trib.rb搭建集群</h4> <p>redis-trib.rb是官方提供的Redis Cluster的管理工具，无需额外下载，默认位于源码包的src目录下，但因该工具是用ruby开发的，所以需要准备相关的依赖环境。</p> <p><strong>准备redis-trib.rb的运行环境</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>-- 下载ruby
<span class="token function">wget</span> https://cache.ruby-lang.org/pub/ruby/2.5/ruby-2.5.1.tar.gz

-- 安装ruby
<span class="token function">tar</span> xvf ruby-2.5.1.tar.gz

./configure -prefix<span class="token operator">=</span>/usr/local/ruby

<span class="token function">make</span>

<span class="token function">make</span> <span class="token function">install</span>

<span class="token builtin class-name">cd</span> /usr/local/ruby/

<span class="token function">sudo</span> <span class="token function">cp</span> bin/ruby /usr/local/bin

<span class="token function">sudo</span> <span class="token function">cp</span> bin/gem /usr/local/bin
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p><strong>安装rubygem redis依赖</strong></p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code><span class="token function">wget</span> http://rubygems.org/downloads/redis-3.3.0.gem

gem <span class="token function">install</span> -l redis-3.3.0.gem
gem list --check redis gem
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><strong>安装redis-trib.rb</strong></p> <p>sudo cp /{redis_home}/src/redis-trib.rb /user/local/bin</p> <p>安装完ruby环境后，执行redis-trib.rb命令确认环境是否正确，输出如下：</p> <div class="language-shell line-numbers-mode"><pre class="language-shell"><code>redis-trib.rb
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>redis-trib.rb提供了集群创建、检查、修复、均衡等命令行工具。</p> <p>redis-trib create命令可快速搭建集群。</p> <p>Redis5.X以后不推荐使用 redis-trib 命令创建集群</p> <p>用redis-cli --cluster代替</p> <div class="language-css line-numbers-mode"><pre class="language-css"><code>redis-cli --cluster help
Cluster Manager <span class="token property">Commands</span><span class="token punctuation">:</span>
  create         <span class="token property">host1</span><span class="token punctuation">:</span>port1 ... <span class="token property">hostN</span><span class="token punctuation">:</span>portN   #创建集群
                 --cluster-replicas &lt;arg&gt;      #从节点个数
  check          <span class="token property">host</span><span class="token punctuation">:</span>port                     #检查集群
                 --cluster-search-multiple-owners #检查是否有槽同时被分配给了多个节点
  info           <span class="token property">host</span><span class="token punctuation">:</span>port                     #查看集群状态
  fix            <span class="token property">host</span><span class="token punctuation">:</span>port                     #修复集群
                 --cluster-search-multiple-owners #修复槽的重复分配问题
  reshard        <span class="token property">host</span><span class="token punctuation">:</span>port                     #指定集群的任意一节点进行迁移slot，重新分slots
                 --cluster-from &lt;arg&gt;          #需要从哪些源节点上迁移slot，可从多个源节点完成迁移，以逗号隔开，传递的是节点的node id，还可以直接传递--from all，这样源节点就是集群的所有节点，不传递该参数的话，则会在迁移过程中提示用户输入
                 --cluster-to &lt;arg&gt;            #slot需要迁移的目的节点的node id，目的节点只能填写一个，不传递该参数的话，则会在迁移过程中提示用户输入
                 --cluster-slots &lt;arg&gt;         #需要迁移的slot数量，不传递该参数的话，则会在迁移过程中提示用户输入。
                 --cluster-yes                 #指定迁移时的确认输入
                 --cluster-timeout &lt;arg&gt;       #设置migrate命令的超时时间
                 --cluster-pipeline &lt;arg&gt;      #定义cluster getkeysinslot命令一次取出的key数量，不传的话使用默认值为10
                 --cluster-replace             #是否直接replace到目标节点
  rebalance      <span class="token property">host</span><span class="token punctuation">:</span>port                                      #指定集群的任意一节点进行平衡集群节点slot数量 
                 --cluster-weight &lt;node1=w1...nodeN=wN&gt;         #指定集群节点的权重
                 --cluster-use-empty-masters                    #设置可以让没有分配slot的主节点参与，默认不允许
                 --cluster-timeout &lt;arg&gt;                        #设置migrate命令的超时时间
                 --cluster-simulate                             #模拟rebalance操作，不会真正执行迁移操作
                 --cluster-pipeline &lt;arg&gt;                       #定义cluster getkeysinslot命令一次取出的key数量，默认值为10
                 --cluster-threshold &lt;arg&gt;                      #迁移的slot阈值超过threshold，执行rebalance操作
                 --cluster-replace                              #是否直接replace到目标节点
  add-node       <span class="token property">new_host</span><span class="token punctuation">:</span>new_port <span class="token property">existing_host</span><span class="token punctuation">:</span>existing_port  #添加节点，把新节点加入到指定的集群，默认添加主节点
                 --cluster-slave                                #新节点作为从节点，默认随机一个主节点
                 --cluster-master-id &lt;arg&gt;                      #给新节点指定主节点
  del-node       <span class="token property">host</span><span class="token punctuation">:</span>port node_id                              #删除给定的一个节点，成功后关闭该节点服务
  call           <span class="token property">host</span><span class="token punctuation">:</span>port command arg arg .. arg               #在集群的所有节点执行相关命令
  set-timeout    <span class="token property">host</span><span class="token punctuation">:</span>port milliseconds                         #设置cluster-node-timeout
  import         <span class="token property">host</span><span class="token punctuation">:</span>port                                      #将外部redis数据导入集群
                 --cluster-from &lt;arg&gt;                           #将指定实例的数据导入到集群
                 --cluster-copy                                 #migrate时指定copy
                 --cluster-replace                              #migrate时指定replace
  help           

For check<span class="token punctuation">,</span> fix<span class="token punctuation">,</span> reshard<span class="token punctuation">,</span> del-node<span class="token punctuation">,</span> set-timeout you can specify the host and port of any working node in the cluster.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h3 id="_3-节点通信"><a href="#_3-节点通信" class="header-anchor">#</a> 3. 节点通信</h3> <h4 id="_3-1-通信流程"><a href="#_3-1-通信流程" class="header-anchor">#</a> 3.1 通信流程</h4> <p>在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和P2P方式。Redis集群采用P2P的Gossip（流言）协议，Gossip协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。</p> <p>通信过程说明：</p> <ul><li>集群中的每个节点都会单独开辟一个TCP通道，用于节点之间彼此通信，通信端口号在基础端口上加10000.</li> <li>每个节点在固定周期内通过特定规则选择几个节点发送ping消息。</li> <li>接收到ping消息的节点用pong消息作为响应。</li></ul> <h4 id="_3-2-gossip消息"><a href="#_3-2-gossip消息" class="header-anchor">#</a> 3.2 Gossip消息</h4> <p>Gossip协议的主要职责就是信息交换，信息交换的载体就是节点彼此发送的Gossip消息。</p> <p>常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息等。</p> <ul><li>meet：消息发送者通知接收者加入到当前集群。</li> <li>ping：用于检测节点是否在线和交换彼此状态信息。</li> <li>pong：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。</li> <li>fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul> <p>所有的消息格式划分为：消息头和消息体。</p> <p>消息头包含发送节点自身状态数据。结构如下：</p> <p><img src="C:%5CUsers%5C12272%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210122162527523.png" alt="image-20210122162527523"></p> <p>集群内所有的消息都采用相同的消息头结构clusterMsg，它包含了发送节点关键信息，如节点id、槽映射、节点标识（主从角色，是否下线）等。消息体在Redis内部采用clusterMsgData结构声明。</p> <p><img src="C:%5CUsers%5C12272%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210122164007024.png" alt="image-20210122164007024"></p> <p>消息体clusterMsgData定义发送消息的数据，其中ping、meet、pong都采用cluster MsgDataGossip数组作为消息体数据，实际消息类型使用消息头的type属性区分。</p> <p><img src="C:%5CUsers%5C12272%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20210122164312999.png" alt="image-20210122164312999"></p> <h4 id="_3-3-节点选择"><a href="#_3-3-节点选择" class="header-anchor">#</a> 3.3 节点选择</h4> <p>Redis集群内节点通信采用固定频率（定时任务每秒执行十次）。</p> <p>Redis集群的Gossip协议需要兼顾信息交换实时性和成本开销。</p> <ul><li>选择发送消息的节点数量：每秒会随机选5个节点找出最久没有通信的节点发送ping消息；如果发现节点最近一次接受pong消息的时间大于cluster_node_timeout/2，则立刻发送ping消息。</li> <li>消息数据量：每个ping消息的数据量体现在消息头和消息体中，其中消息头主要占用空间的字段是myslots[CLUSTER_SLOTS/8]，占用2KB，这块空间占用相对固定。消息体会携带一定数量的其他节点信息用于信息交换。</li></ul> <h3 id="_4-集群伸缩"><a href="#_4-集群伸缩" class="header-anchor">#</a> 4. 集群伸缩</h3> <h4 id="_4-1-伸缩原理"><a href="#_4-1-伸缩原理" class="header-anchor">#</a> 4.1 伸缩原理</h4> <p>Redis集群提供了灵活的节点扩容和收缩方案。在不影响集群对外服务的情况下，可以为集群添加节点进行扩容也可以下线部分节点进行缩容。</p> <p>如果希望加入1个节点实现集群扩容时，需要通过相关命令把一部分槽和数据迁移给新节点，这样每个节点负责的槽和数据相比之前变少了从而达到了集群扩容的目的。</p> <p>集群的水平伸缩的上层原理：集群伸缩=槽和数据在节点之间的移动。</p> <h4 id="_4-2-扩容集群"><a href="#_4-2-扩容集群" class="header-anchor">#</a> 4.2 扩容集群</h4> <p>扩容是分布式存储最常见的需求。</p> <ul><li><p>准备新节点：</p> <ul><li>redis-server xxx.conf</li></ul></li> <li><p>加入集群：</p> <ul><li>cluster meet {ip} {port}</li></ul></li> <li><p>迁移槽和数据：</p> <ul><li><p>槽在迁移过程中集群可以正常提供读写服务，迁移过程是集群扩容最核心的环节。</p></li> <li><p>槽迁移计划：槽是Redis集群管理数据的基本单位，首先需要为新节点制定槽的迁移计划，确定原有节点的哪些槽需要迁移到新节点。槽迁移计划确定以后，开始逐个把槽内数据从源节点迁移到目标节点。</p></li> <li><p>迁移数据：数据迁移过程是逐个槽进行的。流程说明：</p> <ul><li><p>对目标节点发送cluster setslot {slot} importing {sourceNodeId}命令，让目标节点准备导入槽的数据。</p></li> <li><p>对源节点发送cluster setslot {slot} migrating {targetNodeId}命令，让源节点准备迁出槽的数据。</p></li> <li><p>源节点循环执行cluster getkyesinslot {slot} {count}命令，获取count个属于槽{slot}的键。</p></li> <li><p>在源节点上执行migrate {targetIp} {targetPort} &quot;&quot; 0 {timeout} keys {keys ...}命令，把获取的键通过流水线（pipeline）机制批量迁移到目标节点，批量迁移版本的migrate命令在Redis3.0.6以上版本提供，之前的migrate命令只能单个键迁移。对于大量key 的场景，批量键迁移将极大降低节点之间的网络IP次数。</p></li> <li><p>重复执行步骤 3、4 直到槽下所有的键值数据迁移到目标节点。</p></li> <li><p>向集群内所有主节点发送 cluster setslot {slot} node {targetNodeId}命令，通知槽分配给目标节点。为了保证槽节点映射变更及时传播，需要遍历发送给所有主节点更新被迁移的槽指向新节点。</p></li> <li><p>使用伪代码模拟迁移过程：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">moveSlot</span><span class="token punctuation">(</span><span class="token class-name">RedisNode</span> source<span class="token punctuation">,</span><span class="token class-name">RedisNode</span> target<span class="token punctuation">,</span><span class="token class-name">Object</span> slot<span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">// 目标节点准备导入槽</span>
    target<span class="token punctuation">.</span><span class="token function">cluster</span><span class="token punctuation">(</span><span class="token string">&quot;setslot&quot;</span><span class="token punctuation">,</span>slot<span class="token punctuation">,</span><span class="token string">&quot;importing&quot;</span><span class="token punctuation">,</span>source<span class="token punctuation">.</span>nodeId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 目标节点准备迁出槽</span>
    source<span class="token punctuation">.</span><span class="token function">cluster</span><span class="token punctuation">(</span><span class="token string">&quot;setslot&quot;</span><span class="token punctuation">,</span>slot<span class="token punctuation">,</span><span class="token string">&quot;migrating&quot;</span><span class="token punctuation">,</span>target<span class="token punctuation">.</span>nodeId<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//批量从源节点获取键</span>
        <span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> keys <span class="token operator">=</span> source<span class="token punctuation">.</span><span class="token function">cluster</span><span class="token punctuation">(</span><span class="token string">&quot;getkeysinslot&quot;</span><span class="token punctuation">,</span>slot<span class="token punctuation">,</span>pipeline_size<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>keys<span class="token punctuation">.</span><span class="token function">lenght</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">// 键列表为空，退出循环</span>
            <span class="token keyword">break</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token comment">// 批量迁移键到目标节点</span>
        source<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">&quot;migrate&quot;</span><span class="token punctuation">,</span>target<span class="token punctuation">.</span>host<span class="token punctuation">,</span>target<span class="token punctuation">.</span>port<span class="token punctuation">,</span><span class="token string">&quot;&quot;</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>timeout<span class="token punctuation">,</span><span class="token string">&quot;keys&quot;</span><span class="token punctuation">,</span>keys<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 向集群所有主节点通知槽被分配给目标节点</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token class-name">RedisNode</span> node<span class="token operator">:</span> nodes<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>flag <span class="token operator">==</span> <span class="token string">&quot;slave&quot;</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">continue</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            node<span class="token punctuation">.</span><span class="token function">cluster</span><span class="token punctuation">(</span><span class="token string">&quot;setslot&quot;</span><span class="token punctuation">,</span>slot<span class="token punctuation">,</span><span class="token string">&quot;node&quot;</span><span class="token punctuation">,</span>target<span class="token punctuation">.</span>nodeId<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><ul><li>redis-cli --cluster reshard命令简化了数据迁移的工作量。</li></ul></li></ul></li></ul></li></ul> <h4 id="_4-3-收缩集群"><a href="#_4-3-收缩集群" class="header-anchor">#</a> 4.3 收缩集群</h4> <p>收缩集群意味着缩减规模，需要从现有集群中安全下线部分节点。</p> <p>流程说明：</p> <ul><li>首先需要确定下线节点是否有负责的槽，如果是，需要把槽迁移到其他节点，保证节点下线后整个集群槽节点映射的完整性。</li> <li>当下线节点不再负责槽或者本身是从节点时，就可以通知集群内其他节点忘记下线节点，当所有的节点忘记该节点后可以正常关闭。
<ul><li>下线迁移槽：下线节点需要把自己负责的槽迁移到其他节点，原理与之前节点扩容的迁移槽过程一致。redis-cli --cluster reshard。
<ul><li>忘记节点：由于集群内的节点不停地通过Gossip消息彼此交换节点状态，因此需要通过一种健壮的机制让集群内所有节点忘记下线的节点。也就是说让其他节点不再与要下线节点进行Gossip消息交换。Redis提供了cluster forget {downNodeId}命令实现该功能。当节点接收到cluster forget {downNodeId}命令后，会把nodeId指定的节点加入到禁用列表中，在禁用列表内的节点不再发送Gossip消息。禁用列表有效期是60秒，因此有60秒的时间让集群内的所有节点忘记下线节点。</li> <li>删除节点：线上操作不建议使用cluster forget命令下线节点，需要跟大量节点命令交互，建议使用 redis-cli del-node {host:port} {downNodeId} 删除下线的节点。</li></ul></li></ul></li></ul> <h3 id="_5-请求路由"><a href="#_5-请求路由" class="header-anchor">#</a> 5. 请求路由</h3> <h4 id="_5-1-请求重定向"><a href="#_5-1-请求重定向" class="header-anchor">#</a> 5.1 请求重定向</h4> <p>在集群模式下，Redis接收任何键相关命令首先计算键对应的槽，再根据槽找出所对应的节点，如果节点是自身，则处理键命令；否则回复MOVED重定向错误，通知客户端请求正确的节点。这个过程称为MOVED重定向。</p> <p>使用redis-cli命令时，可以加入-c参数支持自动重定向，简化手动发起重定向操作。</p> <p>但是这样会额外增加IO开销，这不是Redis集群高效的使用方式。</p> <p>正因为如此通常集群客户端都采用另一种实现：Smart（智能）客户端。</p> <h4 id="_5-2-smark客户端"><a href="#_5-2-smark客户端" class="header-anchor">#</a> 5.2 Smark客户端</h4> <h5 id="_5-2-1-smart客户端原理"><a href="#_5-2-1-smart客户端原理" class="header-anchor">#</a> 5.2.1 smart客户端原理</h5> <p>Redis客户端都采用Smart客户端支持集群协议。Smart客户端通过在内部维护slot-&gt;node的映射关系，本地就可实现键到节点的查找，从而保证IO效率的最大化，而MOVED重定向负责协助Smart客户端更新slot-&gt;node映射。</p> <p>Jedis就是Smart客户端。</p> <ul><li>首先在JedisCluster初始化时会选择一个运行节点，初始化槽和节点映射关系，使用cluster slots命令完成。</li> <li>Jedis Cluster解析cluster slots结果缓存在本地，并为每个节点创建唯一的JedisPool连接池。映射关系在JedisClusterInfoCache类中。</li> <li>Jedis Cluster执行键命令流程：
<ul><li>计算slot并根据slots缓存获取目标节点连接，发送命令。</li> <li>如果出现连接错误，使用随机连接重新执行键命令，每次命令重试对redi-rections（重试次数）减1.</li> <li>捕获到MOVED重定向错误，使用cluster slots命令更新slots缓存（renewSlotCache方法）。</li> <li>重复执行1、3步，直到命令执行成功，或者当redi-rections&lt;=0时，抛出Jedis ClusterMaxRedirectionsException异常。</li></ul></li> <li>建议升级到Jedis2.8.2以上版本防止cluster slots风暴和写锁阻塞问题。</li></ul> <h5 id="_5-2-2-smart客户端-jediscluster"><a href="#_5-2-2-smart客户端-jediscluster" class="header-anchor">#</a> 5.2.2 Smart客户端——JedisCluster</h5> <div class="language-java line-numbers-mode"><pre class="language-java"><code>    <span class="token keyword">public</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span><span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span> jedisClusterNode<span class="token punctuation">,</span> <span class="token keyword">int</span> connectionTimeout<span class="token punctuation">,</span> <span class="token keyword">int</span> soTimeout<span class="token punctuation">,</span> <span class="token keyword">int</span> maxAttempts<span class="token punctuation">,</span> <span class="token class-name">GenericObjectPoolConfig</span> poolConfig<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>定义：Jedis为Redis Cluster提供了Smart客户端，对应的类是JedisCluster。
<ul><li>Set<HostAndPort> jedisClusterNode：所有Redis Cluster节点信息（也可以是一部分，因为客户端可以通过cluster slots自动发现）。</HostAndPort></li> <li>int connectionTimeout：连接超时。</li> <li>int soTimeout：读写超时。</li> <li>int maxAttempts：重试次数。</li> <li>GenericObjectPoolConfig poolConfig：连接池参数，JedisCluster会为Redis Cluster的每个节点创建连接池。</li></ul></li></ul> <div class="language-java line-numbers-mode"><pre class="language-java"><code>        <span class="token comment">// 初始化所有节点</span>
        <span class="token class-name">Set</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">HostAndPort</span><span class="token punctuation">&gt;</span></span> jedisClusterNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6378</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6380</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6381</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6382</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6383</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        jedisClusterNode<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">HostAndPort</span><span class="token punctuation">(</span><span class="token string">&quot;120.24.59.47&quot;</span><span class="token punctuation">,</span><span class="token number">6384</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化common-pool连接池，并设置相关参数</span>
        <span class="token class-name">GenericObjectPoolConfig</span> poolConfig <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GenericObjectPoolConfig</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">// 初始化JedisCluster</span>
        <span class="token class-name">JedisCluster</span> jedisCluster <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">JedisCluster</span><span class="token punctuation">(</span>jedisClusterNode<span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span>poolConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>

        jedisCluster<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">,</span><span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>jedisCluster<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><ul><li><p>对于JedisCluster的使用需要注意以下几点：</p> <ul><li>JedisCluster包含了所有节点的连接池（JedisPool），所以建议JedisCluster使用单例。</li> <li>JedisCluster每次操作完成后，不需要管理连接池的借还，它在内部已经完成。</li> <li>JedisCluster一般不要执行close()操作，它会将所有JedisPool执行destroy操作。</li></ul></li> <li><p>多节点命令和操作：Redis Cluster虽然提供了分布式的特性，但是有些命令或者操作，诸如keys、flushall、删除指定模式的键，需要遍历所有节点才可以完成。</p></li> <li><p>批量操作的方法：Redis Cluster中，由于key分布到各个节点上，会造成无法实现mget、mset等功能。只能分别对每个节点对应的子key列表执行mget或者pipeline操作。</p></li> <li><p>使用Lua、事务等特性的方法：Lua和事务需要所操作的key，必须在一个节点上，不过Redis Cluster提供了hashtag，如果确实要使用Lua或者事务，可以将所要操作的key使用一个hashtag。</p></li></ul> <h4 id="_5-3-ask重定向"><a href="#_5-3-ask重定向" class="header-anchor">#</a> 5.3 ASK重定向</h4> <h5 id="_5-3-1-客户端ask重定向流程"><a href="#_5-3-1-客户端ask重定向流程" class="header-anchor">#</a> 5.3.1 客户端ASK重定向流程</h5> <p>Redis集群支持在线迁移槽（slot）和数据来完成水平伸缩，当slot对应的数据从源节点到目标节点迁移过程中，客户端需要做到智能识别，保证键命令可正常执行。例如当一个slot数据从源节点迁移到目标节点时，期间可能出现一部分数据在源节点，而另一部分在目标节点。</p> <p>当出现这种状况的时候，客户端键命令执行流程将发生变化：</p> <ul><li>客户端根据本地slots缓存发送命令到源节点，如果存在键对象则直接执行并返回结果给客户端。</li> <li>如果键对象不存在，则可能存在于目标节点，这时源节点会回复ASK重定向异常。</li> <li>客户端从ASK重定向异常提取出目标节点信息，发送asking命令到目标节点打开客户端连接标识，再执行键命令。如果存在则执行，不存在则返回不存在信息。</li> <li>ASK与MOVED虽然都是对客户端的重定向控制，但是有着本质区别。ASK重定向说明集群正在执行slot数据迁移，客户端无法知道什么时候迁移完成，因此只能是临时性的重定向，客户端不会更新slots缓存。但是，MOVED重定向说明键对应的槽已经明确指定到新的节点，因此需要更新slots缓存。</li></ul> <p>当在集群环境下使用mget、mset等批量操作时，slot迁移数据期间由于键列表无法保证在同一节点，会导致大量错误。</p> <ul><li>Pipeline严格按照键发送的顺序返回结果，即使出现异常也是如此。</li> <li>理解ASK重定向之后，可以手动发起ASK流程保证Pipeline的结果正确性。</li></ul> <p>综上所述，使用smart客户端批量操作集群时，需要评估mget/mset、Pipeline等方式在slot迁移场景下的容错性，防止集群迁移造成大量错误和数据丢失的情况。</p> <p>集群环境下对于使用批量操作的场景，建议优先使用Pipeline方式，在客户端实现对ASK重定向的处理，这样既可以受益于批量操作的IO优化，又可以兼容slot迁移场景。</p> <h3 id="_6-故障转移"><a href="#_6-故障转移" class="header-anchor">#</a> 6. 故障转移</h3> <p>Redis集群自身实现了高可用。高可用首先需要解决集群部分失败的场景：当集群内少量节点出现故障时通过自动故障转移保证集群可以正常对外提供服务。</p> <h4 id="_6-1-故障发现"><a href="#_6-1-故障发现" class="header-anchor">#</a> 6.1 故障发现</h4> <p>故障发现是通过消息传播机制实现的，主要环节包括：主观下线（pfail）和客官下线（fail）。</p> <ul><li>主观下线：某个节点认为另一个节点不可用。</li> <li>客观下线：标记一个节点真正的下线。</li></ul> <p>通过Gossip消息传播，集群内节点不断收集到故障节点的下线报告，当半数以上持有槽的主节点都标记某个节点是主观下线时，触发客观下线流程。</p> <p>如果在cluster-node-time*2时间内无法收集到一半以上槽节点的下线报告，那么之前的下线报告将会过期，也就是说主观下线上报的速度追赶不上下线报告过期的速度，那么故障节点将永远无法被标记为客观下线从而导致故障转移失败。因此不建议将cluster-node-time设置得过小。</p> <h4 id="_6-2-故障恢复"><a href="#_6-2-故障恢复" class="header-anchor">#</a> 6.2 故障恢复</h4> <p>故障节点变为客观下线后，如果下线节点是持有槽的主节点则需要在它的从节点中选出一个替换它，从而保证集群的高可用。下线主节点的所有从节点承担故障恢复的义务，当从节点通过内部定时任务发现自身复制的主节点进入客观下线时，将会触发故障恢复流程。</p> <ul><li><p>资格检查：每个从节点都要检查最后与主节点断线时间，判断是否有资格替换故障的主节点。如果从节点与主节点断线时间超过cluster-node-time*cluster-slave-validaty-factor，则当前从节点不具备故障转移资格。参数cluster-slave-validaty-factor用于从节点的有效因子，默认为10。</p></li> <li><p>准备选举时间：当从节点符合故障转移资格后，更新触发故障选举的时间，只有到达该时间后才能执行后续流程。这里之所以采用延迟触发机制，主要是通过对多个节点使用不同的延迟选举时间来支持优先级问题。复制偏移量越大说明从节点延迟越低，那么它应该具有更高的优先级来替换故障主节点。</p></li> <li><p>发起选举：当从节点定时任务检测到达故障选举时间到达后，发起选举流程如下：</p> <ul><li>更新配置纪元。</li> <li>配置节点的应用场景有：
<ul><li>新节点加入。</li> <li>槽节点映射冲突检测。</li> <li>从节点投票选举冲突检测。</li></ul></li></ul></li> <li><p>选举投票：只有持有槽的主节点才会处理故障选举消息（FAILOVER_AUTH_REQUEST），因为每个持有槽的节点在一个配置纪元内都有唯一的一张选票，当接到第一个请求投票的从节点消息时回复FAILOVER_AUTH_ACK消息作为投票，</p></li> <li><p>替换主节点：当从节点收集到足够的选票之后，触发替换主节点操作：</p> <ul><li>当前从节点取消复制变为主节点。</li> <li>执行clusterDelSlot操作撤销故障主节点负责的槽，并执行clusterAddSlot把这些槽委派给自己。</li> <li>向集群广播自己的pong消息，通知集群内所有的节点当前从节点变为主节点并接管了故障主节点的槽信息。</li></ul></li></ul> <h3 id="_7-集群运维"><a href="#_7-集群运维" class="header-anchor">#</a> 7. 集群运维</h3> <h4 id="_7-1-集群完整性"><a href="#_7-1-集群完整性" class="header-anchor">#</a> 7.1 集群完整性</h4> <p>为了保证集群完整性，默认情况下当集群16384个槽任何一个没有指派到节点时整个集群不可用。然而这样当持有槽的主节点下线时，集群是不可用状态，这样是无法容忍的。建议将cluster-require-full-coverage配置为no，当主节点故障时只影响它负责槽的相关命令执行，不会影响其他主节点的可用性。</p> <h4 id="_7-2-宽带消耗"><a href="#_7-2-宽带消耗" class="header-anchor">#</a> 7.2 宽带消耗</h4> <p>集群内Gossip消息通信本身会消耗带宽，官方建议集群最大规模在1000以内。</p> <p>集群带宽消耗主要分为：读写命令消耗+Gossip消息消耗。因此搭建Redis集群时需要根据业务数据规模和消息通信成本做出合理规划：</p> <ul><li>在满足业务需要的情况下尽量避免大集群。</li> <li>适度提高cluster-node-timeout降低消息发送频率，同时cluster-node-timeout还影响故障转移的速度，因此需要根据自身业务场景兼顾二者的平衡。</li> <li>如果条件允许集群尽量均匀部署在更多机器上。</li></ul> <h4 id="_7-3-pub-sub广播问题"><a href="#_7-3-pub-sub广播问题" class="header-anchor">#</a> 7.3 Pub/Sub广播问题</h4> <p>在集群模式下内部实现对所有的publish命令都会向所有的节点进行广播，造成每条publish数据都会在集群内所有节点传播一次，加重带宽负担。针对这种情况，建议使用sentinel结构专门用于Pub/Sub功能，从而规避这一问题。</p> <h4 id="_7-4-集群倾斜"><a href="#_7-4-集群倾斜" class="header-anchor">#</a> 7.4 集群倾斜</h4> <ul><li>数据倾斜：
<ul><li>节点和槽分配严重不均。</li> <li>不同槽对应键数量差异过大。</li> <li>集合对象包含大量元素。</li> <li>内存相关配置不一致。</li></ul></li> <li>请求倾斜：
<ul><li>常出现在热点键场景。避免方式如下：
<ul><li>合理设计键，热度大集合对象做拆分或使用hmget替代hgetall避免整体读取。</li> <li>不要使用热键hash_tag，避免映射到同一槽。</li> <li>对于一致性要求不高的场景，客户端可使用本地缓存减少热键调用。</li></ul></li></ul></li></ul> <h4 id="_7-5-集群读写分离"><a href="#_7-5-集群读写分离" class="header-anchor">#</a> 7.5 集群读写分离</h4> <ul><li>只读连接：集群模式下从节点不接受任何读写请求，发送过来的键命令会重定向到负责槽的主节点上（其中包括它的主节点）。当需要使用从节点分担主节点读压力时，可以使用readonly命令打开客户端连接只读状态。之前的复制配置slave-read-only在集群模式下无效。当开启只读状态时，从节点接收读命令处理流程变为：如果对应的槽属于自己正在复制的主节点则执行读命令，否则返回重定向信息。readonly命令是连接级别生效，因此每次新建连接时都需要执行readonly开启只读状态。执行readwrite命令可以关闭连接只读状态。</li> <li>读写分离：集群模式下的读写分离，同样会遇到：复制延迟，读取过期数据，从节点故障等问题。针对从节点故障问题，客户端需要维护可用从节点列表，集群提供了cluster slaves {nodeId}命令，返回nodeId对应主节点下所有从节点信息，数据格式通cluster nodes。解析以上从节点列表信息，排除fail状态节点，这样客户端对从节点的故障判定可以委托给集群处理，简化维护可用从节点列表难度。</li></ul> <p>集群模式下读写分离涉及对客户端修改如下：</p> <ul><li>维护每个主节点可用从节点列表。</li> <li>针对读命令维护请求节点路由。</li> <li>从节点新建连接开启readonly状态。</li></ul> <p>集群模式下读写分离成本比较高，可以直接扩展主节点数量提高集群性能，一般不建议集群模式下做读写分离。</p> <h4 id="_7-6-数据迁移"><a href="#_7-6-数据迁移" class="header-anchor">#</a> 7.6 数据迁移</h4> <p>redis-migrate-tool工具可满足大多数Redis迁移需求：</p> <ul><li>支持单机、Twemproxy、Redis Cluster、RDB/AOF等多种类型的数据迁移。</li> <li>工具模拟成从节点基于复制流迁移数据，从而支持在线迁移数据，业务方不需要停写。</li> <li>采用多线程加速数据迁移过程且提供数据校验和查看迁移状态等功能。</li></ul> <h3 id="_8-总结"><a href="#_8-总结" class="header-anchor">#</a> 8. 总结</h3> <ul><li>Redis集群数据分区规则采用虚拟槽方式，所有的键映射到16384个槽中，每个节点负责一部分槽和相关数据，实现数据和请求的负载均衡。</li> <li>搭建集群划分三个步骤：准备节点，节点握手，分配槽。可以使用redis-cli --cluster create命令快速搭建集群。</li> <li>集群内部节点通信采用Gossip协议彼此发送消息，消息类型分为：ping消息、pong消息、meet消息、fail消息等。节点定期不断发送和接受ping/pong消息来维护更新集群的状态。消息内容包括节点自身数据和部分其他节点的状态数据。</li> <li>集群伸缩通过在节点之间移动槽和相关数据实现。扩容时根据槽迁移计划把槽从源节点迁移到目标节点，源节点负责的槽相比之前变少从而达到集群扩容的目的，收缩时如果下线的节点有负责的槽需要迁移到其他节点，再通过cluster forget命令让集群内其他节点忘记被下线节点。</li> <li>使用Smart客户端操作集群达到通信效率最大化，客户端内部负责计算维护键-&gt;槽-&gt;节点的映射，用于快速定位键命令到目标节点。集群协议通过Smart客户端全面高效的支持需要一个过程，用户在选择Smart客户端时建议review下集群交互代码如：异常判定和重试逻辑，更新槽的并发控制等。节点接收到键命令时会判断相关的槽是否由自身节点负责，如果不是则返回重定向信息。重定向分为MOVED和ASK，ASK说明集群正在进行槽数据迁移，客户端只在本次请求中做临时重定向，不会更新本地槽缓存。MOVED重定向说明槽已经明确分派到另一个节点，客户端需要更新槽节点缓存。</li> <li>集群自动故障转移过程分为故障发现和故障恢复。节点下线分为主观下线和客观下线，当超过半数主节点认为故障节点为主观下线时标记它为客观下线状态。从节点负责对客观下线的主节点触发故障恢复流程，保证集群的可用性。</li> <li>开发和运维集群过程中常见问题包括：超大规模集群带宽消耗，pub/sub广播问题，集群节点倾斜问题，手动故障转移，在线迁移数据等。</li></ul> <h2 id="第十一章-缓存设计"><a href="#第十一章-缓存设计" class="header-anchor">#</a> 第十一章 缓存设计</h2> <h3 id="_1-缓存的收益和成"><a href="#_1-缓存的收益和成" class="header-anchor">#</a> 1. 缓存的收益和成</h3> <p><strong>收益</strong></p> <ul><li>加速读写：缓存基于内存。</li> <li>降低后端负载：帮助后端减少访问量和复杂计算，在很大程度降低了后端的负载。</li></ul> <p><strong>成本</strong></p> <ul><li>数据不一致性：缓存层和存储层的数据存在着一定时间窗口的不一致性，时间窗口跟更新策略有关。</li> <li>代码维护成本：加入缓存后，需要同时处理缓存层和存储层的逻辑，增大了开发者维护代码的成本。</li> <li>运维成本：以Redis Cluster为例，加入后无形中增加了运维成本。</li></ul> <p><strong>使用场景</strong></p> <ul><li>开销大的复杂计算。</li> <li>加速请求响应。</li></ul> <h3 id="_2-缓存更新策略"><a href="#_2-缓存更新策略" class="header-anchor">#</a> 2. 缓存更新策略</h3> <h4 id="_2-1-lru-lfu-fifo算法剔除"><a href="#_2-1-lru-lfu-fifo算法剔除" class="header-anchor">#</a> 2.1 LRU/LFU/FIFO算法剔除</h4> <ul><li><p>使用场景：剔除算法通常用于缓存使用量超过了预设的最大值时候，如何对现有的数据进行剔除。例如Redis使用maxmemory-policy这个配置作为内存最大值后对于数据的剔除策略。</p></li> <li><p>一致性：要清理哪些数据是由具体算法决定，开发人员只能决定使用哪种算法，所以数据的一致性是最差的。</p></li> <li><p>维护成本：算法不需要开发人员自己实现，通常只需要配置最大maxmemory和对应的策略即可。</p></li></ul> <h4 id="_2-2-超时剔除"><a href="#_2-2-超时剔除" class="header-anchor">#</a> 2.2 超时剔除</h4> <ul><li>使用场景：超时剔除通过给缓存数据设置过期时间，让其在过期时间后自动删除，例如Redis提供的expire命令，例如expire命令。实时性要求不高的可以用。例如视频。</li> <li>一致性：一段时间窗口内存在一致性问题，即缓存数据和真实数据源的数据不一致。</li> <li>维护成本：维护成本不是很高，只需设置expire过期时间即可，当然前提是应用方允许这段时间可能发生的数据不一致。</li></ul> <h4 id="_2-3-主动更新"><a href="#_2-3-主动更新" class="header-anchor">#</a> 2.3 主动更新</h4> <ul><li>使用场景：应用方对于数据的一致性要求高，需要在真实数据更新后，理解更新缓存数据。</li> <li>一致性：一致性最高，但如果主动更新发生了问题，那么这条数据很可能很长时间不会更新，所以建议结合超时剔除一起使用效果会更好。</li> <li>维护成本：维护成本会更高，开发者需要自己来完成更新，并保证更新操作的正确性。</li></ul> <h4 id="_2-4-最佳实践"><a href="#_2-4-最佳实践" class="header-anchor">#</a> 2.4 最佳实践</h4> <table><thead><tr><th style="text-align:center;">策略</th> <th style="text-align:center;">一致性</th> <th style="text-align:center;">维护成本</th></tr></thead> <tbody><tr><td style="text-align:center;">LRU/LRF/FIFO算法剔除</td> <td style="text-align:center;">最差</td> <td style="text-align:center;">低</td></tr> <tr><td style="text-align:center;">超时剔除</td> <td style="text-align:center;">较差</td> <td style="text-align:center;">较低</td></tr> <tr><td style="text-align:center;">主动更新</td> <td style="text-align:center;">强</td> <td style="text-align:center;">高</td></tr></tbody></table> <p>有两个建议：</p> <ul><li>低一致性业务建议配置最大内存和淘汰策略的方式使用。</li> <li>高一致性业务可以结合使用超时剔除和主动更新，这样即使主动更新出了问题，也能保证数据过期时间后删除脏数据。</li></ul> <h3 id="_3-缓存粒度控制"><a href="#_3-缓存粒度控制" class="header-anchor">#</a> 3. 缓存粒度控制</h3> <p>缓存粒度问题，究竟是缓存全部属性还是只缓存部分重要属性呢？</p> <ul><li>通用性：缓存全部数据更加通用，但实际上看，很长时间内应用只需要几个重要的属性。</li> <li>空间占用：缓存全部数据会造成内存浪费、带宽消耗更大、数据的序列化和反序列化的CPU开销大。</li> <li>代码维护：全部数据的优势更明显，部分数据一旦要加新字段需要修改业务代码，而且修改后通常还需要刷新缓存数据。</li></ul> <table><thead><tr><th>数据类型</th> <th>通用性</th> <th>空间占用（内存空间+网络带宽）</th> <th>代码维护</th></tr></thead> <tbody><tr><td>全部数据</td> <td>高</td> <td>大</td> <td>简单</td></tr> <tr><td>部分数据</td> <td>低</td> <td>小</td> <td>较为复杂</td></tr></tbody></table> <h3 id="_4-穿透优化"><a href="#_4-穿透优化" class="header-anchor">#</a> 4. 穿透优化</h3> <p>缓存穿透是指查询一个根本不存在的数据，缓存层和存储层都不会命中，通常出于容错的考虑，如果从存储层查不到数据则不写入缓存层。</p> <p>缓存穿透将导致不存在的数据每次请求都要到存储层去查询，失去了缓存保护后端存储的意义。</p> <p>造成缓存穿透的基本原因有两个：</p> <ul><li>第一，自身业务代码或者数据出现问题。</li> <li>第二，一些恶意攻击、爬虫等造成大量空命中。</li></ul> <p>解决缓存穿透问题。</p> <h4 id="_4-1-缓存空对象"><a href="#_4-1-缓存空对象" class="header-anchor">#</a> 4.1 缓存空对象</h4> <p>存储层不命中后，仍然将空对象保留到缓存层中，之后再访问这个数据将会从缓存中获取。</p> <h4 id="_4-2-布隆过滤器拦截"><a href="#_4-2-布隆过滤器拦截" class="header-anchor">#</a> 4.2 布隆过滤器拦截</h4> <p>在访问缓存层和存储层之前，将存在的key用布隆过滤器提前保存起来，做第一层拦截。例如：一个推荐系统有4亿个用户id，每个小时算法工程师会根据每个用户之前历史行为计算出推荐数据放到存储层中，但是最新的用户由于没有历史行为，就会发生缓存穿透的行为，为此可以将所有推荐数据的用户做成布隆过滤器。如果布隆过滤器认为该用户id不存在，那么就不会访问存储层，在一定程度保护了存储层。</p> <p>可以利用Bitmaps实现布隆过滤器。</p> <p>这种方法用于数据命中不高、数据相对固定、实时性低（通常是数据集较大）的应用场景，代码维护较为复杂，但是缓存空间占用少。</p> <h4 id="_4-3-两种方案对比"><a href="#_4-3-两种方案对比" class="header-anchor">#</a> 4.3 两种方案对比</h4> <table><thead><tr><th style="text-align:center;">解决缓存穿透</th> <th style="text-align:center;">使用场景</th> <th style="text-align:center;">维护成本</th></tr></thead> <tbody><tr><td style="text-align:center;">缓存空对象</td> <td style="text-align:center;">数据命中不高、数据频繁变化实时性高</td> <td style="text-align:center;">代码维护简单、需要过多的缓存空间、数据不一致</td></tr> <tr><td style="text-align:center;">布隆过滤器</td> <td style="text-align:center;">数据命中不高、数据相对固定实时性低</td> <td style="text-align:center;">代码维护复杂、缓存空间占用少</td></tr></tbody></table> <h3 id="_5-无底洞优化"><a href="#_5-无底洞优化" class="header-anchor">#</a> 5. 无底洞优化</h3> <p>2010年，Facebook的Memcache节点已经达到了3000个，承载着TB级别的缓存数据。但开发和运维人员发现了一个问题，为了满足业务要求添加了大量新Memcache节点，但是发现性能不但没有好转反而下降了，当时将这种现象称为缓存的“无底洞”现象。</p> <p>那么为什么会产生这种现象呢，通常来说添加节点使得Memcache集群 性能应该更强了，但事实并非如此。键值数据库由于通常采用哈希函数将key映射到各个节点上，造成key的分布与业务无关，但是由于数据量和访问 量的持续增长，造成需要添加大量节点做水平扩容，导致键值分布到更多的 节点上，所以无论是Memcache还是Redis的分布式，批量操作通常需要从不 同节点上获取，相比于单机批量操作只涉及一次网络操作，分布式批量操作 会涉及多次网络时间。</p> <p>无底洞问题分析：</p> <ul><li>客户端一次批量操作会涉及多次网络操作，也就意味着批量操作会随着节点的增多，耗时会不断增大。</li> <li>网络连接数变多，对节点的性能也会有一定影响。</li></ul> <p>更多的节点不代表更高的性能，所谓“无底洞”就是说投入越多不一定产出越多，但是分布式又是不可用避免的。</p> <ul><li>命令本身的优化，例如优化SQL语句等。</li> <li>减少网络通信次数。</li> <li>降低接入成本，例如客户端使用长连/连接池、NIO等。</li></ul> <p>我们假设命令、客户端连接已经为最优，重点讨论减少网络操作次数。</p> <p>以Redis批量获取n个字符串为例，有三种实现方法：</p> <ul><li>客户端n次get：n次网络+n次get命令本身。</li> <li>客户端1次pipeline get：次网络+n次get命令本身。</li> <li>客户端1次mget：1次网络+1次mget命令本身。</li></ul> <h4 id="_5-1-串行命令"><a href="#_5-1-串行命令" class="header-anchor">#</a> 5.1 串行命令</h4> <p>逐次执行n个get命令。</p> <p>操作时间=n次网络时间+n次命令时间。</p> <h4 id="_5-2-串行io"><a href="#_5-2-串行io" class="header-anchor">#</a> 5.2 串行IO</h4> <p>Smart客户端分别对每个节点执行mget或者Pipeline操作。</p> <p>操作时间=node次网络时间+n次命令时间。</p> <h4 id="_5-3-并行io"><a href="#_5-3-并行io" class="header-anchor">#</a> 5.3 并行IO</h4> <p>此方案是将串行IO方案中的最后一步改为多线程执行。</p> <p>网络次数虽然还是节点个数，但由于使用多线程网络时间变为O(1)，这种方案会增加编程的复杂度。</p> <p>操作时间=max_slow(node网络时间)+n次命令时间</p> <h4 id="_5-4-hash-tag实现"><a href="#_5-4-hash-tag实现" class="header-anchor">#</a> 5.4 hash_tag实现</h4> <p>hash_tag可以将多个key强制分配到一个节点上。</p> <p>操作时间=1次网络时间+n次命令时间。</p> <h4 id="_5-5-对比"><a href="#_5-5-对比" class="header-anchor">#</a> 5.5 对比</h4> <table><thead><tr><th style="text-align:center;">方案</th> <th style="text-align:center;">优点</th> <th style="text-align:center;">缺点</th> <th style="text-align:center;">网络IO</th></tr></thead> <tbody><tr><td style="text-align:center;">串行命令</td> <td style="text-align:center;">编程简单；如果少量keys，性能可以满足要求</td> <td style="text-align:center;">大量keys请求延迟严重</td> <td style="text-align:center;">O(keys)</td></tr> <tr><td style="text-align:center;">串行IO</td> <td style="text-align:center;">编程简单；少量节点，性能满足要求</td> <td style="text-align:center;">大量node延迟严重</td> <td style="text-align:center;">O(nodes)</td></tr> <tr><td style="text-align:center;">并行IO</td> <td style="text-align:center;">利用并行特性，延迟取决于最慢的节点</td> <td style="text-align:center;">编程复杂；由于多线程问题，问题定位可能比较难</td> <td style="text-align:center;">O(max_slow(nodes))</td></tr> <tr><td style="text-align:center;">hash_tag</td> <td style="text-align:center;">性能最高</td> <td style="text-align:center;">业务维护成本较高；容易出现数据倾斜</td> <td style="text-align:center;">O(1)</td></tr></tbody></table> <h3 id="_6-雪崩优化"><a href="#_6-雪崩优化" class="header-anchor">#</a> 6. 雪崩优化</h3> <p>什么是缓存雪崩：由于缓存层承载着大量请求，有效地保护了存储层，但是如果缓存层由于某些原因不能提供服务，于是所有的请求都会达到存储层，存储层的调用量会暴增，造成存储层也会级联宕机的情况。缓存雪崩的英文原意是stampeding herd（奔逃的野牛），指的是缓存层宕掉后，流量会像奔逃的野牛一样，打向后端存储。</p> <p>预防和解决缓存雪崩问题，可以从以下三个方面进行着手：</p> <ul><li>保证缓存层服务高可用性。Redis Sentinel和Redis Cluster。</li> <li>依赖隔离组件作为后端限流并降级。比如个性化推荐服务不可用，可以降级补充热点数据。Java依赖隔离工具Hystrix。</li> <li>提前演练。</li></ul> <h3 id="_7-热度key重建优化"><a href="#_7-热度key重建优化" class="header-anchor">#</a> 7. 热度key重建优化</h3> <p>开发人员使用“缓存+过期时间”的策略既可以加速数据读写，又保证数 据的定期更新，这种模式基本能够满足绝大部分需求。但是有两个问题如果同时出现，可能就会对应用造成致命的危害：</p> <ul><li>当前key是一个热度key，并发量非常大。</li> <li>重建缓存不能在短时间完成，可能是一个复杂计算，例如复杂的SQL、多次IO、多个依赖等。</li></ul> <p>在缓存失效的瞬间，有大量线程来重建缓存，造成后端负载加大，甚至可能会让应用崩溃。</p> <p>目标：</p> <ul><li>减少重建缓存的次数。</li> <li>数据尽可能一致。</li> <li>较少的潜在危险。</li></ul> <h4 id="_7-1-互斥锁（mutex-key）"><a href="#_7-1-互斥锁（mutex-key）" class="header-anchor">#</a> 7.1 互斥锁（mutex key）</h4> <p>此方法只运行一个线程重建缓存，其他线程等待重建缓存的线程执行完，重新从缓存获取数据即可。</p> <p>Redis的setnx就是基于互斥锁做的。</p> <h4 id="_7-2-永远不过期"><a href="#_7-2-永远不过期" class="header-anchor">#</a> 7.2 永远不过期</h4> <p>两层意思：</p> <ul><li>从缓存层面来看，确实没有设置过期时间，所以不会出现热度key过期后产生的问题，也就是“物理”不过期。</li> <li>从功能层面来看，为每个value设置一个逻辑过期时间，当发现超过逻辑过期时间后，会使用单独的线程去构建缓存。</li></ul> <p>从实战看，此方法有效杜绝了热点key产生的问题，但唯一不足的就是重构缓存期间，会出现数据不一致的情况，这取决于应用方是否容忍这种不一致。</p> <h4 id="_7-3-对比"><a href="#_7-3-对比" class="header-anchor">#</a> 7.3 对比</h4> <table><thead><tr><th style="text-align:center;">解决方案</th> <th style="text-align:center;">优点</th> <th style="text-align:center;">缺点</th></tr></thead> <tbody><tr><td style="text-align:center;">简单分布式锁</td> <td style="text-align:center;">思路简单、保证一致性</td> <td style="text-align:center;">代码复杂度增大、存在死锁的风险、存在线程池阻塞的风险</td></tr> <tr><td style="text-align:center;">“永远不过期”</td> <td style="text-align:center;">基本杜绝热点key问题</td> <td style="text-align:center;">不保证一致性、逻辑过期时间增加代码维护成本和内存成本</td></tr></tbody></table> <h3 id="_8-总结-2"><a href="#_8-总结-2" class="header-anchor">#</a> 8. 总结</h3> <ul><li>缓存的使用带来的收益是能够加速读写，降低后端存储负载。</li> <li>缓存的使用带来的成本是缓存和存储数据不一致性，代码维护成本增大，架构复杂度增大。</li> <li>比较推荐的缓存更新策略是结合剔除、超时、主动更新三种方案共同完成。</li> <li>穿透问题：使用缓存空对象和布隆过滤器来解决，注意它们各自的使用场景和局限性。</li> <li>无底洞问题：分布式缓存中，有更多的机器不保证有更高的性能。有四种批量操作方式：串行命令、串行IO、并行IO、hash_tag。</li> <li>雪崩问题：缓存层高可用、客户端降级、提前演练是解决雪崩问题的重要方法。</li> <li>热点key问题：互斥锁、“永远不过期”能够在一定程度上解决热点key问题，开发人员在使用时要了解它们各自的使用成本。</li></ul></div></div> <div class="page-edit"><div class="edit-link"><a href="https://github.com/zhanjiabin/corona-blog/edit/master/docs/01.后端/06.Redis/01.Redis.md" target="_blank" rel="noopener noreferrer">编辑</a> <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></div> <div class="tags"><a href="/tags/?tag=Redis" title="标签">
      #Redis
    </a></div> <div class="last-updated"><span class="prefix">上次更新:</span> <span class="time">2021/01/30, 13:01:00</span></div></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><a href="/pages/mongodb/" class="page-nav-centre page-nav-centre-prev"><div class="tooltip">
        MongoDB
      </div></a> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/pages/mongodb/" class="prev">MongoDB</a></span> <!----></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/archives" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/pages/http/"><div>HTTP</div></a> <span>04-05</span></dt></dl><dl><dd>02</dd> <dt><a href="/pages/html_mobile/"><div>移动端开发笔记</div></a> <span>04-03</span></dt></dl><dl><dd>03</dd> <dt><a href="/pages/css_base/"><div>CSS学习笔记</div></a> <span>04-02</span></dt></dl> <dl><dd></dd> <dt><a href="/archives" class="more">更多文章&gt;</a></dt></dl></div></div> </main></div> <div class="footer"><div class="icons"><a href="mailto:1227216685@qq.com" title="发邮件" target="_blank" class="iconfont icon-youjian"></a><a href="https://github.com/zhanjiabin" title="GitHub" target="_blank" class="iconfont icon-github"></a><a href="https://music.163.com/#/playlist?id=82020112" title="听音乐" target="_blank" class="iconfont icon-erji"></a></div> 
     | Copyright © 2020-2021
    <span>Corona | MIT License</span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----></div><div class="global-ui"><div></div></div></div>
    <script src="/assets/js/app.2d002c64.js" defer></script><script src="/assets/js/2.1de4f9a9.js" defer></script><script src="/assets/js/3.388dfb37.js" defer></script><script src="/assets/js/28.c46e3d81.js" defer></script>
  </body>
</html>