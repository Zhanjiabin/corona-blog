---
title: Spring Boot
date: 2020-08-16 17:13:04
permalink: /pages/spring_boot
categories:
  - 后端
  - Java
tags:
  - Java
  - Spring
  - Spring Boot
author:
  name: 詹佳斌
  link: https://github.com/zhanjiabin
---
# Spring Boot

Spring Boot
<!-- more -->
# SpringBoot学习笔记

## 第一章 Spring Boot快速入门

### 1.简述

Spring Boot是由Pivotal团队提供的全新框架，其设计目的是用来简化新Spring应用的初始搭建以及开发过程。该框架使用了特定的方式来进行配置，从而使开发人员不再需要定义样板化的配置。通过这种方式，Spring Boot致力于在蓬勃发展的快速应用开发领域(rapid application development)成为领导者。

### 2.特点

SpringBoot所具备的特征有：

（1）可以创建独立的[Spring](https://baike.baidu.com/item/Spring/85061)应用程序，并且基于其Maven或Gradle插件，可以创建可执行的JARs和WARs；

（2）内嵌Tomcat或Jetty等Servlet容器；

（3）提供自动配置的“starter”项目对象模型（POMS）以简化[Maven](https://baike.baidu.com/item/Maven/6094909)配置；

（4）尽可能自动配置Spring容器；

（5）提供准备好的特性，如指标、健康检查和外部化配置；

（6）绝对没有代码生成，不需要XML配置。

### 3.SpringMVC主要注解

- `@Controller`：@Controller用于标记在一个类上，使用它标记的类就是一个SpringMvc Controller对象，分发处理器会扫描使用该注解的类的方法，并检测该方法是否使用了@RequestMapping注解。
- `@RestController`：@Controller+@ResponseBody。
- `@RequestMapping`：在Spring MVC 中使用 @RequestMapping 来映射请求，也就是通过它来指定控制器可以处理哪些URL请求，相当于Servlet中在web.xml中配置。
- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@RequestParam`
- `@PathVariable`

### 4.最基础的SpringBoot Maven

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>

    <groupId>com.corona</groupId>
    <artifactId>springboot</artifactId>
    <version>1.0-SNAPSHOT</version>

    <parent>
        <artifactId>spring-boot-starter-validation</artifactId>
        <groupId>org.springframework.boot</groupId>
        <version>2.1.3.RELEASE</version>
        <relativePath/>
    </parent>

    <dependencies>
        <!-- SpringMvc -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- 单元测试 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

</project>
```

### 5.测试

MockMvc测试

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
@AutoConfigureMockMvc
public class HelloControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testHello() throws Exception {
        ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get("/hello"));
        //响应状态码200
        resultActions.andExpect(MockMvcResultMatchers.status().isOk());
        resultActions.andExpect(MockMvcResultMatchers.content().string("hello world"));
    }

}
```

## 第二章 Spring Boot自动配置原理

### 1.概述

Spring Boot自动配置，要解决三个问题：

* 满足什么样的条件？  @ConditionalOnClass
* 创建哪些Bean？@Configuration+@Bean
* 创建的Bean属性？@EnableConfigurationProperties

### 2.自动配置类

对照下这三个问题，在我们引入**spring-boot-starter-web**依赖，会创建一个8080端口的内嵌Tomcat，同时可以通过**application.yaml**配置文件中的**server.port**配置自定义端口。

例子：

Spring Boot提供的**EmbeddedWebServerFactoryCustomizerAutoConfiguration**类，负责创建内嵌的Tomcat、Jetty等等Web服务器的配置类。

```java
@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties({ServerProperties.class})
public class EmbeddedWebServerFactoryCustomizerAutoConfiguration {
    public EmbeddedWebServerFactoryCustomizerAutoConfiguration() {
    }

    @Configuration
    @ConditionalOnClass({HttpServer.class})
    public static class NettyWebServerFactoryCustomizerConfiguration {
        public NettyWebServerFactoryCustomizerConfiguration() {
        }

        @Bean
        public NettyWebServerFactoryCustomizer nettyWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
            return new NettyWebServerFactoryCustomizer(environment, serverProperties);
        }
    }

    @Configuration
    @ConditionalOnClass({Undertow.class, SslClientAuthMode.class})
    public static class UndertowWebServerFactoryCustomizerConfiguration {
        public UndertowWebServerFactoryCustomizerConfiguration() {
        }

        @Bean
        public UndertowWebServerFactoryCustomizer undertowWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
            return new UndertowWebServerFactoryCustomizer(environment, serverProperties);
        }
    }

    @Configuration
    @ConditionalOnClass({Server.class, Loader.class, WebAppContext.class})
    public static class JettyWebServerFactoryCustomizerConfiguration {
        public JettyWebServerFactoryCustomizerConfiguration() {
        }

        @Bean
        public JettyWebServerFactoryCustomizer jettyWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
            return new JettyWebServerFactoryCustomizer(environment, serverProperties);
        }
    }

    @Configuration
    @ConditionalOnClass({Tomcat.class, UpgradeProtocol.class})
    public static class TomcatWebServerFactoryCustomizerConfiguration {
        public TomcatWebServerFactoryCustomizerConfiguration() {
        }

        @Bean
        public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment, ServerProperties serverProperties) {
            return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
        }
    }
}
```

在我们通过 [`SpringApplication#run(Class primarySource, String... args)`](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/SpringApplication.java#L1218-L1227) 方法，启动 Spring Boot 应用的时候，有个非常重要的组件 [SpringFactoriesLoader](https://github.com/spring-projects/spring-framework/blob/master/spring-core/src/main/java/org/springframework/core/io/support/SpringFactoriesLoader.java) 类，会读取 `META-INF` 目录下的 `spring.factories` 文件，获得**每个框架定义的需要自动配置的配置类**。

我们以 [spring-boot-autoconfigure](https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-autoconfigure) 项目的 [Spring Boot `spring.factories`](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-autoconfigure/src/main/resources/META-INF/spring.factories) 文件来举个例子，如下图所示：![img](http://www.iocoder.cn/images/Spring-Boot/2019-02-01/02.png)

如此，原先 `@Configuration` 注解的配置类，就**升级**成类自动配置类。这样，Spring Boot 在获取到需要自动配置的配置类后，就可以自动创建相应的 Bean，完成自动配置的功能。

因为 spring-boot-autoconfigure 项目提供的是它选择的主流框架的自动配置，所以其它框架需要自己实现。例如说，Dubbo 通过 [dubbo-spring-boot-project](https://github.com/apache/dubbo-spring-boot-project) 项目，提供 Dubbo 的自动配置。

### 3.条件注解

* @Profile：为了满足不同环境注册不同的 Bean ，引入了Spring3.1版本 [`@Profile`](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Profile.java) 注解
* @Conditional：在 Spring4 版本时，提供了 [`@Conditional`](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/context/annotation/Conditional.java) 注解，用于声明在配置类或者创建 Bean 的方法上，表示需要满足指定条件才能生效。

显然，Spring4 提交的 `@Conditional` 注解非常不方便，需要我们自己去拓展。因此，Spring Boot 进一步增强，提供了常用的条件注解：

- `@ConditionalOnBean`：当容器里有指定 Bean 的条件下
- `@ConditionalOnMissingBean`：当容器里没有指定 Bean 的情况下
- `@ConditionalOnSingleCandidate`：当指定 Bean 在容器中只有一个，或者虽然有多个但是指定首选 Bean
- `@ConditionalOnClass`：当类路径下有指定类的条件下
- `@ConditionalOnMissingClass`：当类路径下没有指定类的条件下
- `@ConditionalOnProperty`：指定的属性是否有指定的值
- `@ConditionalOnResource`：类路径是否有指定的值
- `@ConditionalOnExpression`：基于 SpEL 表达式作为判断条件
- `@ConditionalOnJava`：基于 Java 版本作为判断条件
- `@ConditionalOnJndi`：在 JNDI 存在的条件下差在指定的位置
- `@ConditionalOnNotWebApplication`：当前项目不是 Web 项目的条件下
- `@ConditionalOnWebApplication`：当前项目是 Web项 目的条件下

### 4.配置属性

Spring Boot 约定读取 `application.yaml`、`application.properties` 等配置文件，从而实现创建 Bean 的自定义属性配置，甚至可以搭配 `@ConditionalOnProperty` 注解来取消 Bean 的创建。

添加 `@ConfigurationProperties` 注解，并设置 `prefix = "order"` 属性，这样它就可以读取**前缀**为 `order` 配置项，设置到配置类对应的属性上。

`@ConfigurationProperties` 注解除了支持添加在类上，也只支持添加在方法上。

### 5.内置Starter

我们在使用Spring Boot时，并不会直接引入spring-boot-autoconfigure依赖，而是使用Spring Boot内置提供的Starter依赖，例如说，想使用SpringMVC时，引入的是spring-boot-starter-web依赖。

因为Spring Boot提供的自动配置类，基本都有@ConditionalClass条件注解，判断我们项目中存在指定的类，才会创建对应的Bean。而拥有指定类的前提，一般是需要我们引入对应框架的依赖。

因此，在我们引入spring-boot-starter-web依赖时，它会帮我们自动引入相关依赖，从而保证自动配置类能够生效，创建对应的Bean。

### 6.自定义Starter

Spring Boot Starter命名规则：

| 场景                         | 命名规则                            | 示例                                                         |
| :--------------------------- | :---------------------------------- | :----------------------------------------------------------- |
| **Spring Boot 内置** Starter | `spring-boot-starter-{框架}`        | `spring-boot-starter-web`                                    |
| 框架 **自定义** Starter      | `{框架}-spring-boot-starter`        | [`mybatis-spring-boot-starter`](https://mvnrepository.com/artifact/org.mybatis.spring.boot/mybatis-spring-boot-starter) |
| 个人开源 **自定义** Starter  | `{个人}-spring-boot-starter-{框架}` | corona-spring-boot-starter-mybatis                           |

做一个简单的starter demo

maven只需引入

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter</artifactId>
    <version>2.2.2.RELEASE</version>
</dependency>
```

属性配置类：

```java
@ConfigurationProperties(prefix = "corona.server")
public class CoronaServerProperties {

    private static final Integer DEFAULT_PORT = 8000;

    private Integer port = DEFAULT_PORT;

    public static Integer getDefaultPort() {
        return DEFAULT_PORT;
    }

    public Integer getPort() {
        return port;
    }

    public CoronaServerProperties setPort(Integer port) {
        this.port = port;
        return this;
    }
}
```

自动配置类：

```java
@Configuration
@EnableConfigurationProperties(CoronaServerProperties.class)
public class CoronaServerAutoConfiguration {

    private Logger logger = LoggerFactory.getLogger(CoronaServerAutoConfiguration.class);

    @Bean
    @ConditionalOnClass(HttpServer.class)// 需要项目中存在 com.sun.net.httpserver.HttpServer 类。该类为 JDK 自带，所以一定成立
    public HttpServer httpServer(CoronaServerProperties serverProperties) throws IOException {
        HttpServer server = HttpServer.create(new InetSocketAddress(serverProperties.getPort()), 0);
        server.start();
        logger.info("[httpServer][启动服务器成功，端口为:{}]", serverProperties.getPort());
        return server;
    }

}
```

## 第三章 Spring Boot Jar 启动原理

### 1.概述

Spring Boot 提供了Maven插件spring-boot-maven-plugin，可以方便地将Spring Boot项目打成jar包或者war包。

Spring Boot jar包，一共分成四个部分：

![image-20201226185257604](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20201226185257604.png)

1. META-INF目录：通过MANIFEST.MF文件提供jar包的元数据，声明了jar的启动类。

2. org目录：为Spring Boot提供的spring-boot-loader项目，它是java -jar启动Spring Boot项目的秘密所在，也是稍后我们将深入了解的部分。
3. BOOT-INF/lib目录：我们Spring Boot项目中引入的依赖的jar包们。spring-boot-loader项目很大的一个作用，就是解决jar包里嵌套jar的情况，如何加载到其中的类。
4. BOOT-INF/classes目录：我们在Spring Boot项目中Java类所编译的.class、配置文件等等。

spring-boot-loader项目需要解决两个问题：

1. 第一，如何引导执行我们创建的Spring Boot应用的启动类，例如上述图中的Application类。
2. 第二，如何加载BOOT-INF/class目录下的类，以及BOOT-INF/lib目录下内嵌的jar包中的类。

### 2.MANIFEST.MF

内容如下：

```yaml
Manifest-Version: 1.0
Created-By: Maven Jar Plugin 3.2.0
Build-Jdk-Spec: 11
Implementation-Title: blog
Implementation-Version: 1.0.0
Implementation-Vendor: Pivotal Software, Inc.
Main-Class: org.springframework.boot.loader.JarLauncher
Start-Class: com.corona.blog.BlogApplication
Spring-Boot-Version: 2.3.1.RELEASE
Spring-Boot-Classes: BOOT-INF/classes/
Spring-Boot-Lib: BOOT-INF/lib/
Spring-Boot-Classpath-Index: BOOT-INF/classpath.idx
```

这个实际上是一个Properties配置文件，每一行都是一个配置项目，重点来看看两个配置项：

* Main-Class配置项：Java规定的jar包的启动类，这里设置为spring-boot-loader项目的JarLauncher类，进行Spring Boot应用的启动。
* Start-Class配置项：Spring Boot规定的主启动类，这里设置为我们定义的Application类。

tips：为什么会有Main-Class/Start-Class配置项呢？因为是我们通过Spring Boot提供的Maven插件spring-boot-maven-plugin进行打包，该插件该配置项写入到MANIFEST.MF中，从而能让spring-boot-loader能够引导启动Spring Boot应用。

可能胖友会有疑惑，`Start-Class` 对应的 Application 类自带了 `#main(String[] args)` 方法，为什么我们不能直接运行会如何呢？我们来简单尝试一下哈，控制台执行如下：



```
$ java -classpath lab-39-demo-2.2.2.RELEASE.jar cn.iocoder.springboot.lab39.skywalkingdemo.Application
错误: 找不到或无法加载主类 cn.iocoder.springboot.lab39.skywalkingdemo.Application
```



直接找不到 Application 类，因为它在 `BOOT-INF/classes` 目录下，不符合 Java 默认的 `jar` 包的加载规则。因此，需要通过 JarLauncher 启动加载。

当然实际还有一个更重要的原因，Java 规定可执行器的 `jar` 包禁止嵌套其它 `jar` 包。但是我们可以看到 `BOOT-INF/lib` 目录下，实际有 Spring Boot 应用依赖的所有 `jar` 包。因此，`spring-boot-loader` 项目自定义实现了 ClassLoader 实现类 [LaunchedURLClassLoader](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot-tools/spring-boot-loader/src/main/java/org/springframework/boot/loader/LaunchedURLClassLoader.java)，支持加载 `BOOT-INF/classes` 目录下的 `.class` 文件，以及 `BOOT-INF/lib` 目录下的 `jar` 包。

### 3.JarLauncher

源码如下：

```java
  protected void launch(String[] args) throws Exception {
    if (!isExploded())
        // 1.注册 URL 协议的处理器
      JarFile.registerUrlProtocolHandler(); 
      // 2.创建类加载器
    ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
    String jarMode = System.getProperty("jarmode");
    String launchClass = (jarMode != null && !jarMode.isEmpty()) ? "org.springframework.boot.loader.jarmode.JarModeLauncher" : getMainClass();
      // 3.执行启动类的main方法
    launch(args, launchClass, classLoader);
  }
```

1. 调用JarFile的 registerUrlProtocolHandler()方法，注册Spring Boot自定义的URLStreamHandler实现类，用于jar包的加载读取。
2. 调用自身的createClassLoader(List<Archive> archives)方法，创建自定义的ClassLoader实现类，用于从jar包中加载类。
3. 执行我们声明的Spring Boot启动类，进行Spring Boot应用的启动。

简单来说，就是整一个可以读取jar包中类的加载器，保证BOOT-INF/lib目录下的类和BOOT-classes内嵌的jar中的类能够被正常加载到，之后执行Spring Boot应用的启动。

### 4.LaunchedURLClassLoader

LaunchedURLClassLoader是spring-boot-loader项目自定义的类加载器，实现对jar中META-INF/classes目录下的类和META-INF/lib内嵌的jar包中的类的加载。

tips：

Java 类加载器是 Java 运行时环境的一个部件，负责动态加载 Java 类到 Java 虚拟机的内存空间中。类通常是按需加载，即第一次使用该类时才加载。

由于有了类加载器，Java 运行时系统不需要知道文件与文件系统。对学习类加载器而言，掌握 Java 的委派概念是很重要的。每个 Java 类必须由某个类加载器装入到内存。

```java
// ExecutableArchiveLauncher.java

protected ClassLoader createClassLoader(List<Archive> archives) throws Exception {
    // 获得所有 Archive 的 URL 地址
    List<URL> urls = new ArrayList<>(archives.size());
    for (Archive archive : archives) {
        urls.add(archive.getUrl());
    }
    // 创建加载这些 URL 的 ClassLoader
    return createClassLoader(urls.toArray(new URL[0]));
}

protected ClassLoader createClassLoader(URL[] urls) throws Exception {
	return new LaunchedURLClassLoader(urls, getClass().getClassLoader());
}

// LaunchedURLClassLoader.java

public class LaunchedURLClassLoader extends URLClassLoader {

	public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
		super(urls, parent);
	}
	
}
```

- 第一个参数 `urls`，使用的是 Archive 集合对应的 URL 地址们，从而告诉 LaunchedURLClassLoader 读取 `jar` 的**地址**。
- 第二个参数 `parent`，设置 LaunchedURLClassLoader 的**父**加载器。这里后续胖友可以理解下，类加载器的**双亲委派模型**，这里就拓展开了。

```java
package org.springframework.boot.loader;

import java.io.ByteArrayOutputStream;
import java.io.IOException;
import java.io.InputStream;
import java.net.JarURLConnection;
import java.net.URL;
import java.net.URLClassLoader;
import java.net.URLConnection;
import java.security.AccessController;
import java.security.PrivilegedActionException;
import java.util.Enumeration;
import java.util.function.Supplier;
import java.util.jar.JarFile;
import java.util.jar.Manifest;
import org.springframework.boot.loader.archive.Archive;
import org.springframework.boot.loader.jar.Handler;
import org.springframework.boot.loader.jar.JarFile;

public class LaunchedURLClassLoader extends URLClassLoader {
  private static final int BUFFER_SIZE = 4096;
  
  private final boolean exploded;
  
  private final Archive rootArchive;
  
  static {
    ClassLoader.registerAsParallelCapable();
  }
  
  private final Object packageLock = new Object();
  
  private volatile DefinePackageCallType definePackageCallType;
  
  public LaunchedURLClassLoader(URL[] urls, ClassLoader parent) {
    this(false, urls, parent);
  }
  
  public LaunchedURLClassLoader(boolean exploded, URL[] urls, ClassLoader parent) {
    this(exploded, (Archive)null, urls, parent);
  }
  
  public LaunchedURLClassLoader(boolean exploded, Archive rootArchive, URL[] urls, ClassLoader parent) {
    super(urls, parent);
    this.exploded = exploded;
    this.rootArchive = rootArchive;
  }

  
  protected Class<?> loadClass(String name, boolean resolve) throws ClassNotFoundException {
    if (name.startsWith("org.springframework.boot.loader.jarmode."))
      try {
        Class<?> result = loadClassInLaunchedClassLoader(name);
        if (resolve)
          resolveClass(result); 
        return result;
      } catch (ClassNotFoundException classNotFoundException) {} 
    if (this.exploded)
      return super.loadClass(name, resolve); 
    Handler.setUseFastConnectionExceptions(true);
    try {
      try {
        definePackageIfNecessary(name);
      } catch (IllegalArgumentException ex) {
        if (getPackage(name) == null)
          throw new AssertionError("Package " + name + " has already been defined but it could not be found"); 
      } 
      return super.loadClass(name, resolve);
    } finally {
      Handler.setUseFastConnectionExceptions(false);
    } 
  }
  
  private void definePackageIfNecessary(String className) {
    int lastDot = className.lastIndexOf('.');
    if (lastDot >= 0) {
      String packageName = className.substring(0, lastDot);
      if (getPackage(packageName) == null)
        try {
          definePackage(className, packageName);
        } catch (IllegalArgumentException ex) {
          if (getPackage(packageName) == null)
            throw new AssertionError("Package " + packageName + " has already been defined but it could not be found"); 
        }  
    } 
  }
  
  private void definePackage(String className, String packageName) {
    try {
      AccessController.doPrivileged(() -> {
            String packageEntryName = packageName.replace('.', '/') + "/";
            String classEntryName = className.replace('.', '/') + ".class";
            for (URL url : getURLs()) {
              try {
                URLConnection connection = url.openConnection();
                if (connection instanceof JarURLConnection) {
                  JarFile jarFile = ((JarURLConnection)connection).getJarFile();
                  if (jarFile.getEntry(classEntryName) != null && jarFile.getEntry(packageEntryName) != null && jarFile.getManifest() != null) {
                    definePackage(packageName, jarFile.getManifest(), url);
                    return null;
                  } 
                } 
              } catch (IOException iOException) {}
            } 
            return null;
          }AccessController.getContext());
    } catch (PrivilegedActionException privilegedActionException) {}
  }
  
  protected Package definePackage(String name, Manifest man, URL url) throws IllegalArgumentException {
    if (!this.exploded)
      return super.definePackage(name, man, url); 
    synchronized (this.packageLock) {
      return doDefinePackage(DefinePackageCallType.MANIFEST, () -> super.definePackage(name, man, url));
    } 
  }
  ......
}

```

### 5.Launcher

```java
package org.springframework.boot.loader;

import java.io.File;
import java.net.URI;
import java.net.URL;
import java.security.CodeSource;
import java.security.ProtectionDomain;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;
import org.springframework.boot.loader.archive.Archive;
import org.springframework.boot.loader.archive.ExplodedArchive;
import org.springframework.boot.loader.archive.JarFileArchive;
import org.springframework.boot.loader.jar.JarFile;

public abstract class Launcher {
  private static final String JAR_MODE_LAUNCHER = "org.springframework.boot.loader.jarmode.JarModeLauncher";
  
  protected void launch(String[] args) throws Exception {
    if (!isExploded())
      JarFile.registerUrlProtocolHandler(); 
    ClassLoader classLoader = createClassLoader(getClassPathArchivesIterator());
    String jarMode = System.getProperty("jarmode");
    String launchClass = (jarMode != null && !jarMode.isEmpty()) ? "org.springframework.boot.loader.jarmode.JarModeLauncher" : getMainClass();
    launch(args, launchClass, classLoader);
  }
  
  @Deprecated
  protected ClassLoader createClassLoader(List<Archive> archives) throws Exception {
    return createClassLoader(archives.iterator());
  }
  
  protected ClassLoader createClassLoader(Iterator<Archive> archives) throws Exception {
    List<URL> urls = new ArrayList<>(50);
    while (archives.hasNext()) {
      Archive archive = archives.next();
      urls.add(archive.getUrl());
      archive.close();
    } 
    return createClassLoader(urls.<URL>toArray(new URL[0]));
  }
  
  protected ClassLoader createClassLoader(URL[] urls) throws Exception {
    return new LaunchedURLClassLoader(isExploded(), getArchive(), urls, getClass().getClassLoader());
  }
  
  protected void launch(String[] args, String launchClass, ClassLoader classLoader) throws Exception {
    Thread.currentThread().setContextClassLoader(classLoader);
    createMainMethodRunner(launchClass, args, classLoader).run();
  }
  
  protected MainMethodRunner createMainMethodRunner(String mainClass, String[] args, ClassLoader classLoader) {
    return new MainMethodRunner(mainClass, args);
  }
  
  protected abstract String getMainClass() throws Exception;
  
  protected Iterator<Archive> getClassPathArchivesIterator() throws Exception {
    return getClassPathArchives().iterator();
  }
  
  @Deprecated
  protected List<Archive> getClassPathArchives() throws Exception {
    throw new IllegalStateException("Unexpected call to getClassPathArchives()");
  }
  
  protected final Archive createArchive() throws Exception {
    ProtectionDomain protectionDomain = getClass().getProtectionDomain();
    CodeSource codeSource = protectionDomain.getCodeSource();
    URI location = (codeSource != null) ? codeSource.getLocation().toURI() : null;
    String path = (location != null) ? location.getSchemeSpecificPart() : null;
    if (path == null)
      throw new IllegalStateException("Unable to determine code source archive"); 
    File root = new File(path);
    if (!root.exists())
      throw new IllegalStateException("Unable to determine code source archive from " + root); 
    return root.isDirectory() ? (Archive)new ExplodedArchive(root) : (Archive)new JarFileArchive(root);
  }
  
  protected boolean isExploded() {
    return false;
  }
  
  protected Archive getArchive() {
    return null;
  }
}
```

![Spring Boot  启动原理](http://www.iocoder.cn/images/Spring-Boot/2019-01-07/30.png)

红色部分，解决jar包中的类加载问题：

* 通过Archive，实现jar包的遍历，将BOOT-INF/classes目录和BOOT-INF/lib的每一个内嵌的jar解析成一个Archive对象。
* 通过Handler，处理jar:协议的URL的资源读取，也就是读取了每个Archive里的内容。
* 通过LanchedURLClassLoader，实现BOOT-INF/classes目录下的类和BOOT-INF/classes目录下内嵌的jar包中的类的加载。具体的URL来源，是通过Archive提供；具体URL的读取，是通过Handler提供。
* 橘色部分，解决Spring Boot启用的启动问题：通过MainMethodRunner，实现Spring Boot应用的启动类的执行。

当然，上述的一切都是通过Launcher来完成引导和启动，通过MANIFEST.MF进行具体配置。

## 第四章 Spring Boot开发工具

### 1.Spring Boot热部署入门

#### 1.1 概述

严格来说，应该叫 HotSwap 的方式，翻译成中文会有热部署、热更新、热替换、热加载等等多种。这里，我们就采用大家可能说的比较多的翻译，**热部署**。

#### 1.2 spring-boot-devtools

[`spring-boot-devtools`](https://github.com/spring-projects/spring-boot/tree/master/spring-boot-project/spring-boot-devtools) 是 Spring Boot 提供的开发者工具，它会监控当前应用所在的 classpath 下的文件发生变化，进行**自动重启**。

注意，`spring-boot-devtools` 并**没有**采用热部署的方式，而是一种较快的重启方式。其官方文档解释如下：

> FROM [《Spring Boot 2.X 中文文档 —— 开发者工具》](https://docshome.gitbooks.io/springboot/content/pages/using-spring-boot.html#using-boot-devtools-restart)
>
> Spring Boot 通过使用两个类加载器来提供了重启技术。
>
> - 不改变的类（例如，第三方 jar）被加载到 **base** 类加载器中。
> - 经常处于开发状态的类被加载到 **restart** 类加载器中。
>
> 当应用重启时，**restart** 类加载器将被丢弃，并重新创建一个新的。这种方式意味着应用重启比**冷启动**要快得多，因为省去 **base** 类加载器的处理步骤，并且可以直接使用。
>
> 如果您觉得重启还不够快，或者遇到类加载问题，您可以考虑如 ZeroTurnaround 的 [JRebel](https://zeroturnaround.com/software/jrebel/) 等工具。他们是通过在加载类时重写类来加快重新加载。

#### 1.3 IDEA热部署

IDEA 提供了 [HotSwap](https://www.jetbrains.com/help/idea/debugger-hotswap.html) 插件，可以实现真正的热部署。

#### 1.4 Jrebel

[Jrebel](https://www.jrebel.com/) 是比较有名的一款 Java 热部署插件。

### 2.Spring Boot Lombok使用入门

#### 2.1 概述

[Lombok](https://github.com/rzwitserloot/lombok) 是一个 Java 工具，通过使用其定义的注解，自动生成常见的冗余代码，提升开发效率。

#### 2.2 实现原理

Lombok 的实现原理，基于 [JSR269(Pluggable Annotation Processing API)](https://jcp.org/en/jsr/detail?id=269) 规范，自定义编译器注解处理器，用于在 Javac 编译阶段时，扫描使用到 Lombok 定义的注解的类，进行自定义的代码生成。

- [《注解处理器是干嘛的》](http://www.iocoder.cn/Fight/What-does-the-annotation-handler-do/?self)
- [《JSR269 插件化注解API》](https://blog.whatakitty.com/JSR269插件化注解API.html)

#### 2.3 安装Lombok

在 IDEA 中，已经提供了 [IntelliJ Lombok plugin](https://plugins.jetbrains.com/plugin/6317-lombok) 插件，方便我们使用 Lombok。安装方式很简单，只需要在 IDEA Plugins 功能中，搜索 Lombok 关键字即可。

#### 2.4 Lombok依赖

```xml
<!-- 引入 Lombok 依赖 -->
<dependency>
    <groupId>org.projectlombok</groupId>
    <artifactId>lombok</artifactId>
    <optional>true</optional>
</dependency>
```

#### 2.5 Lombok注解一览

Lombok 的注解非常多，我们逐个来看看。

[`@Getter`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/Getter.java) 注解，添加在**类**或**属性**上，生成对应的 get 方法。

[`@Setter`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/Setting.java) 注解，添加在**类**或**属性**上，生成对应的 set 方法。

[`@ToString`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/ToString.java) 注解，添加在**类**上，生成 toString 方法。

[`@EqualsAndHashCode`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/EqualsAndHashCode.java) 注解，添加在**类**上，生成 equals 和 hashCode 方法。

`@AllArgsConstructor`、`@RequiredArgsConstructor`、`@NoArgsConstructor` 注解，添加在**类**上，为类自动生成对应参数的构造方法。

[`@Data`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/Data.java) 注解，添加在**类**上，是 5 个 Lombok 注解的组合。

- 为所有属性，添加 `@Getter`、`@ToString`、`@EqualsAndHashCode` 注解的效果
- 为非 `final` 修饰的属性，添加 `@Setter` 注解的效果
- 为 `final` 修改的属性，添加 `@RequiredArgsConstructor` 注解的效果

`@Value` 注解，添加在**类**上，和 `@Data` 注解类似，区别在于它会把所有属性默认定义为 `private final` 修饰，所以不会生成 set 方法。

[`@CommonsLog`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/apachecommons/CommonsLog.java)、[`@Flogger`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/flogger/Flogger.java)、[`@Log`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/java/Log.java)、[`@JBossLog`](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/jbosslog/JBossLog.java)、[@Log4j](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/log4j/Log4j.java)、[@Log4j2](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/extern/log4j/Log4j2.java)、[@Slf4j](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/Slf4j.java)、[@Slf4jX](https://github.com/rzwitserloot/lombok/blob/master/src/core/lombok/Slf4jX.java) 注解，添加在**类**上，自动为类添加对应的日志支持。

`@NonNull` 注解，添加在**方法参数**、**类属性**上，用于自动生成 `null` 参数检查。若确实是 `null` 时，抛出 NullPointerException 异常。

`@Cleanup` 注解，添加在方法中的**局部变量**上，在作用域结束时会自动调用 `#close()` 方法，来释放资源。例如说，使用在 Java IO 流操作的时候。

`@Builder` 注解，添加在**类**上，给该类加个构造者模式 Builder 内部类。

`@Synchronized` 注解，添加在**方法**上，添加同步锁。

`@SneakyThrows` 注解，添加在**方法**上，给该方法添加 `try catch` 代码块。

`@Accessors` 注解，添加在**方法**或**属性**上，并设置 `chain = true`，实现链式编程。

[lombok功能列表](https://projectlombok.org/features/all)

### 3.Spring Boot对象转换MapStruct入门

性能很高。非反射机制，而是对象映射机制。

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>lab-55</artifactId>
        <groupId>cn.iocoder.springboot.labs</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>lab-55-mapstruct-demo-lombok</artifactId>

    <properties>
        <java.version>1.8</java.version>
        <mapstruct.version>1.3.1.Final</mapstruct.version>
        <lombok.version>1.18.12</lombok.version>
    </properties>

    <dependencies>
        <!-- 引入 mapstruct 依赖 -->
        <dependency>
            <groupId>org.mapstruct</groupId>
            <artifactId>mapstruct</artifactId>
            <version>${mapstruct.version}</version>
        </dependency>

        <!-- 引入 lombok 依赖 -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>${lombok.version}</version>
            <scope>provided</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-compiler-plugin</artifactId>
                <version>3.8.1</version>
                <configuration>
                    <source>${java.version}</source>
                    <target>${java.version}</target>
                    <annotationProcessorPaths>
                        <!-- 引入 mapstruct-processor -->
                        <path>
                            <groupId>org.mapstruct</groupId>
                            <artifactId>mapstruct-processor</artifactId>
                            <version>${mapstruct.version}</version>
                        </path>
                        <!-- 引入 lombok-processor -->
                        <path>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                            <version>${lombok.version}</version>
                        </path>
                    </annotationProcessorPaths>
                </configuration>
            </plugin>
        </plugins>
    </build>

</project>
```

## 第五章 Spring Boot SpringMVC入门

### 1.概述

- Spring 为展现层提供的基于 MVC 设计理念的优秀的Web 框架，是目前最主流的 MVC 框架之一
- Spring3.0 后全面超越 Struts2，成为最优秀的 MVC 框架
- Spring MVC 通过一套 MVC 注解，让 POJO 成为处理请求的控制器，而无须实现任何接口。
- 支持 REST 风格的 URL 请求
- 采用了松散耦合可插拔组件结构，比其他 MVC 框架更具扩展性和灵活性

### 2.快速入门

#### 2.1 注解

可能有胖友之前未使用过 SpringMVC ，所以在这个小节，我们来说下它提供的注解。

- `@Controller`
- `@RestController`
- `@RequestMapping`
- `@GetMapping`
- `@PostMapping`
- `@PutMapping`
- `@RequestParam`
- `@PathVariable`

##### 2.1.1 @Controller

[`@Controller`](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/stereotype/Controller.java) 注解，添加在类上，表示这是控制器 Controller 对象。属性如下：

- `name` 属性：该 Controller 对象的 Bean 名字。允许空。

[`@RestController`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RestController.java) 注解，添加在类上，是 `@Controller` 和 [`@ResponseBody`](https://github.com/ndimiduk/spring-framework/blob/master/org.springframework.web/src/main/java/org/springframework/web/bind/annotation/ResponseBody.java) 的组合注解，直接使用接口方法的返回结果，经过 JSON/XML 等序列化方式，最终返回。也就是说，无需使用 InternalResourceViewResolver 解析视图，返回 HTML 结果。

目前主流的架构，都是 [前后端分离](https://blog.csdn.net/fuzhongmin05/article/details/81591072) 的架构，后端只需要提供 API 接口，仅仅返回数据。而视图部分的工作，全部交给前端来做。也因此，我们项目中 99.99% 使用 `@RestController` 注解。

往往，我们提供的 API 接口，都是 Restful 或者类 Restful 风格，所以不了解的胖友，推荐看看如下两篇文章：

- [《RESTful API 最佳实践》](http://www.iocoder.cn/Fight/estful-api-best-practices.html)
- [《跟着 Github 学习 Restful HTTP API 的优雅设计》](http://www.iocoder.cn/Fight/Learn-Restful-HTTP-API-design-from-Github)

##### 2.1.2 @RequestMapping

[`@RequestMapping`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMapping.java) 注解，添加在类或方法上，标记该类/方法对应接口的配置信息。

`@RequestMapping` 注解的**常用属性**，如下：

- `path` 属性：接口路径。`[]` 数组，可以填写多个接口路径。
- `values` 属性：和 `path` 属性相同，是它的别名。
- `method` 属性：请求方法 [RequestMethod](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestMethod.java) ，可以填写 `GET`、`POST`、`POST`、`DELETE` 等等。`[]` 数组，可以填写多个请求方法。如果为空，表示匹配所有请求方法。

`@RequestMapping` 注解的**不常用属性**，如下：

- `name` 属性：接口名。一般情况下，我们不填写。

- `params` 属性：请求参数需要包含值的**参数名**。可以填写多个参数名。如果为空，表示匹配所有请你求方法。

- `headers` 属性：和 `params` 类似，只是从参数名变成**请求头**。

- `consumes` 属性：和 `params` 类似，只是从参数名变成请求头的**提交内容类型**( [Content-Type](https://juejin.im/post/5cb34fc06fb9a068a75d3555) )

- `produces` 属性：和 `params` 类似，只是从参数名变成请求头的( [Accept](https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Accept) )**可接受类型**。

  > 艿艿：关于 `consumes` 和 `produces` 属性，可以看看 [《Http 请求中 Content-Type 和 Accept 讲解以及在 Spring MVC 中的应用》](https://www.cnblogs.com/111testing/p/6037579.html) 文章，更加详细。

考虑到让开发更加方便，Spring 给每种请求方法提供了对应的注解：

- [`@GetMapping`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/GetMapping.java) 注解：对应 `@GET` 请求方法的 `@RequestMapping` 注解。
- [`@PostMapping`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PostMapping.java) 注解：对应 `@POST` 请求方法的 `@RequestMapping` 注解。
- [`@PutMapping`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PutMapping.java) 注解：对应 `@PUT` 请求方法的 `@RequestMapping` 注解。
- [`@DeleteMapping`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/DeleteMapping.java) 注解：对应 `@DELETE` 请求方法的 `@RequestMapping` 注解。
- 还有其它几个，就不一一列举了。

##### 2.1.3 @RequestParam

[`@RequestParam`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/RequestParam.java) 注解，添加在方法参数上，标记该方法参数对应的请求参数的信息。属性如下：

- `name` 属性：对应的请求参数名。如果为空，则直接使用方法上的参数变量名。
- `value` 属性：和 `name` 属性相同，是它的别名。
- `required` 属性：参数是否必须传。默认为 `true` ，表示必传。
- `defaultValue` 属性：参数默认值。

[`@PathVariable`](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/web/bind/annotation/PathVariable.java) 注解，添加在方法参数上，标记接口路径和方法参数的映射关系。具体的，我们在示例中来看。相比 `@RequestParam` 注解，少一个 `defaultValue` 属性。

#### 2.2 引入依赖

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>2.1.3.RELEASE</version>
        <relativePath/> <!-- lookup parent from repository -->
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>lab-springmvc-23-01</artifactId>

    <dependencies>
        <!-- 实现对 Spring MVC 的自动化配置 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- 方便等会写单元测试 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

    </dependencies>

</project>
```

### 3.测试接口

#### 3.1 集成测试

SpringMVC提供了测试框架MockMvc，方便快速测试接口。

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
@AutoConfigureMockMvc
public class HelloControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @Test
    public void testHello() throws Exception {
        ResultActions resultActions = mockMvc.perform(MockMvcRequestBuilders.get("/hello"));
        //响应状态码200
        resultActions.andExpect(MockMvcResultMatchers.status().isOk());
        resultActions.andExpect(MockMvcResultMatchers.content().string("hello world"));
        MvcResult mvcResult = resultActions.andReturn();
        System.out.println("拦截器数量:" + mvcResult.getInterceptors().length);
    }

}

拦截器数量:2
```

#### 3.2 单元测试

```java
@RunWith(SpringRunner.class)
@SpringBootTest(classes = Application.class)
@AutoConfigureMockMvc
public class HelloControllerTest {

    @MockBean
    private IUserService userService;

    @Test
    public void testGetUserName(){
        System.out.println("before mock:" + userService.getUserName(1));
        Mockito.when(userService.getUserName(1)).thenReturn("eeiy");
        System.out.println("after mock:" + userService.getUserName(1));

    }
}
```

### 4.全局统一返回

在全局统一返回里，我们至少需要定义三个字段：

- `code`：状态码。无论是否成功，必须返回。
  - 成功时，状态码为 0 。
  - 失败时，对应业务的错误码。

- `data`：数据。成功时，返回该字段。
- `message`：错误提示。失败时，返回该字段。

```css
// 成功响应
{
    code: 0,
    data: {
        id: 1,
        username: "yudaoyuanma"
    }
}

// 失败响应
{
    code: 233666,
    message: "徐妈太丑了"
}
```

#### 4.1 CommonResult

```java
// CommonResult.java

public class CommonResult<T> implements Serializable {

    public static Integer CODE_SUCCESS = 0;

    /**
     * 错误码
     */
    private Integer code;
    /**
     * 错误提示
     */
    private String message;
    /**
     * 返回数据
     */
    private T data;

    /**
     * 将传入的 result 对象，转换成另外一个泛型结果的对象
     *
     * 因为 A 方法返回的 CommonResult 对象，不满足调用其的 B 方法的返回，所以需要进行转换。
     *
     * @param result 传入的 result 对象
     * @param <T> 返回的泛型
     * @return 新的 CommonResult 对象
     */
    public static <T> CommonResult<T> error(CommonResult<?> result) {
        return error(result.getCode(), result.getMessage());
    }

    public static <T> CommonResult<T> error(Integer code, String message) {
        Assert.isTrue(!CODE_SUCCESS.equals(code), "code 必须是错误的！");
        CommonResult<T> result = new CommonResult<>();
        result.code = code;
        result.message = message;
        return result;
    }

    public static <T> CommonResult<T> success(T data) {
        CommonResult<T> result = new CommonResult<>();
        result.code = CODE_SUCCESS;
        result.data = data;
        result.message = "";
        return result;
    }

    @JsonIgnore // 忽略，避免 jackson 序列化给前端
    public boolean isSuccess() { // 方便判断是否成功
        return CODE_SUCCESS.equals(code);
    }

    @JsonIgnore // 忽略，避免 jackson 序列化给前端
    public boolean isError() { // 方便判断是否失败
        return !isSuccess();
    }

    // ... 省略 setting/getting/toString 方法

}
```

#### 4.2 GlobalResponseBodyHandler

```java
// GlobalResponseBodyHandler.java

@ControllerAdvice(basePackages = "cn.iocoder.springboot.lab23.springmvc.controller")
public class GlobalResponseBodyHandler implements ResponseBodyAdvice {

    @Override
    public boolean supports(MethodParameter returnType, Class converterType) {
        return true;
    }

    @Override
    public Object beforeBodyWrite(Object body, MethodParameter returnType, MediaType selectedContentType, Class selectedConverterType,
                                  ServerHttpRequest request, ServerHttpResponse response) {
        // 如果已经是 CommonResult 类型，则直接返回
        if (body instanceof CommonResult) {
            return body;
        }
        // 如果不是，则包装成 CommonResult 类型
        return CommonResult.success(body);
    }

}
```

### 5.全局异常处理

#### 5.1 ExceptionEnum

```java
/**
 * 异常枚举类
 *
 * @author corona
 * @date 2020-06-26
 */
public enum ExceptionEnum {

    /**
     * 自定义异常
     */
    BIZ_EXCEPTION(1, "自定义异常"),
    /**
     * 运行时异常
     */
    RUNTIME_EXCEPTION(2, "运行时异常"),
    /**
     * 空指针异常
     */
    NULL_POINTER_EXCEPTION(3, "空指针异常"),
    /**
     * 类型转换异常
     */
    CLASS_CAST_EXCEPTION(4, "类型转换异常"),
    /**
     * IO异常
     */
    IO_EXCEPTION(5, "IO异常"),
    /**
     * 未知方法异常
     */
    NO_SUCH_METHOD_EXCEPTION(6, "未知方法异常"),
    /**
     * 数组越界异常
     */
    INDEX_OUT_OF_BOUNDS_EXCEPTION(7, "数组越界异常"),
    /**
     * 400错误 无法解析
     */
    HTTP_MESSAGE_NOT_READABLE_EXCEPTION(8, "400错误 无法解析"),
    /**
     * 400错误 类型不匹配
     */
    TYPE_MISMATCH_EXCEPTION(9, "400错误 类型不匹配"),
    /**
     * 400错误 参数缺失
     */
    MISSING_SERVLET_REQUEST_PARAMETER_EXCEPTION(10, "400错误 参数缺失"),
    /**
     * 405错误 请求方法不匹配
     */
    HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION(11, "405错误 请求方法不匹配"),
    /**
     * 406错误 Media类型不匹配
     */
    HTTP_MEDIA_TYPE_NOT_ACCEPTABLE_EXCEPTION(12, "406错误 Media类型不匹配"),
    /**
     * 500错误 参数转换异常
     */
    CONVERSION_NOT_SUPPORTED_EXCEPTION(13, "500错误 参数转换异常"),
    /**
     * 栈溢出
     */
    STACK_OVERFLOW_ERROR(14, "栈溢出"),
    /**
     * 除数不能为0
     */
    ARITHMETIC_EXCEPTION(15, "除数不能为0"),
    /**
     * 没有权限
     */
    UNAUTHORIZED_EXCEPTION(16, "未授权！"),
    /**
     * Valid框架异常
     */
    VALID_EXCEPTION(17,"Valid框架异常"),
    /**
     * 其它错误
     */
    Exception(100, "其它错误");


    private Integer code;
    private String message;

    ExceptionEnum(Integer code, String message) {
        this.code = code;
        this.message = message;
    }

    public Integer getCode() {
        return code;
    }

    public String getMessage() {
        return message;
    }
}
```

#### 5.2 GlobalExceptionHandler

```java
/**
 * 全局异常处理类
 *
 * @author Corona
 * @date 2020-06-26
 */
@Slf4j
@ControllerAdvice
@ResponseBody
public class GlobalExceptionHandler {

    private static final String logExceptionFormat = "Capture Exception By GlobalExceptionHandler: Code: %s Detail: %s";

    /**
     * 自定义异常类
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(BizException.class)
    public Result bizExceptionHandler(BizException ex) {
        return resultFormat(ExceptionEnum.BIZ_EXCEPTION, ex);
    }

    /**
     * 运行时异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(RuntimeException.class)
    public Result runtimeExceptionHandler(RuntimeException ex) {
        return resultFormat(ExceptionEnum.RUNTIME_EXCEPTION, ex);
    }

    /**
     * 空指针异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(NullPointerException.class)
    public Result nullPointerExceptionHandler(NullPointerException ex) {
        return resultFormat(ExceptionEnum.NULL_POINTER_EXCEPTION, ex);
    }

    /**
     * 类型转换异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(ClassCastException.class)
    public Result classCastExceptionHandler(ClassCastException ex) {
        return resultFormat(ExceptionEnum.CLASS_CAST_EXCEPTION, ex);
    }

    /**
     * IO异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(IOException.class)
    public Result iOExceptionHandler(IOException ex) {
        return resultFormat(ExceptionEnum.IO_EXCEPTION, ex);
    }

    /**
     * 未知方法异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(NoSuchMethodException.class)
    public Result noSuchMethodExceptionHandler(NoSuchMethodException ex) {
        return resultFormat(ExceptionEnum.NO_SUCH_METHOD_EXCEPTION, ex);
    }

    /**
     * 数组越界异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(IndexOutOfBoundsException.class)
    public Result indexOutOfBoundsExceptionHandler(IndexOutOfBoundsException ex) {
        return resultFormat(ExceptionEnum.INDEX_OUT_OF_BOUNDS_EXCEPTION, ex);
    }

    /**
     * 400错误 无法解析
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({HttpMessageNotReadableException.class})
    public Result requestNotReadable(HttpMessageNotReadableException ex) {
        return resultFormat(ExceptionEnum.HTTP_MESSAGE_NOT_READABLE_EXCEPTION, ex);
    }

    /**
     * 400错误 类型不匹配
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({TypeMismatchException.class})
    public Result requestTypeMismatch(TypeMismatchException ex) {
        return resultFormat(ExceptionEnum.TYPE_MISMATCH_EXCEPTION, ex);
    }

    /**
     * 400错误 参数缺失
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({MissingServletRequestParameterException.class})
    public Result requestMissingServletRequest(MissingServletRequestParameterException ex) {
        return resultFormat(ExceptionEnum.MISSING_SERVLET_REQUEST_PARAMETER_EXCEPTION, ex);
    }

    /**
     * 405错误 请求方法不匹配
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({HttpRequestMethodNotSupportedException.class})
    public Result request405(HttpRequestMethodNotSupportedException ex) {
        return resultFormat(ExceptionEnum.HTTP_REQUEST_METHOD_NOT_SUPPORTED_EXCEPTION, ex);
    }

    /**
     * 406错误 Media类型不匹配
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({HttpMediaTypeNotAcceptableException.class})
    public Result request406(HttpMediaTypeNotAcceptableException ex) {
        return resultFormat(ExceptionEnum.HTTP_MEDIA_TYPE_NOT_ACCEPTABLE_EXCEPTION, ex);
    }

    /**
     * 500错误 参数转换异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({ConversionNotSupportedException.class, HttpMessageNotWritableException.class})
    public Result server500(RuntimeException ex) {
        return resultFormat(ExceptionEnum.CONVERSION_NOT_SUPPORTED_EXCEPTION, ex);
    }

    /**
     * 栈溢出
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({StackOverflowError.class})
    public Result requestStackOverflow(StackOverflowError ex) {
        return resultFormat(ExceptionEnum.STACK_OVERFLOW_ERROR, ex);
    }

    /**
     * 除数不能为0
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({ArithmeticException.class})
    public Result arithmeticException(ArithmeticException ex) {
        return resultFormat(ExceptionEnum.ARITHMETIC_EXCEPTION, ex);
    }

    /**
     * 未认证
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({UnauthorizedException.class})
    public Result unauthorizedException(UnauthorizedException ex) {
        return resultFormat(ExceptionEnum.UNAUTHORIZED_EXCEPTION, ex);
    }

    /**
     * 捕获@Validate校验抛出的异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(BindException.class)
    @ResponseBody
    public Result validException(BindException ex) {
        BindingResult bindingResult = ex.getBindingResult();
        List<FieldError> fieldErrors = bindingResult.getFieldErrors();
        for (FieldError fieldError : fieldErrors) {
            log.error(String.format(logExceptionFormat, ExceptionEnum.VALID_EXCEPTION.getCode(), fieldError.getDefaultMessage()));
            return Result.failed(ExceptionEnum.VALID_EXCEPTION.getCode(), fieldError.getDefaultMessage());
        }
        return null;
    }

    /**
     * 捕获@Validate校验抛出的异常
     *
     * @param ex
     * @return
     */
    @ExceptionHandler(MethodArgumentNotValidException.class)
    @ResponseBody
    public Result methodArgumentNotValidException(MethodArgumentNotValidException ex) {
        BindingResult bindingResult = ex.getBindingResult();
        List<FieldError> fieldErrors = bindingResult.getFieldErrors();
        for (FieldError fieldError : fieldErrors) {
            log.error(String.format(logExceptionFormat, ExceptionEnum.VALID_EXCEPTION.getCode(), fieldError.getDefaultMessage()));
            return Result.failed(ExceptionEnum.VALID_EXCEPTION.getCode(), fieldError.getDefaultMessage());
        }
        return null;
    }

    /**
     * 其他错误 位置错误
     *
     * @param ex
     * @return
     */
    @ExceptionHandler({Exception.class})
    public Result exception(Exception ex) {
        return resultFormat(ExceptionEnum.Exception, ex);
    }

    private <T extends Throwable> Result resultFormat(ExceptionEnum exceptionEnum, T ex) {
        log.error(String.format(logExceptionFormat, exceptionEnum.getCode(), ex.getMessage()));
        return Result.failed(exceptionEnum.getCode(), ex.getMessage());
    }

}
```

### 6. HandlerInterceptor拦截器

在使用SpringMVC的时候，我们可以使用HandlerInterceptor，拦截SpringMVC处理请求的过程，自定义前置和处理的逻辑。

* 日志拦截器，记录请求与响应。
* 认证拦截器，例如说access_token访问令牌，获得当前用户的信息，记录到ThreadLocal中。这样，后续的逻辑，只需要通过ThreadLocal就可以获取到用户信息。
* 授权拦截器，可以通过每个API接口需要的授权信息，进行判断，当前请求是否允许访问。例如说，用户是否登录，是否有该API操作的权限等等。
* 限流拦截器，可以通过每个API接口的限流配置，进行判断判断，当前请求是否超过允许的请求频率，避免恶意的请求，打爆整个系统。

```java
/**
 * Spring MVC配置类
 */
@Slf4j
@Configuration
public class SpringMVCConfiguration implements WebMvcConfigurer {

    @Autowired
    public FirstInterceptor firstInterceptor() {
        return new FirstInterceptor();
    }

    @Autowired
    public SecondInterceptor secondInterceptor() {
        return new SecondInterceptor();
    }

    @Autowired
    public ThirdInterceptor thirdInterceptor() {
        return new ThirdInterceptor();
    }

    @Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截器一
        registry.addInterceptor(this.firstInterceptor()).addPathPatterns("/**");
        //拦截器二
        registry.addInterceptor(this.secondInterceptor()).addPathPatterns("/hello");
        //拦截器三
        registry.addInterceptor(this.thirdInterceptor()).addPathPatterns("/**");
    }
}
```



### 7.Servlet、Filter、Listener

有两种方式，配置Servlet、Filter、Listener。分别是：

* 通过Bean的方式。
* 通过注解的方式。

#### 7.1 通过Bean的方式

```java
/**
 * Spring MVC配置类
 */
@Slf4j
@Configuration
public class SpringMVCConfiguration implements WebMvcConfigurer {

    @Bean
    public ServletRegistrationBean testServlet01(){
        ServletRegistrationBean servletRegistrationBean = new ServletRegistrationBean<>(new HttpServlet() {
            @Override
            protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
                log.info("[doGet][uri: {}]", req.getRequestURI());
            }
        });
        servletRegistrationBean.setUrlMappings(Collections.singleton("/hello"));
        return servletRegistrationBean;
    }

    @Bean
    public FilterRegistrationBean testFilter01(){
        FilterRegistrationBean filterRegistrationBean = new FilterRegistrationBean<>(new Filter() {
            @Override
            public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
                log.info("[doFilter]");
                filterChain.doFilter(servletRequest,servletResponse);
            }
        });
        filterRegistrationBean.setUrlPatterns(Collections.singleton("/hello"));
        return filterRegistrationBean;
    }
    
    @Bean
    public ServletListenerRegistrationBean<?> testListener01(){
        return new ServletListenerRegistrationBean<>(new ServletContextListener() {
            @Override
            public void contextInitialized(ServletContextEvent sce) {
                log.info("[contextInitialized]");
            }

            @Override
            public void contextDestroyed(ServletContextEvent sce) {

            }
        });
    }
}
```

#### 7.2 通过注解的方式

在 Servlet3.0 的新特性里，提供了 [`@WebServlet`](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/annotation/WebServlet.java)、[`@WebFilter`](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/annotation/WebFilter.java)、[`@WebListener`](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/annotation/WebListener.java) 三个注解，方便配置 Servlet、Filter、Listener 。

而在 SpringBoot 中，我们仅需要在 Application 类上，添加 [`@ServletComponentScan`](https://github.com/spring-projects/spring-boot/blob/master/spring-boot-project/spring-boot/src/main/java/org/springframework/boot/web/servlet/ServletComponentScan.java) 注解，开启对 `@WebServlet`、`@WebFilter`、`@WebListener` 注解的扫描。不过要**注意**，当且仅当使用**内嵌**的 Web Server 才会生效。

```java
@WebServlet(urlPatterns = "/test/02")
public class TestServlet02 extends HttpServlet {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        logger.info("[doGet][uri: {}]", req.getRequestURI());
    }

}

@WebFilter("/test/*")
public class TestFilter02 implements Filter {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {
        logger.info("[doFilter]");
        filterChain.doFilter(servletRequest, servletResponse);
    }

}

@WebListener
public class TestServletContextListener02 implements ServletContextListener {

    private Logger logger = LoggerFactory.getLogger(getClass());

    @Override
    public void contextInitialized(ServletContextEvent sce) {
        logger.info("[contextInitialized]");
    }

    @Override
    public void contextDestroyed(ServletContextEvent sce) {
    }

}
```

### 8.Cors跨域

CORS是一个W3C标准，全称是"跨域资源共享"（Cross-origin resource sharing）。

它允许浏览器向跨源服务器，发出[`XMLHttpRequest`](http://www.ruanyifeng.com/blog/2012/09/xmlhttprequest_level_2.html)请求，从而克服了AJAX只能[同源](http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html)使用的限制。

#### 8.1 简介

CORS需要浏览器和服务器同时支持。目前，所有浏览器都支持该功能，IE浏览器不能低于IE10。

整个CORS通信过程，都是浏览器自动完成，不需要用户参与。对于开发者来说，CORS通信与同源的AJAX通信没有差别，代码完全一样。浏览器一旦发现AJAX请求跨源，就会自动添加一些附加的头信息，有时还会多出一次附加的请求，但用户不会有感觉。

因此，实现CORS通信的关键是服务器。只要服务器实现了CORS接口，就可以跨源通信。

#### 8.2 两种请求

浏览器将CORS请求分成两类：简单请求（simple request）和非简单请求（not-so-simple request）。

只要同时满足以下两大条件，就属于简单请求。

> （1) 请求方法是以下三种方法之一：
>
> - HEAD
> - GET
> - POST
>
> （2）HTTP的头信息不超出以下几种字段：
>
> - Accept
> - Accept-Language
> - Content-Language
> - Last-Event-ID
> - Content-Type：只限于三个值`application/x-www-form-urlencoded`、`multipart/form-data`、`text/plain`

这是为了兼容表单（form），因为历史上表单一直可以发出跨域请求。AJAX 的跨域设计就是，只要表单可以发，AJAX 就可以直接发。

凡是不同时满足上面两个条件，就属于非简单请求。

浏览器对这两种请求的处理，是不一样的。

#### 8.3 简单请求

##### 8.3.1 基本流程

对于简单请求，浏览器直接发出CORS请求。具体来说，就是在头信息之中，增加一个`Origin`字段。

下面是一个例子，浏览器发现这次跨源AJAX请求是简单请求，就自动在头信息之中，添加一个`Origin`字段。

> ```http
> GET /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面的头信息中，`Origin`字段用来说明，本次请求来自哪个源（协议 + 域名 + 端口）。服务器根据这个值，决定是否同意这次请求。

如果`Origin`指定的源，不在许可范围内，服务器会返回一个正常的HTTP回应。浏览器发现，这个回应的头信息没有包含`Access-Control-Allow-Origin`字段（详见下文），就知道出错了，从而抛出一个错误，被`XMLHttpRequest`的`onerror`回调函数捕获。注意，这种错误无法通过状态码识别，因为HTTP回应的状态码有可能是200。

如果`Origin`指定的域名在许可范围内，服务器返回的响应，会多出几个头信息字段。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Credentials: true
> Access-Control-Expose-Headers: FooBar
> Content-Type: text/html; charset=utf-8
> ```

上面的头信息之中，有三个与CORS请求相关的字段，都以`Access-Control-`开头。

**（1）Access-Control-Allow-Origin**

该字段是必须的。它的值要么是请求时`Origin`字段的值，要么是一个`*`，表示接受任意域名的请求。

**（2）Access-Control-Allow-Credentials**

该字段可选。它的值是一个布尔值，表示是否允许发送Cookie。默认情况下，Cookie不包括在CORS请求之中。设为`true`，即表示服务器明确许可，Cookie可以包含在请求中，一起发给服务器。这个值也只能设为`true`，如果服务器不要浏览器发送Cookie，删除该字段即可。

**（3）Access-Control-Expose-Headers**

该字段可选。CORS请求时，`XMLHttpRequest`对象的`getResponseHeader()`方法只能拿到6个基本字段：`Cache-Control`、`Content-Language`、`Content-Type`、`Expires`、`Last-Modified`、`Pragma`。如果想拿到其他字段，就必须在`Access-Control-Expose-Headers`里面指定。上面的例子指定，`getResponseHeader('FooBar')`可以返回`FooBar`字段的值。

##### 8.3.2 withCredentials 属性

上面说到，CORS请求默认不发送Cookie和HTTP认证信息。如果要把Cookie发到服务器，一方面要服务器同意，指定`Access-Control-Allow-Credentials`字段。

> ```http
> Access-Control-Allow-Credentials: true
> ```

另一方面，开发者必须在AJAX请求中打开`withCredentials`属性。

> ```javascript
> var xhr = new XMLHttpRequest();
> xhr.withCredentials = true;
> ```

否则，即使服务器同意发送Cookie，浏览器也不会发送。或者，服务器要求设置Cookie，浏览器也不会处理。

但是，如果省略`withCredentials`设置，有的浏览器还是会一起发送Cookie。这时，可以显式关闭`withCredentials`。

> ```javascript
> xhr.withCredentials = false;
> ```

需要注意的是，如果要发送Cookie，`Access-Control-Allow-Origin`就不能设为星号，必须指定明确的、与请求网页一致的域名。同时，Cookie依然遵循同源政策，只有用服务器域名设置的Cookie才会上传，其他域名的Cookie并不会上传，且（跨源）原网页代码中的`document.cookie`也无法读取服务器域名下的Cookie。

#### 8.4 非简单请求

##### 8.4.1 预检请求

非简单请求是那种对服务器有特殊要求的请求，比如请求方法是`PUT`或`DELETE`，或者`Content-Type`字段的类型是`application/json`。

非简单请求的CORS请求，会在正式通信之前，增加一次HTTP查询请求，称为"预检"请求（preflight）。

浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些HTTP动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的`XMLHttpRequest`请求，否则就报错。

下面是一段浏览器的JavaScript脚本。

> ```javascript
> var url = 'http://api.alice.com/cors';
> var xhr = new XMLHttpRequest();
> xhr.open('PUT', url, true);
> xhr.setRequestHeader('X-Custom-Header', 'value');
> xhr.send();
> ```

上面代码中，HTTP请求的方法是`PUT`，并且发送一个自定义头信息`X-Custom-Header`。

浏览器发现，这是一个非简单请求，就自动发出一个"预检"请求，要求服务器确认可以这样请求。下面是这个"预检"请求的HTTP头信息。

> ```http
> OPTIONS /cors HTTP/1.1
> Origin: http://api.bob.com
> Access-Control-Request-Method: PUT
> Access-Control-Request-Headers: X-Custom-Header
> Host: api.alice.com
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

"预检"请求用的请求方法是`OPTIONS`，表示这个请求是用来询问的。头信息里面，关键字段是`Origin`，表示请求来自哪个源。

除了`Origin`字段，"预检"请求的头信息包括两个特殊字段。

**（1）Access-Control-Request-Method**

该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法，上例是`PUT`。

**（2）Access-Control-Request-Headers**

该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段，上例是`X-Custom-Header`。

##### 8.4.2 预检请求的回应

服务器收到"预检"请求以后，检查了`Origin`、`Access-Control-Request-Method`和`Access-Control-Request-Headers`字段以后，确认允许跨源请求，就可以做出回应。

> ```http
> HTTP/1.1 200 OK
> Date: Mon, 01 Dec 2008 01:15:39 GMT
> Server: Apache/2.0.61 (Unix)
> Access-Control-Allow-Origin: http://api.bob.com
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Content-Type: text/html; charset=utf-8
> Content-Encoding: gzip
> Content-Length: 0
> Keep-Alive: timeout=2, max=100
> Connection: Keep-Alive
> Content-Type: text/plain
> ```

上面的HTTP回应中，关键的是`Access-Control-Allow-Origin`字段，表示`http://api.bob.com`可以请求数据。该字段也可以设为星号，表示同意任意跨源请求。

> ```http
> Access-Control-Allow-Origin: *
> ```

如果服务器否定了"预检"请求，会返回一个正常的HTTP回应，但是没有任何CORS相关的头信息字段。这时，浏览器就会认定，服务器不同意预检请求，因此触发一个错误，被`XMLHttpRequest`对象的`onerror`回调函数捕获。控制台会打印出如下的报错信息。

> ```bash
> XMLHttpRequest cannot load http://api.alice.com.
> Origin http://api.bob.com is not allowed by Access-Control-Allow-Origin.
> ```

服务器回应的其他CORS相关字段如下。

> ```http
> Access-Control-Allow-Methods: GET, POST, PUT
> Access-Control-Allow-Headers: X-Custom-Header
> Access-Control-Allow-Credentials: true
> Access-Control-Max-Age: 1728000
> ```

**（1）Access-Control-Allow-Methods**

该字段必需，它的值是逗号分隔的一个字符串，表明服务器支持的所有跨域请求的方法。注意，返回的是所有支持的方法，而不单是浏览器请求的那个方法。这是为了避免多次"预检"请求。

**（2）Access-Control-Allow-Headers**

如果浏览器请求包括`Access-Control-Request-Headers`字段，则`Access-Control-Allow-Headers`字段是必需的。它也是一个逗号分隔的字符串，表明服务器支持的所有头信息字段，不限于浏览器在"预检"中请求的字段。

**（3）Access-Control-Allow-Credentials**

该字段与简单请求时的含义相同。

**（4）Access-Control-Max-Age**

该字段可选，用来指定本次预检请求的有效期，单位为秒。上面结果中，有效期是20天（1728000秒），即允许缓存该条回应1728000秒（即20天），在此期间，不用发出另一条预检请求。

##### 8.4.3 浏览器的正常请求和回应

一旦服务器通过了"预检"请求，以后每次浏览器正常的CORS请求，就都跟简单请求一样，会有一个`Origin`头信息字段。服务器的回应，也都会有一个`Access-Control-Allow-Origin`头信息字段。

下面是"预检"请求之后，浏览器的正常CORS请求。

> ```http
> PUT /cors HTTP/1.1
> Origin: http://api.bob.com
> Host: api.alice.com
> X-Custom-Header: value
> Accept-Language: en-US
> Connection: keep-alive
> User-Agent: Mozilla/5.0...
> ```

上面头信息的`Origin`字段是浏览器自动添加的。

下面是服务器正常的回应。

> ```http
> Access-Control-Allow-Origin: http://api.bob.com
> Content-Type: text/html; charset=utf-8
> ```

上面头信息中，`Access-Control-Allow-Origin`字段是每次回应都必定包含的。

#### 8.5 与JSONP的比较

CORS与JSONP的使用目的相同，但是比JSONP更强大。

JSONP只支持`GET`请求，CORS支持所有类型的HTTP请求。JSONP的优势在于支持老式浏览器，以及可以向不支持CORS的网站请求数据。

#### 8.6 如何解决跨域

Nginx、网关服务都可以做统一配置处理。

Spring MVC解决跨域目前一共有三种方案：

1. 使用@CrossCors注解，配置每个API接口。
2. 使用CorsRegistry.java注册表，配置每个API接口。
3. 使用CorsFilter.java过滤器，处理跨域请求。

方案1和方案2本质上是相同的方案，只是配置方式不同。

##### 8.6.1 @CrossCors

`@CrossCors` 注解，添加在类或方法上，标记该类/方法对应接口的 Cors 信息。

`@CrossCors` 注解的**常用属性**，如下：

- `origins` 属性，设置允许的请求来源。`[]` 数组，可以填写多个请求来源。默认值为 `*` 。
- `value` 属性，和 `origins` 属性相同，是它的别名。
- `allowCredentials` 属性，是否允许客户端请求发送 Cookie 。默认为 `false` ，不允许请求发送 Cookie 。
- `maxAge` 属性，本次预检请求的有效期，单位为秒。默认值为 1800 秒。

`@CrossCors` 注解的**不常用属性**，如下：

- `methods` 属性，设置允许的请求方法。`[]` 数组，可以填写多个请求方法。默认值为 `GET` + `POST` 。
- `allowedHeaders` 属性，允许的请求头 Header 。`[]` 数组，可以填写多个请求来源。默认值为 `*` 。
- `exposedHeaders` 属性，允许的响应头 Header 。`[]` 数组，可以填写多个请求来源。默认值为 `*` 。

**坑**

在前端使用符合 CORS 规范的网络库时，例如说 Vue 常用的网络库 [axios](https://github.com/axios/axios) ，在发起[非简单请求](https://www.ruanyifeng.com/blog/2016/04/cors.html)时，会自动先先发起 `OPTIONS` “预检”请求，要求服务器确认是否能够这样请求。这样，这个请求就会被 SpringMVC 的拦截器所处理。

此时，如果我们的拦截器认为 `handler` **一定**是 HandlerMethod 类型时，就会导致报错。例如说，艿艿在 [UserSecurityInterceptor](https://github.com/YunaiV/onemall/blob/master/user/user-sdk/src/main/java/cn/iocoder/mall/user/sdk/interceptor/UserSecurityInterceptor.java) 拦截器中，会认为 `handler` 是 HandlerMethod 类型，然后通过它获得 `@RequiresLogin` 注解信息，判断是否需要登录。然后，实际上，此时 `handler` 是 [PreFlightHandler](https://github.com/spring-projects/spring-framework/blob/master/spring-webmvc/src/main/java/org/springframework/web/servlet/handler/AbstractHandlerMapping.java#L539-L558) 类型，则会导致抛出异常。如下图所示：![getCorsHandlerExecutionChain](http://www.iocoder.cn/images/Spring-Boot/2019-11-17/03.png)

此时，有两种解决方案：

- 1）检查每个拦截器的实现，是不是依赖于 `handler` 是 HandlerMethod 的逻辑，进行修复。
- 2）不使用该方案，而是采用 [「8.3 CorsFilter」](http://www.iocoder.cn/Spring-Boot/SpringMVC/?github#) 过滤器，避免 `OPTIONS` 预检查走到拦截器里。

显然，`1）` 的成本略微有点高，所以一般情况下，推荐 `2）` 。目前艿艿的项目，也是采用 [「8.3 CorsFilter」](http://www.iocoder.cn/Spring-Boot/SpringMVC/?github#) 过滤器的方式。

##### 8.6.2 CorsRegistry

显然，在每个 Controller 上配置 `@CrossOrigin` 注解，是挺麻烦一事。所以更多的情况下，我们会选择配置 CorsRegistry 注册表。

修改 [SpringMVCConfiguration](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-02/src/main/java/cn/iocoder/springboot/lab23/springmvc/config/SpringMVCConfiguration.java) 配置类，增加 CorsRegistry 相关的配置。代码如下：

```java
/**
 * Spring MVC配置类
 *
 * @author Corona
 */
@Slf4j
@Configuration
public class SpringMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 添加全局的 CORS 配置
        registry.addMapping("/**") // 匹配所有 URL ，相当于全局配置
                .allowedOrigins("*") // 允许所有请求来源
                .allowCredentials(true) // 允许发送 Cookie
                .allowedMethods("*") // 允许所有请求 Method
                .allowedHeaders("*") // 允许所有请求 Header
//                .exposedHeaders("*") // 允许所有响应 Header
                .maxAge(1800L); // 有效期 1800 秒，2 小时
    }
}

```

- 这里配置匹配的路径是 `/**` ，从而实现全局 CORS 配置。
- 如果想要配置单个路径的 CORS 配置，可以通过 `CorsRegistry#addMapping(String pathPattern)` 方法，继续往其中添加 CORS 配置。
- 如果胖友想要更安全，可以 `originns` 属性，只填写允许的前端域名地址。

这种方式，一样会存在 [「8.1 @CrossCors」](http://www.iocoder.cn/Spring-Boot/SpringMVC/?github#) 提供到的坑坑坑坑坑，因为这两者的实现方式是一致的。所以，继续看 [「8.3 CorsFilter」](http://www.iocoder.cn/Spring-Boot/SpringMVC/?github#) 方案。

##### 8.6.3 CorsFilter

在 [Spring Web](https://github.com/spring-projects/spring-framework/tree/master/spring-web) 中，内置提供 CorsFilter 过滤器，实现对 CORS 的处理。

配置方式很简单，既然是 Filter 过滤器，就可以采用 [「7.1 通过 Bean 的方式」](http://www.iocoder.cn/Spring-Boot/SpringMVC/?github#) ，进行配置。所以修改 [SpringMVCConfiguration](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-02/src/main/java/cn/iocoder/springboot/lab23/springmvc/config/SpringMVCConfiguration.java) 配置类，增加 CorsFilter 相关的配置。代码如下：

```java
/**
 * Spring MVC配置类
 *
 * @author Corona
 */
@Slf4j
@Configuration
public class SpringMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        // 添加全局的 CORS 配置
        registry.addMapping("/**") // 匹配所有 URL ，相当于全局配置
                .allowedOrigins("*") // 允许所有请求来源
                .allowCredentials(true) // 允许发送 Cookie
                .allowedMethods("*") // 允许所有请求 Method
                .allowedHeaders("*") // 允许所有请求 Header
//                .exposedHeaders("*") // 允许所有响应 Header
                .maxAge(1800L); // 有效期 1800 秒，2 小时
    }

    @Bean
    public FilterRegistrationBean<CorsFilter> corsFilter() {
        // 创建 UrlBasedCorsConfigurationSource 配置源，类似 CorsRegistry 注册表
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // 创建 CorsConfiguration 配置，相当于 CorsRegistration 注册信息
        CorsConfiguration config = new CorsConfiguration();
        config.setAllowedOrigins(Collections.singletonList("*")); // 允许所有请求来源
        config.setAllowCredentials(true); // 允许发送 Cookie
        config.addAllowedMethod("*"); // 允许所有请求 Method
        config.setAllowedHeaders(Collections.singletonList("*")); // 允许所有请求 Header
        // config.setExposedHeaders(Collections.singletonList("*")); // 允许所有响应 Header
        config.setMaxAge(1800L); // 有效期 1800 秒，2 小时
        source.registerCorsConfiguration("/**", config);
        // 创建 FilterRegistrationBean 对象
        FilterRegistrationBean<CorsFilter> bean = new FilterRegistrationBean<>(
                new CorsFilter(source)); // 创建 CorsFilter 过滤器
        bean.setOrder(0); // 设置 order 排序。这个顺序很重要哦，为避免麻烦请设置在最前
        return bean;
    }
}

```

### 9. HttpMessageConverter消息转换器

在SpringMVC中，可以使用@RequestBody和@ResponseBody两个注解，分别完成请求报文（内容）到对象和对象到响应报文（内容）的转换，底层这种灵活的消息转换机制，就是Spring3.x中新引入的HttpMessageConverter，即消息转换器机制。

在一些业务场景下，前端提交给后端 API 参数，比较复杂，那么可能我们希望能够使用 JSON 的格式，提交给后端 API 接口。此时，我们可以使用  [MappingJackson2HttpMessageConverter](https://github.com/spring-projects/spring-framework/blob/master/spring-web/src/main/java/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.java)消息转换器，将 JSON 字符串，转换成对应的对象。

#### 9.1 HttpMessageConverter

HttpMessageConverter源码：

```java
public interface HttpMessageConverter<T> {
        // 是否能够读取指定的 mediaType 内容类型，转换成对应的 clazz 对象
        boolean canRead(Class<?> clazz, @Nullable MediaType mediaType);
        // 读取请求内容，转换成 clazz 对象
        T read(Class<? extends T> clazz, HttpInputMessage inputMessage)
                    throws IOException, HttpMessageNotReadableException;

        // 是否能够将 clazz 对象，序列化成 mediaType 内容类型
        boolean canWrite(Class<?> clazz, @Nullable MediaType mediaType);
        // 将 clazz 对象，序列化成 contentType 内容类型，写入到响应。
        void write(T t, @Nullable MediaType contentType, HttpOutputMessage outputMessage)
                    throws IOException, HttpMessageNotWritableException;

        // 获得 HttpMessageConverter 能够支持的内容类型。
        List<MediaType> getSupportedMediaTypes();
}

```

MappingJackson2HttpMessageConverter 源码：

```java
public class MappingJackson2HttpMessageConverter extends AbstractJackson2HttpMessageConverter {
    @Nullable
    private String jsonPrefix;

    public MappingJackson2HttpMessageConverter() {
        this(Jackson2ObjectMapperBuilder.json().build());
    }

    public MappingJackson2HttpMessageConverter(ObjectMapper objectMapper) {
        //所以打上@RequestBody注解后 此消息转换器会自动帮忙解析
        super(objectMapper, new MediaType[]{MediaType.APPLICATION_JSON, new MediaType("application", "*+json")});
    }

    public void setJsonPrefix(String jsonPrefix) {
        this.jsonPrefix = jsonPrefix;
    }

    public void setPrefixJson(boolean prefixJson) {
        this.jsonPrefix = prefixJson ? ")]}', " : null;
    }

    protected void writePrefix(JsonGenerator generator, Object object) throws IOException {
        if (this.jsonPrefix != null) {
            generator.writeRaw(this.jsonPrefix);
        }

    }
}
```

- 在**请求**时，我们在请求头 `Content-Type` 上，表示请求内容（Request Body）的内容类型。这样，SpringMVC 会从自己的 HttpMessageConverter **数组**中，通过 `#canRead(clazz, mediaType)` 方法，判断是否够读取指定的 `mediaType` 内容类型，转换成对应的 `clazz` 对象。如果可以，则调用 `#read(Class<? extends T> clazz, HttpInputMessage inputMessage)` 方法，读取请求内容，转换成 `clazz` 对象。
- 在**响应**时，我们在请求头 `Accept` 上，表示请求内容（Response Body）的内容类型。这样，SpringMVC 会从自己的 HttpMessageConverter **数组**中，通过 `#canWrite(clazz, mediaType)` 方法，判断是否能够将 `clazz` 对象，序列化成 `mediaType` 内容类型。如果可以，则调用 `#write(contentType, outputMessage)` 方法， 将 `clazz` 对象，序列化成 `contentType` 内容类型，写入到响应。

#### 9.2 增加XML消息转换器

##### 9.2.1 引入依赖

在 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-02/pom.xml) 文件中，**额外**引入 [`jackson-dataformat-xml`](https://mvnrepository.com/artifact/com.fasterxml.jackson.dataformat/jackson-dataformat-xml) 依赖。如下：

```xml
<!-- 引入 jackson 对 xml 的转换器，实现对 XML 的序列化 -->
<dependency>
    <groupId>com.fasterxml.jackson.dataformat</groupId>
    <artifactId>jackson-dataformat-xml</artifactId>
</dependency>
```

##### 9.2.2 SpringMvcConfiguration

```java
/**
 * Spring MVC配置类
 *
 * @author Corona
 */
@Slf4j
@Configuration
public class SpringMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //增加XML消息转换器
        Jackson2ObjectMapperBuilder xmlBuilder = Jackson2ObjectMapperBuilder.xml();
        xmlBuilder.indentOutput(true);
        converters.add(new MappingJackson2XmlHttpMessageConverter(xmlBuilder.build()));
    }
}

```

##### 9.2.3 UserController

```java
package corona.springboot.controller;

import corona.springboot.service.IUserService;
import corona.springboot.vo.UserVO;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.MediaType;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/user")
public class UserController {

    @Autowired
    private IUserService userService;

    @PostMapping(value = "add",
            consumes = {MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_VALUE},
            produces = {MediaType.APPLICATION_XML_VALUE, MediaType.APPLICATION_JSON_VALUE}
    )
    public UserVO add(@RequestBody UserVO userVO) {
        return userVO;
    }
}
```

### 10. 整合Fastjson

在国内，我们可能希望使用Fastjson作为JSON默认的工具类，以提升JSON的反序列化和反序列化性能。在Fastjson中，已经内置提供[FastJsonHttpMessageConverter](https://github.com/alibaba/fastjson/blob/master/src/main/java/com/alibaba/fastjson/support/spring/FastJsonHttpMessageConverter.java) 消息转换器，方便我们替换 SpringMVC 默认的 HttpMessageConverter 。

#### 10.1 引入依赖

在 [`pom.xml`](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-23/lab-springmvc-23-02/pom.xml) 文件中，**额外**引入 [`fastjson`](https://mvnrepository.com/artifact/com.alibaba/fastjson) 依赖。如下：

```xml
<!-- 引入 Fastjson ，实现对 JSON 的序列化 -->
<dependency>
    <groupId>com.alibaba</groupId>
    <artifactId>fastjson</artifactId>
    <version>1.2.62</version>
</dependency>
```

#### 10.2 SpringMvcConfiguration

```java
/**
 * Spring MVC配置类
 *
 * @author Corona
 */
@Slf4j
@Configuration
public class SpringMvcConfiguration implements WebMvcConfigurer {

    @Override
    public void configureMessageConverters(List<HttpMessageConverter<?>> converters) {
        //增加XML消息转换器
        Jackson2ObjectMapperBuilder xmlBuilder = Jackson2ObjectMapperBuilder.xml();
        xmlBuilder.indentOutput(true);
        converters.add(new MappingJackson2XmlHttpMessageConverter(xmlBuilder.build()));

        //创建 FastJsonHttpMessageConverter 对象
        FastJsonHttpMessageConverter fastJsonHttpMessageConverter = new FastJsonHttpMessageConverter();

        //自定义FastJson配置
        FastJsonConfig fastJsonConfig = new FastJsonConfig();
        fastJsonConfig.setCharset(Charset.defaultCharset()); // 设置字符集
        fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect); // 剔除循环引用
        fastJsonHttpMessageConverter.setFastJsonConfig(fastJsonConfig);
        // 设置支持的 MediaType
        fastJsonHttpMessageConverter.setSupportedMediaTypes(Arrays.asList(MediaType.APPLICATION_JSON,
                MediaType.APPLICATION_JSON_UTF8));
        // 添加到 converters 中
        // 注意，添加到最开头，放在 MappingJackson2XmlHttpMessageConverter 前面
        converters.add(0, fastJsonHttpMessageConverter);
    }
}

```

## 第六章 Spring Boot分布式Session入门

### 1. 概述

在考虑高性能之前，一定要做高可用。

Session的一致性，简单来理解，就是相同sessionid在多个web容器下，Session的数据要一致。

为了解决Session不一致，一般来说，有三种方案：

1. Session黏连：使用Nginx实现会话黏连，将相同sessionid的浏览器所发起的请求，转发到同一台服务器。这样，就不会存在多个web服务器创建多个session的情况，也就不会发生session不一致的问题。不过，这种方式目前基本不被采用，因为，如果一台服务器重启，那么会导致转发到这个服务器上的session全部丢失。具体怎么实现这种方式，可以看看 [《Nginx 第三方模块 —— nginx-sticky-module 的使用（基于cookie的会话保持）》](https://blog.csdn.net/bigtree_3721/article/details/78007853) 文章。
2. Session复制：Web服务器之间，进行Session复制同步，仅仅适用于实现Session复制的Web容器，例如说Tomcat，Weblogic等等。不过，这种方式目前基本也不被采用，试想一下，如果我们有5台Web服务器，所有的Session都要同步到每一个节点上，一个是效率低，一个是浪费内存。
3. Session外部化存储：Session外部化存储，考虑不再采用Web容器的内存中存储Session，而是将Session存储外部化，持久化到MySQL、Redis、MongoDN等等数据库中，这样，Tomcat就可以无状态化，专注提供Web服务器或者API接口，未来扩展也变得更加容易。

实现Session外部化存储有两种方式：

1. 基于Tomcat、Jetty等Web容器自带的扩展，使用读取外部存储器的Session管理器。例如说：

- [《Redisson Tomcat会话管理器（Tomcat Session Manager）》](https://github.com/redisson/redisson/wiki/14.-第三方框架整合#146-spring-session会话管理器) ，实现将 Tomcat 使用 Redis 存储 Session 。
- [《Jetty 集群配置 Session 存储到 MySQL、MongoDB》](https://blog.csdn.net/xiao__gui/article/details/43271509) ，实现 Jetty 使用 MySQL、MongoDB 存储 Session 。

2. 基于应用层封装 [HttpServletRequest](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/http/HttpServletRequest.java) 请求对象，包装成自己的 RequestWrapper 对象，从而让实现调用 [`HttpServletRequest#getSession()`](https://github.com/javaee/servlet-spec/blob/master/src/main/java/javax/servlet/http/HttpServletRequest.java#L542-L581) 方法时，获得读写外部存储器的 SessionWrapper 对象。例如说，稍后我们会看到的本文的主角 [Spring Session](https://spring.io/projects/spring-session) 。

Spring Session 提供了 [SessionRepositoryFilter](https://github.com/spring-projects/spring-session/blob/master/spring-session-core/src/main/java/org/springframework/session/web/http/SessionRepositoryFilter.java) 过滤器，它会过滤请求时，将请求 HttpServletRequest 对象包装成 [SessionRepositoryRequestWrapper](https://github.com/spring-projects/spring-session/blob/master/spring-session-core/src/main/java/org/springframework/session/web/http/SessionRepositoryFilter.java#L192-L418) 对象。代码如下：

```java
// SessionRepositoryFilter.java

protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain filterChain) throws ServletException, IOException {
    // sessionRepository 是访问外部数据源的操作类，例如说访问 Redis、MySQL 等等
    request.setAttribute(SESSION_REPOSITORY_ATTR, this.sessionRepository);
    

    // 将请求和响应进行包装成 SessionRepositoryRequestWrapper 和 SessionRepositoryResponseWrapper 对象
    SessionRepositoryFilter<S>.SessionRepositoryRequestWrapper wrappedRequest = new SessionRepositoryFilter.SessionRepositoryRequestWrapper(request, response, this.servletContext);
    SessionRepositoryFilter.SessionRepositoryResponseWrapper wrappedResponse = new SessionRepositoryFilter.SessionRepositoryResponseWrapper(wrappedRequest, response);

    // 继续执行下一个过滤器
    try {
        filterChain.doFilter(wrappedRequest, wrappedResponse);
    } finally {
        // 请求结束，提交 Session 到外部数据源
        wrappedRequest.commitSession();
    }

}
```

* 调用 [`SessionRepositoryRequestWrapper#getSession()`](https://github.com/spring-projects/spring-session/blob/master/spring-session-core/src/main/java/org/springframework/session/web/http/SessionRepositoryFilter.java#L325-L328) 方法时，返回的是自己封装的 [HttpSessionWrapper](https://github.com/spring-projects/spring-session/blob/master/spring-session-core/src/main/java/org/springframework/session/web/http/SessionRepositoryFilter.java#L375-L390) 对象。代码如下：

```java
// SessionRepositoryFilter#SessionRepositoryRequestWrapper.java

	@Override
	public HttpSessionWrapper getSession() {
		return getSession(true);
	}
```

- 后续，我们调用 HttpSessionWrapper 的方法，例如说 `HttpSessionWrapper#setAttribute(String name, Object value)` 方法，访问的就是外部数据源，而不是内存中。

当然 ① 和 ② 两种方案思路是类似且一致的，只是说拓展的提供者和位置不同。

### 2. Spring Session

Spring Session 提供了用于管理用户会话信息的 API 和实现。

- `HttpSession` - 允许以通用的方式替换应用程序容器(即 Tomcat)中的 HttpSession ，并支持在请求头(Header)中提供 sessionid ，方便提供 RESTful API 。
- `WebSocket` - 提供在接收 WebSocket 消息时保持 HttpSession 活跃的能力。😈 不然，HttpSession 就过期失效了。
- `WebSession` - 允许以与应用程序容器无关的方式替换 Spring WebFlux 的 WebSession 。

- 可以使用 Redis、JDBC（访问 MySQL、Oracle 等数据库）、Hazelcast 作为 Session 存储的数据源。
- 同时 Spring Session 也另外提供了 [Spring Session MongoDB](https://spring.io/projects/spring-session-data-mongodb) ，实现使用 MongoDB 作为 Session 存储的数据源。

### 3. 快速入门Spring Session + Redis

在config包路径下，创建SessionConfiguration类，自定义Spring Session Redis的配置。

```java
/**
 * 自动化配置 Spring Session 使用 Redis 作为数据源
 *
 * @author Corona
 */
@Configuration
@EnableRedisHttpSession
public class SessionConfiguration {

    /**
     * 创建 {@link org.springframework.session.data.redis.RedisOperationsSessionRepository} 使用的 RedisSerializer Bean 。
     *
     * 具体可以看看 {@link org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration#setDefaultRedisSerializer(RedisSerializer)} 方法，
     * 它会引入名字为 "springSessionDefaultRedisSerializer" 的 Bean 。
     *
     * @return RedisSerializer Bean
     */
    @Bean(name = "springSessionDefaultRedisSerializer")
    public RedisSerializer springSessionDefaultRedisSerializer(){
        return RedisSerializer.json();
    }

}
```

在类上，添加 [`@EnableRedisHttpSession`](https://github.com/spring-projects/spring-session/blob/master/spring-session-data-redis/src/main/java/org/springframework/session/data/redis/config/annotation/web/http/EnableRedisHttpSession.java) 注解，开启自动化配置 Spring Session 使用 Redis 作为数据源。该注解有如下属性：

- `maxInactiveIntervalInSeconds` 属性，Session 不活跃后的过期时间，默认为 1800 秒。
- `redisNamespace` 属性，在 Redis 的 key 的统一前缀，默认为 `"spring:session"` 。
- `redisFlushMode` 属性，Redis 会话刷新模式(RedisFlushMode)。目前有两种，默认为RedisFlushMode.ON_SAVE
  - `RedisFlushMode.ON_SAVE` ，在请求执行完成时，统一写入 Redis 存储。
  - `RedisFlushMode.IMMEDIATE` ，在每次修改 Session 时，立即写入 Redis 存储。

- `cleanupCron` 属性，清理 Redis Session 会话过期的任务执行 CRON 表达式，默认为 `"0 * * * * *"` 每分钟执行一次。虽然说，Redis 自带了 key 的过期，但是惰性删除策略，实际过期的 Session 还在 Redis 中占用内存。所以，Spring Session 通过定时任务，删除 Redis 中过期的 Session ，尽快释放 Redis 的内存。不了解 Redis 的删除过期 key 的策略的胖友，可以看看 [《Redis 中删除过期 Key 的三种策略》](https://blog.csdn.net/a_bang/article/details/52986935/) 文章。

* 在 `#springSessionDefaultRedisSerializer()` 方法，定义了一个 Bean 名字为 `"springSessionDefaultRedisSerializer"` 的 RedisSerializer Bean ，采用 JSON 序列化方式。因为默认情况下，采用 [Java 自带的序列化方式](https://juejin.im/post/5ce3cdc8e51d45777b1a3cdf) ，可读性很差，所以进行替换

1. 在浏览器中，访问get_all接口，返回目前的session的内容，响应结果如下：

```
{}
```

2. 终端执行redis-cli命令，连接到Redis中，查看是否创建了一个Session，过程如下：

```shell
127.0.0.1:6379> scan 0
1) "0"
2) 1) "spring:session:corona:sessions:expires:5b6433ac-d158-4e97-b801-7a2c00663e9a"
   2) "spring:session:corona:expirations:1609061040000"  //是为了获得每分钟需要过期的 sessionid 集合，即 {时间戳} 是每分钟的时间戳
   3) "spring:session:corona:sessions:5b6433ac-d158-4e97-b801-7a2c00663e9a" //负责真正存储Session数据
```

每一个 Session 对应 Redis 三个 key-value 键值对。

- 开头：以 `spring:session` 开头，可以通过 `@EnableRedisHttpSession` 注解的 `redisNamespace` 属性配置。
- 结尾：以对应 Session 的 sessionid 结尾。
- 中间：中间分别是 `"sessions"`、`"expirations"`、`sessions:expires` 。**一般情况下，我们只需要关注中间为 `"sessions"` 的 key-value 键值对即可，它负责真正存储 Session 数据。**对于中间为 `"sessions:expires"` 和 `"expirations"` 的两个来说，主要为了实现主动删除 Redis 过期的 Session 会话，解决 Redis 惰性删除的“问题”。具体的实现原理，本文就不赘述，感兴趣的胖友，可以看看 [《从 Spring-Session 源码看 Session 机制的实现细节》](http://www.iocoder.cn/Spring-Session/laoxu/spring-session-4/?self) 文章。

```shell
127.0.0.1:6379> HGETALL spring:session:corona:sessions:5b6433ac-d158-4e97-b801-7a2c00663e9a
1) "lastAccessedTime" #最后访问时间
2) "1609059528676"
3) "maxInactiveInterval" #Session 允许最大不活跃时长，单位：秒
4) "1800"
5) "creationTime" #创建时间
6) "1609059201028"
127.0.0.1:6379> ttl spring:session:corona:sessions:5b6433ac-d158-4e97-b801-7a2c00663e9a
(integer) 2081  # 虽然说，Spring Session Redis 实现了主动删除，但是并不妨碍这里也使用 Redis 自动过期策略。
```

然后调用两次接口：

```shell
127.0.0.1:6379> HGETALL spring:session:corona:sessions:5b6433ac-d158-4e97-b801-7a2c00663e9a
 1) "lastAccessedTime"
 2) "1609059704665"
 3) "maxInactiveInterval"
 4) "1800"
 5) "creationTime"
 6) "1609059201028"
 7) "sessionAttr:corona"
 8) "\"eeiy\""
 9) "sessionAttr:eeiy"
10) "\"corona\""
```

- 我们调用 `HttpSession#setAttribute(String name, Object value)` 方法，设置的每一个 key-value 键值对，对应到 Redis hash 数据结构中的一个 **key** 。考虑到毕竟 key 冲突，使用 `"sessionAttr:"` 开头。

### 4. 自定义sessionId

在Spring Session中，我们可以通过自定义HttpSessionResolver Bean，设置sessionId请求和响应时所在的地方，目前有两种实现，也就是说提供两种策略：

* CookieHttpSessionIdResolver，sessionId存放在Cookie中。
* HeaderHttpSessionIdResolver，sessionId存放在Header之中。

#### 4.1 CookieHttpSessionIdResolver

默认情况下，Spring Session产生的sessionId的key为“SESSION”。

自定义key可以通过自定义CookieHttpSessionIdResolver Bean来实现：

```java
/**
 * 自动化配置 Spring Session 使用 Redis 作为数据源
 *
 * @author Corona
 */
@Configuration
@EnableRedisHttpSession(redisNamespace = "spring:session:corona")
public class SessionConfiguration {

    /**
     * 创建 {@link org.springframework.session.data.redis.RedisOperationsSessionRepository} 使用的 RedisSerializer Bean 。
     *
     * 具体可以看看 {@link org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration#setDefaultRedisSerializer(RedisSerializer)} 方法，
     * 它会引入名字为 "springSessionDefaultRedisSerializer" 的 Bean 。
     *
     * @return RedisSerializer Bean
     */
    @Bean(name = "springSessionDefaultRedisSerializer")
    public RedisSerializer springSessionDefaultRedisSerializer(){
        return RedisSerializer.json();
    }

    @Bean
    public CookieHttpSessionIdResolver sessionIdResolver(){
        //创建CookieHttpSessionIdResolver
        CookieHttpSessionIdResolver sessionIdResolver = new CookieHttpSessionIdResolver();

        //创建DefaultCookieSerializer对象
        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
        sessionIdResolver.setCookieSerializer(cookieSerializer);//设置到sessionIdResolver中
        cookieSerializer.setCookieName("JSESSIONID");
        return sessionIdResolver;
    }
}
```

- 我们可以看到，DefaultCookieSerializer 是 CookieHttpSessionIdResolver 的一个属性，通过它来完成在 Cookie 中的 sessionid 的读取和写入。

#### 4.2 HeaderHttpSessionIdResolver

当我们希望 session 存放在 **Header** 之中时，我们可以通过自定义 CookieHttpSessionIdResolver Bean 来实现。代码如下：

```java
package corona.springboot.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.redis.serializer.RedisSerializer;
import org.springframework.session.data.redis.config.annotation.web.http.EnableRedisHttpSession;
import org.springframework.session.web.http.HeaderHttpSessionIdResolver;

/**
 * 自动化配置 Spring Session 使用 Redis 作为数据源
 *
 * @author Corona
 */
@Configuration
@EnableRedisHttpSession(redisNamespace = "spring:session:corona")
public class SessionConfiguration {

    /**
     * 创建 {@link org.springframework.session.data.redis.RedisOperationsSessionRepository} 使用的 RedisSerializer Bean 。
     * <p>
     * 具体可以看看 {@link org.springframework.session.data.redis.config.annotation.web.http.RedisHttpSessionConfiguration#setDefaultRedisSerializer(RedisSerializer)} 方法，
     * 它会引入名字为 "springSessionDefaultRedisSerializer" 的 Bean 。
     *
     * @return RedisSerializer Bean
     */
    @Bean(name = "springSessionDefaultRedisSerializer")
    public RedisSerializer springSessionDefaultRedisSerializer() {
        return RedisSerializer.json();
    }

//    @Bean
//    public CookieHttpSessionIdResolver sessionIdResolver(){
//        //创建CookieHttpSessionIdResolver
//        CookieHttpSessionIdResolver sessionIdResolver = new CookieHttpSessionIdResolver();
//
//        //创建DefaultCookieSerializer对象
//        DefaultCookieSerializer cookieSerializer = new DefaultCookieSerializer();
//        sessionIdResolver.setCookieSerializer(cookieSerializer);//设置到sessionIdResolver中
//        cookieSerializer.setCookieName("JSESSIONID");
//        return sessionIdResolver;
//    }

    @Bean
    public HeaderHttpSessionIdResolver sessionIdResolver() {
        return new HeaderHttpSessionIdResolver("token");
    }
}

```

浏览器随便访问一个接口：

![image-20201227172853772](C:\Users\12272\AppData\Roaming\Typora\typora-user-images\image-20201227172853772.png)

我们可以看到确实响应的 Header 中有 `"token"` 的返回。

后续，前端在请求后端 API 接口时，也需要在请求的 Header 为 `"token"` 上，带上该 sessionid 值。

### 5.总结

实际项目中，相信大多数胖友基本没有使用过 Spring Session 。艿艿自己也去问了一些老友，大概 10 来个，只有一个在很久以前的项目中使用过。

那么，如果我们抛开 Spring Session ，而单纯谈论 Session ，是否大家项目中有在使用 Session 呢？艿艿又去问了这圈老友，估计要被我烦死了，哈哈哈哈，貌似使用 Session 的人也并不多。

又去知乎上搜了和 Session 相关的讨论，发现了 [《Session 正在被淘汰吗？》](https://www.zhihu.com/question/315397046) 文章，发现确实大家的观点比较接近，Session 慢慢不再被项目中采用。这是为什么呢？艿艿也来谈谈自己的观点。

在过去，客户端一般来说主要就是浏览器，而现在客户端可以是 PC 浏览器、Mobile 浏览器、微信小程序、iOS 又或者 Android 客户端。而 sessionid 的机制，是将当前客户端和服务端的 Session 会话进行绑定。现在，用户会使用多个客户端，这个是目的非常常见的情况。那么，一个用户在多个客户端，会有多个 sessionid ，和服务端的多个 Session 会话进行绑定。

我们以购物车的场景举例子，毕竟大家都爱买买买。用户在 PC 浏览器上，添加商品到购物车中，我们选择将该信息存储到 Session 中。那么，如果此时用户在微信小程序中打开购物车，是看不到这个商品的。因为，该用户的 PC 浏览器和微信小程序对应两个不同的 Session 。

显然，这个现象在这个年代，是无法被接受的，测试小姐姐跳起来就给你一个 BUG 。不过，如果胖友对很久以前的电商的购物车功能有印象的话，这个现象非常常见。

这个时候，我们的选择，一般是将添加商品到购物车的信息缓存到 Redis 中。这样，用户在多个客户端就能查看到这个商品了。

现在，基本绝大多数会话信息，都是希望做到用户级别的共享，那么 Session 的定位就非常尴尬，慢慢的都被拆分到 Redis 缓存中。所以，也就慢慢出现了 [《Session 正在被淘汰吗？》](https://www.zhihu.com/question/315397046) 的声音。

同时，因为 sessionid 可以和服务端的 Session 会话进行绑定，所以用户在登录之后，sessionid 我们就可以作为用户的身份标识。而现在，OAuth2 和 JWT 慢慢普及开来，大家越来越倾向使用这两者取代 sessionid 。

艿艿的话，倾向功能强大的 OAuth2 。为什么呢？现在都是长会话，用户登录后，保持 30 天有效。

- 那么 OAuth2 相比 sessionid 来说，每次请求带的是 accessToken 访问令牌，过期时间是 2 小时，万一泄露也最多是 2 小时。而 sessionid 泄露是“永久”，因为可以不断活跃，刷新会话的过期时间。😈 当然，机智的胖友可能会问，OAuth2 万一泄露的是 refreshToken 刷新令牌呢？那可能有点危险，不过因为 refreshToken 并不会每次请求都带着，所以泄露的几率会大大降低。
- 那么 OAuth2 相比 JWT 来说，因为 JWT 是无状态的 Token ，所以无法实现服务端级的严谨的 Token 过期策略。例如说，用户登出 Token 失效，又或者用户修改密码 Token 失效。因此，虽然说 OAuth2 需要引入借助外部存储器来存储状态，但是带来的好处不言而喻。同时，OAuth2 提供了四种认证方式，也为未来的业务拓展提供了更多的可能性。

不过呢，也不能说 Session 还是有很多使用场景的。

- 对于管理后台来说，一般只有 PC 端，基本不太存在多 Session 共享的烦恼。
- 也可以只使用 sessionid 作为身份标识，而会话信息存储到 Redis 当中。这样，sessionid 就有点像是一个单纯的 Token 。

😈 关于这块的观点，欢迎一起讨论。

> 艿艿：还有两点可以补充下，这里就简单说下。
>
> 前后端分离后，一些临时状态交给前端处理即可。例如说，登录后的回调地址，无需在放在 Session 之中了。
>
> 微服务拆分之后，如果在 Session 存储会话信息，就显得太重，因为一些信息并不是所有服务都需要，所以需要经过一定拆分，存储到 Redis 当中。

另外，可能有同学会想问 Spring Session 是否能够和 Spring Security OAuth2 做集成呢？目前看下来，是暂时不支持，可以看看 Spring Session 下的 https://github.com/spring-projects/spring-session/issues/149 讨论。

## 第七章 Spring Boot API 接口文档Swagger入门

### 1.概述

**Swagger** 。通过在 API 接口上，添加相应的 Swagger 提供的注解，自动生成 API 文档。

### 2.快速入门 Swagger

#### 2.1 引入依赖

```xml
<!-- 引入 Swagger 依赖 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger2</artifactId>
    <version>2.9.2</version>
</dependency>

<!-- 引入 Swagger UI 依赖，以实现 API 接口的 UI 界面 -->
<dependency>
    <groupId>io.springfox</groupId>
    <artifactId>springfox-swagger-ui</artifactId>
    <version>2.9.2</version>
</dependency>
```

#### 2.2 SwaggerConfiguration

```java
/**
 * swagger配置类
 *
 * @author Corona
 * @date 2020-12-27
 */
@Configuration
@EnableSwagger2
public class SwaggerConfiguration {

    @Bean
    public Docket createRestApi() {
        // 创建 Docket 对象
        return new Docket(DocumentationType.SWAGGER_2) // 文档类型，使用 Swagger2
                .apiInfo(this.apiInfo()) // 设置 API 信息
                // 扫描 Controller 包路径，获得 API 接口
                .select()
                .apis(RequestHandlerSelectors.basePackage("corona.springboot.controller"))
                .paths(PathSelectors.any())
                // 构建出 Docket 对象
                .build();
    }

    /**
     * 创建 API 信息
     */
    private ApiInfo apiInfo() {
        return new ApiInfoBuilder()
                .title("测试接口文档示例")
                .description("我是一段描述")
                .version("1.0.0") // 版本号
                .contact(new Contact("Corona", "http://www.yasina.top", "1227216685@qq.com")) // 联系人
                .build();
    }

}
```

### 3. Swagger UI界面

#### 3.1 引入依赖

```xml
<!-- 1. swagger-bootstrap-ui 目前改名为 knife4j -->
<!-- 2. 实现 swagger-bootstrap-ui 的自动化配置  -->
<!-- 3. 因为 knife4j-spring 已经引入 Swagger 依赖，所以无需重复引入 -->
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring</artifactId>
    <version>1.9.6</version>
</dependency>
<dependency>
    <groupId>com.github.xiaoymin</groupId>
    <artifactId>knife4j-spring-ui</artifactId>
    <version>1.9.6</version>
</dependency>
```

### 4. 更强大的YApi

我们引入了 YApi 接口管理平台，形成了我们 Swagger + YApi + Axure 标记的整体方案。大体就是酱紫。深夜 02:16 了，结束今天的哔哔，迎接明天的哔哔。

## 第八章 Spring Boot参数校验Validation入门

### 1.概述

实现Bean Validation规范的数据校验框架，主要有：

Hibernate Validator

### 2.注解

#### 2.1 Bean Validation定义的约束注解

[`javax.validation.constraints`](https://github.com/eclipse-ee4j/beanvalidation-api/tree/master/src/main/java/javax/validation/constraints) 包下，定义了一系列的约束( constraint )注解。如下：

> 参考 [《JSR 303 - Bean Validation 介绍及最佳实践》](https://www.ibm.com/developerworks/cn/java/j-lo-jsr303/index.html) 博客。
>
> 一共 22 个注解，快速略过即可。

- 空和非空检查
  - `@NotBlank` ：只能用于字符串不为 `null` ，并且字符串 `#trim()` 以后 length 要大于 0 。
  - `@NotEmpty` ：集合对象的元素不为 0 ，即集合不为空，也可以用于字符串不为 `null` 。
  - `@NotNull` ：不能为 `null` 。
  - `@Null` ：必须为 `null` 。
- 数值检查
  - `@DecimalMax(value)` ：被注释的元素必须是一个数字，其值必须小于等于指定的最大值。
  - `@DecimalMin(value)` ：被注释的元素必须是一个数字，其值必须大于等于指定的最小值。
  - `@Digits(integer, fraction)` ：被注释的元素必须是一个数字，其值必须在可接受的范围内。
  - `@Positive` ：判断正数。
  - `@PositiveOrZero` ：判断正数或 0 。
  - `@Max(value)` ：该字段的值只能小于或等于该值。
  - `@Min(value)` ：该字段的值只能大于或等于该值。
  - `@Negative` ：判断负数。
  - `@NegativeOrZero` ：判断负数或 0 。
- Boolean 值检查
  - `@AssertFalse` ：被注释的元素必须为 `true` 。
  - `@AssertTrue` ：被注释的元素必须为 `false` 。
- 长度检查
  - `@Size(max, min)` ：检查该字段的 `size` 是否在 `min` 和 `max` 之间，可以是字符串、数组、集合、Map 等。
- 日期检查
  - `@Future` ：被注释的元素必须是一个将来的日期。
  - `@FutureOrPresent` ：判断日期是否是将来或现在日期。
  - `@Past` ：检查该字段的日期是在过去。
  - `@PastOrPresent` ：判断日期是否是过去或现在日期。
- 其它检查
  - `@Email` ：被注释的元素必须是电子邮箱地址。
  - `@Pattern(value)` ：被注释的元素必须符合指定的正则表达式。

#### 2.2 Hibernate Validator附加的约束注解

[`org.hibernate.validator.constraints`](https://github.com/hibernate/hibernate-validator/tree/master/engine/src/main/java/org/hibernate/validator/constraints) 包下，定义了一系列的约束( constraint )注解。如下：

- `@Range(min=, max=)` ：被注释的元素必须在合适的范围内。
- `@Length(min=, max=)` ：被注释的字符串的大小必须在指定的范围内。
- `@URL(protocol=,host=,port=,regexp=,flags=)` ：被注释的字符串必须是一个有效的 URL 。
- `@SafeHtml` ：判断提交的 HTML 是否安全。例如说，不能包含 javascript 脚本等等。

#### 2.3 @Valid和@Validated

[`@Valid`](https://docs.oracle.com/javaee/7/api/javax/validation/Valid.html) 注解，是 Bean Validation 所定义，可以添加在普通方法、构造方法、方法参数、方法返回、成员变量上，表示它们需要进行约束校验。

[`@Validated`](https://github.com/spring-projects/spring-framework/blob/master/spring-context/src/main/java/org/springframework/validation/annotation/Validated.java) 注解，是 Spring Validation 锁定义，可以添加在类、方法参数、普通方法上，表示它们需要进行约束校验。同时，`@Validated` 有 `value` 属性，支持分组校验。属性如下：

```
// Validated.java

Class<?>[] value() default {};
```

对于初学的胖友来说，很容易搞混 `@Valid` 和 `@Validated` 注解。

**① 声明式校验**

Spring Validation **仅**对 `@Validated` 注解，实现声明式校验。

**② 分组校验**

Bean Validation 提供的 `@Valid` 注解，因为没有分组校验的属性，所以无法提供分组校验。此时，我们只能使用 ``@Validated` 注解。

**③ 嵌套校验**

相比来说，`@Valid` 注解的地方，多了【成员变量】。这就导致，如果有嵌套对象的时候，只能使用 `@Valid` 注解。例如说：

```
// User.java
public class User {
    
    private String id;

    @Valid
    private UserProfile profile;

}

// UserProfile.java
public class UserProfile {

    @NotBlank
    private String nickname;

}
```

- 如果不在 `User.profile` 属性上，添加 `@Valid` 注解，就会导致 `UserProfile.nickname` 属性，不会进行校验。

当然，`@Valid` 注解的地方，也多了【构造方法】和【方法返回】，所以在有这方面的诉求的时候，也只能使用 `@Valid` 注解。

**🔥 总结**

总的来说，绝大多数场景下，我们使用 `@Validated` 注解即可。

而在有嵌套校验的场景，我们使用 `@Valid` 注解添加到成员属性上。

相比在 Controller 添加参数校验来说，在 Service 进行参数校验，会更加安全可靠。艿艿个人建议的话，Controller 的参数校验可以不做，**Service 的参数校验一定要做**。

## 第九章 Spring Boot WebSocket入门

### 1.概述

#### 1.1 WebSocket概述

相对HTTP协议，WebSocket协议重点提供了服务端主动向客户端发送数据的能力，这样就可以完成实时性较高的需求，比如聊天IM即时通讯功能、消息订阅服务、网页游戏等。

同时，因为WebSocket使用TCP通信，可以避免重复创建连接，提升通信质量和效率。例如说，美团的长连接服务，具体可以看看 [《美团点评移动网络优化实践》](https://tech.meituan.com/2017/03/17/shark-sdk.html) 。

WebSocket相比普通的Socket来说，仅仅是借助HTTP协议完成握手，创建连接。后续的所有通信，都和HTTP协议无关。

每个WebSocket连接都始于一个HTTP请求。
具体来说，WebSocket协议在第一次握手连接时，通过HTTP协议在传送WebSocket支持的版本号，协议的字版本号，原始地址，主机地址等等一些列字段给服务器端：

```http
GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key:dGhlIHNhbXBsZSBub25jZQ==
Origin: http://example.com
Sec-WebSocket-Version: 13
```

注意，关键的地方是，这里面有个Upgrade首部，用来把当前的HTTP请求升级到WebSocket协议，这是HTTP协议本身的内容，是为了扩展支持其他的通讯协议。
如果服务器支持新的协议，则必须返回101：

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept:s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

至此，HTTP请求物尽其用，如果成功出发onopen事件，否则触发onerror事件，后面的传输则不再依赖HTTP协议。

第一，WebSocket设计上就是天生为HTTP增强通信（全双工通信等），所以在HTTP协议连接的基础上是很自然的一件事，并因此而能获得HTTP的诸多便利。
第二，这诸多便利中有一条很重要，基于HTTP连接将获得最大的一个兼容支持，比如即使服务器不支持WebSocket也能建立HTTP通信，只不过返回的是onerror而已，这显然比服务器无响应要好的多。

[《WebSocket 教程》](https://www.ruanyifeng.com/blog/2017/05/websocket.html)

在实现提供WebSocket服务的项目中，一般有如下几种解决方案：

* 方案一：Spring WebSocket
* 方案二：Tomcat WebSocket
* 方案三：STOMP WebSocket
* 方案四：NETTY WebSocket

#### 1.2  轮询（polling）和Comet（长轮询和流技术）概述

随着互联网的发展，传统的HTTP协议已经很难满足Web应用日益复杂的需求了。近年来，随着HTML5的诞生，WebSocket协议被提出，它实现了浏览器与服务器的全双工通信，扩展了浏览器与服务端的通信功能，使服务端也能主动向客户端发送数据。

　　我们知道，传统的HTTP协议是无状态的，每次请求（request）都要由客户端（如 浏览器）主动发起，服务端进行处理后返回response结果，而服务端很难主动向客户端发送数据；这种客户端是主动方，服务端是被动方的传统Web模式 对于信息变化不频繁的Web应用来说造成的麻烦较小，而对于涉及实时信息的Web应用却带来了很大的不便，如带有即时通信、实时数据、订阅推送等功能的应 用。在WebSocket规范提出之前，开发人员若要实现这些实时性较强的功能，经常会使用折衷的解决方法：**轮询（polling）**和**Comet**技术。其实后者本质上也是一种轮询，只不过有所改进。

　　**轮询**是最原始的实现实时Web应用的解决方案。轮询技术要求客户端以设定的时间间隔周期性地向服务端发送请求，频繁地查询是否有新的数据改动。明显地，这种方法会导致过多不必要的请求，浪费流量和服务器资源。

　　**Comet技术**又可以分为**长轮询**和**流技术**。**长轮询**改进了上述的轮询技术，减小了无用的请求。它会为某些数据设定过期时间，当数据过期后才会向服务端发送请求；这种机制适合数据的改动不是特别频繁的情况。**流技术**通常是指客户端使用一个隐藏的窗口与服务端建立一个HTTP长连接，服务端会不断更新连接状态以保持HTTP长连接存活；这样的话，服务端就可以通过这条长连接主动将数据发送给客户端；流技术在大并发环境下，可能会考验到服务端的性能。

　　这两种技术都是基于请求-应答模式，都不算是真正意义上的实时技术；它们的每一次请求、应答，都浪费了一定流量在相同的头部信息上，并且开发复杂度也较大。

　　伴随着HTML5推出的WebSocket，真正实现了Web的实时通信，使B/S模式具备了C/S模式的实时通信能力。WebSocket的工作流程是这 样的：浏览器通过JavaScript向服务端发出建立WebSocket连接的请求，在WebSocket连接建立成功后，客户端和服务端就可以通过 TCP连接传输数据。因为WebSocket连接本质上是TCP连接，不需要每次传输都带上重复的头部数据，所以它的数据传输量比轮询和Comet技术小 了很多。本文不详细地介绍WebSocket规范，主要介绍下WebSocket在Java Web中的实现。

　　JavaEE 7中出了JSR-356:Java API for WebSocket规范。不少Web容器，如Tomcat,Nginx,Jetty等都支持WebSocket。Tomcat从7.0.27开始支持 WebSocket，从7.0.47开始支持JSR-356，下面的Demo代码也是需要部署在**Tomcat7.0.47**以上的版本才能运行。

### 2.Tomcat WebSocket快速入门

#### 2.1 引入依赖

```xml
<!-- 实现对 WebSocket 相关依赖的引入，方便~ -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

#### 2.2 WebSocketServerEndpoint

```java
/**
 * WebSocket服务端的端点
 *
 * @author Corona
 * @date 2020-12-27
 */
@Slf4j
@Controller
@ServerEndpoint("/")
public class WebSocketServerEndPoint implements InitializingBean {

    /**
     * 消息类型与 MessageHandler 的映射
     * <p>
     * 注意，这里设置成静态变量。虽然说 WebsocketServerEndpoint 是单例，
     * 但是 Spring Boot 还是会为每个 WebSocket 创建一个 WebsocketServerEndpoint Bean 。
     */
    private static final Map<String, MessageHandler> HANDLERS = new HashMap<>();

    @Autowired
    private ApplicationContext applicationContext;

    @OnOpen
    public void onOpen(Session session, EndpointConfig config) {
        log.info("[onOpen][session({})接入]", session);
        // <1> 解析 accessToken
        List<String> accessTokenValues = session.getRequestParameterMap().get("accessToken");
        String accessToken = !CollectionUtils.isEmpty(accessTokenValues) ? accessTokenValues.get(0) : null;
        // <2> 创建 AuthRequest 消息类型
        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);
        // <3> 获得消息处理器
        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);
        if (messageHandler == null) {
            log.error("[onOpen][认证消息类型，不存在消息处理器]");
            return;
        }
        messageHandler.execute(session, authRequest);
    }

    @OnMessage
    public void onMessage(Session session, String message) {
        log.info("[onOpen][session({}) 接收到一条消息({})]", session, message); // 生产环境下，请设置成 debug 级别
        try {
            // <1> 获得消息类型
            JSONObject jsonMessage = JSON.parseObject(message);
            String messageType = jsonMessage.getString("type");
            // <2> 获得消息处理器
            MessageHandler messageHandler = HANDLERS.get(messageType);
            if (messageHandler == null) {
                log.error("[onMessage][消息类型({}) 不存在消息处理器]", messageType);
                return;
            }
            // <3> 解析消息
            Class<? extends Message> messageClass = this.getMessageClass(messageHandler);
            // <4> 处理消息
            Message messageObj = JSON.parseObject(jsonMessage.getString("body"), messageClass);
            messageHandler.execute(session, messageObj);
        } catch (Throwable throwable) {
            log.info("[onMessage][session({}) message({}) 发生异常]", session, throwable);
        }
    }

    @OnClose
    public void onClose(Session session, CloseReason closeReason) {
        log.info("[onClose][session({})连接关闭。关闭原因是({})]", session, closeReason);
        WebSocketUtil.removeSession(session);
    }

    @OnError
    public void onError(Session session, Throwable throwable) {
        log.info("[onError][session({})发生异常]", session, throwable);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        // 通过 ApplicationContext 获得所有 MessageHandler Bean
        // 获得所有 MessageHandler Bean
        // 添加到 handlers 中
        applicationContext.getBeansOfType(MessageHandler.class).values()
                .forEach(messageHandler -> HANDLERS.put(messageHandler.getType(), messageHandler));
        log.info("[afterPropertiesSet][消息处理器数量：{}]", HANDLERS.size());
    }

    private Class<? extends Message> getMessageClass(MessageHandler handler) {
        // 获得 Bean 对应的 Class 类名。因为有可能被 AOP 代理过。
        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);
        // 获得接口的 Type 数组
        Type[] interfaces = targetClass.getGenericInterfaces();
        Class<?> superclass = targetClass.getSuperclass();
        // 此处，是以父类的接口为准
        while ((Objects.isNull(interfaces) || 0 == interfaces.length) && Objects.nonNull(superclass)) {
            interfaces = superclass.getGenericInterfaces();
            superclass = targetClass.getSuperclass();
        }
        if (Objects.nonNull(interfaces)) {
            // 遍历 interfaces 数组
            for (Type type : interfaces) {
                // 要求 type 是泛型参数
                if (type instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType) type;
                    // 要求是 MessageHandler 接口
                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {
                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
                        // 取首个元素
                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {
                            return (Class<Message>) actualTypeArguments[0];
                        } else {
                            throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
                        }
                    }
                }
            }
        }
        throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
    }
}
```

- 在类上，添加 `@Controller` 注解，保证创建一个 WebsocketServerEndpoint Bean 。
- 在类上，添加 JSR-356 定义的 [`@ServerEndpoint`](https://github.com/eclipse-ee4j/websocket-api/blob/master/api/server/src/main/java/javax/websocket/server/ServerEndpoint.java) 注解，标记这是一个 WebSocket EndPoint ，路径为 `/` 。
- WebSocket 一共有四个事件，分别对应使用 JSR-356 定义的 [`@OnOpen`](https://github.com/eclipse-ee4j/websocket-api/blob/master/api/client/src/main/java/javax/websocket/OnOpen.java)、[`@OnMessage`](https://github.com/eclipse-ee4j/websocket-api/blob/master/api/client/src/main/java/javax/websocket/OnMessage.java)、[`@OnClose`](https://github.com/eclipse-ee4j/websocket-api/blob/master/api/client/src/main/java/javax/websocket/OnClose.java)、[`@OnError`](https://github.com/eclipse-ee4j/websocket-api/blob/master/api/client/src/main/java/javax/websocket/OnError.java) 注解。

#### 2.3 WebSocketConfiguration

```java
@Configuration
// @EnableWebSocket // 无需添加该注解，因为我们并不是使用 Spring WebSocket
public class WebSocketConfiguration {

    @Bean
    public ServerEndpointExporter serverEndpointExporter() {
        return new ServerEndpointExporter();
    }

}
```

- 在 `#serverEndpointExporter()` 方法中，创建 ServerEndpointExporter Bean 。该 Bean 的作用，是扫描添加有 `@ServerEndpoint` 注解的 Bean 。

#### 2.4 消息

##### 2.4.1 消息抽象接口

```java
/**
 * 消息接口
 *
 * @author Corona
 */
public interface Message {

}
```

##### 2.4.2 消息具体类（以认证请求为类）

```java
@Data
@Accessors(chain = true)
public class AuthRequest implements Message {

    public static final String TYPE = "AUTH_REQUEST";

    private String accessToken;

}
```

```java
@Data
@Accessors(chain = true)
public class AuthResponse implements Message {

    public static final String TYPE = "AUTH_RESPONSE";

    /**
     * 响应状态码
     */
    private Integer code;
    /**
     * 响应提示
     */
    private String message;
    
}
```

#### 2.5 消息处理器

##### 2.5.1 消息处理器抽象接口

```java
/**
 * 消息处理器抽象接口
 *
 * @param <T>
 * @author Corona
 * @date 2020-01-02
 */
public interface MessageHandler<T extends Message> {

    /**
     * 执行处理消息
     *
     * @param session 会话
     * @param message 消息
     */
    void execute(Session session, T message);

    /**
     * 返回消息类型
     *
     * @return 消息类型，即每个 Message 实现类上的 TYPE 静态字段
     */
    String getType();

}
```

##### 2.5.2 消息处理器具体接口（以认证请求为例）

```java
@Component
public class AuthMessageHandler implements MessageHandler<AuthRequest> {

    @Override
    public void execute(Session session, AuthRequest message) {
        // 如果未传递 accessToken 
        if (StringUtils.isEmpty(message.getAccessToken())) {
            WebSocketUtil.send(session, AuthResponse.TYPE,
                    new AuthResponse().setCode(1).setMessage("认证 accessToken 未传入"));
            return;
        }

        // 添加到 WebSocketUtil 中
        // 考虑到代码简化，我们先直接使用 accessToken 作为 User
        WebSocketUtil.addSession(session, message.getAccessToken());

        // 判断是否认证成功。这里，假装直接成功
        WebSocketUtil.send(session, AuthResponse.TYPE, new AuthResponse().setCode(0));

        // 通知所有人，某个人加入了。这个是可选逻辑，仅仅是为了演示
        // 考虑到代码简化，我们先直接使用 accessToken 作为 User
        WebSocketUtil.broadcast(UserJoinNoticeRequest.TYPE,
                new UserJoinNoticeRequest().setNickname(message.getAccessToken()));
    }

    @Override
    public String getType() {
        return AuthRequest.TYPE;
    }

}
```

#### 2.6 WebSocketUtil

```java
@Slf4j
public class WebSocketUtil {

    // ========== 会话相关 ==========

    /**
     * Session 与用户的映射
     */
    private static final Map<Session, String> SESSION_USER_MAP = new ConcurrentHashMap<>();
    /**
     * 用户与 Session 的映射
     */
    private static final Map<String, Session> USER_SESSION_MAP = new ConcurrentHashMap<>();

    /**
     * 添加 Session 。在这个方法中，会添加用户和 Session 之间的映射
     *
     * @param session Session
     * @param user    用户
     */
    public static void addSession(Session session, String user) {
        // 更新 USER_SESSION_MAP
        USER_SESSION_MAP.put(user, session);
        // 更新 SESSION_USER_MAP
        SESSION_USER_MAP.put(session, user);
    }

    /**
     * 移除 Session 。
     *
     * @param session Session
     */
    public static void removeSession(Session session) {
        // 从 SESSION_USER_MAP 中移除
        String user = SESSION_USER_MAP.remove(session);
        // 从 USER_SESSION_MAP 中移除
        if (user != null && user.length() > 0) {
            USER_SESSION_MAP.remove(user);
        }
    }

    // ========== 消息相关 ==========

    /**
     * 广播发送消息给所有在线用户
     *
     * @param type    消息类型
     * @param message 消息体
     * @param <T>     消息类型
     */
    public static <T extends Message> void broadcast(String type, T message) {
        // 创建消息
        String messageText = buildTextMessage(type, message);
        // 遍历 SESSION_USER_MAP ，进行逐个发送
        for (Session session : SESSION_USER_MAP.keySet()) {
            sendTextMessage(session, messageText);
        }
    }

    /**
     * 发送消息给单个用户的 Session
     *
     * @param session Session
     * @param type    消息类型
     * @param message 消息体
     * @param <T>     消息类型
     */
    public static <T extends Message> void send(Session session, String type, T message) {
        // 创建消息
        String messageText = buildTextMessage(type, message);
        // 遍历给单个 Session ，进行逐个发送
        sendTextMessage(session, messageText);
    }

    /**
     * 发送消息给指定用户
     *
     * @param user    指定用户
     * @param type    消息类型
     * @param message 消息体
     * @param <T>     消息类型
     * @return 发送是否成功你那个
     */
    public static <T extends Message> boolean send(String user, String type, T message) {
        // 获得用户对应的 Session
        Session session = USER_SESSION_MAP.get(user);
        if (session == null) {
            log.error("[send][user({}) 不存在对应的 session]", user);
            return false;
        }
        // 发送消息
        send(session, type, message);
        return true;
    }

    /**
     * 构建完整的消息
     *
     * @param type    消息类型
     * @param message 消息体
     * @param <T>     消息类型
     * @return 消息
     */
    private static <T extends Message> String buildTextMessage(String type, T message) {
        JSONObject messageObject = new JSONObject();
        messageObject.put("type", type);
        messageObject.put("body", message);
        return messageObject.toString();
    }

    /**
     * 真正发送消息
     *
     * @param session     Session
     * @param messageText 消息
     */
    private static void sendTextMessage(Session session, String messageText) {
        if (session == null) {
            log.error("[sendTextMessage][session 为 null]");
            return;
        }
        RemoteEndpoint.Basic basic = session.getBasicRemote();
        if (basic == null) {
            log.error("[sendTextMessage][session 的  为 null]");
            return;
        }
        try {
            basic.sendText(messageText);
        } catch (IOException e) {
            log.error("[sendTextMessage][session({}) 发送消息{}) 发生异常",
                    session, messageText, e);
        }
    }

}
```

### 3.Spring WebSocket快速入门

#### 3.1 引入依赖

```xml
<!-- 实现对 WebSocket 相关依赖的引入，方便~ -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-websocket</artifactId>
</dependency>
```

#### 3.2 SpringWebSocketShakeInterceptor

因为 WebSocketSession 无法获得 ws 地址上的请求参数，所以只好通过该拦截器，获得 `accessToken` 请求参数，设置到 `attributes` 中。

```java
public class SpringWebSocketShakeInterceptor extends HttpSessionHandshakeInterceptor {

    @Override
    public boolean beforeHandshake(ServerHttpRequest request, ServerHttpResponse response, WebSocketHandler wsHandler, Map<String, Object> attributes) throws Exception {
        // 获得 accessToken
        if (request instanceof ServletServerHttpRequest) {
            ServletServerHttpRequest serverRequest = (ServletServerHttpRequest) request;
            attributes.put("accessToken", serverRequest.getServletRequest().getParameter("accessToken"));
        }
        // 调用父方法，继续执行逻辑
        return super.beforeHandshake(request, response, wsHandler, attributes);
    }
}
```

#### 3.3 SpringWebSocketHandler

```java
/**
 * Spring Websocket 服务的端点
 * 等同于 Tomcat 的 WebSocketServerEndPoint
 *
 * @author Corona
 * @date 2021-01-02
 */
@Slf4j
public class SpringWebSocketHandler extends TextWebSocketHandler implements InitializingBean {

    /**
     * 消息类型与 MessageHandler 的映射
     * <p>
     * 无需设置成静态变量
     */
    private final Map<String, MessageHandler> HANDLERS = new HashMap<>();

    @Autowired
    private ApplicationContext applicationContext;

    /**
     * 对应 open 事件
     *
     * @param session
     * @throws Exception
     */
    @Override
    public void afterConnectionEstablished(WebSocketSession session) throws Exception {
        log.info("[afterConnectionEstablished][session({}) 接入]", session);
        // 解析 accessToken
        String accessToken = (String) session.getAttributes().get("accessToken");
        // 创建 AuthRequest 消息类型
        AuthRequest authRequest = new AuthRequest().setAccessToken(accessToken);
        // 获得消息处理器
        MessageHandler<AuthRequest> messageHandler = HANDLERS.get(AuthRequest.TYPE);
        if (messageHandler == null) {
            log.error("[onOpen][认证消息类型，不存在消息处理器]");
            return;
        }
        messageHandler.execute(session, authRequest);
    }

    /**
     * 对应 message 事件
     *
     * @param session
     * @param textMessage
     * @throws Exception
     */
    @Override
    public void handleTextMessage(WebSocketSession session, TextMessage textMessage) throws Exception {
        // 生产环境下，请设置成 debug 级别
        log.info("[handleMessage][session({}) 接收到一条消息({})]", session, textMessage);
        try {
            // 获得消息类型
            JSONObject jsonMessage = JSON.parseObject(textMessage.getPayload());
            String messageType = jsonMessage.getString("type");
            // 获得消息处理器
            MessageHandler messageHandler = HANDLERS.get(messageType);
            if (messageHandler == null) {
                log.error("[onMessage][消息类型({}) 不存在消息处理器]", messageType);
                return;
            }
            // 解析消息
            Class<? extends Message> messageClass = this.getMessageClass(messageHandler);
            // 处理消息
            Message messageObj = JSON.parseObject(jsonMessage.getString("body"), messageClass);
            messageHandler.execute(session, messageObj);
        } catch (Throwable throwable) {
            log.info("[onMessage][session({}) message({}) 发生异常]", session, throwable);
        }
    }

    /**
     * 对应 close 事件
     *
     * @param session
     * @param status
     * @throws Exception
     */
    @Override
    public void afterConnectionClosed(WebSocketSession session, CloseStatus status) throws Exception {
        log.info("[afterConnectionClosed][session({}) 连接关闭。关闭原因是({})}]", session, status);
        SpringWebSocketUtil.removeSession(session);
    }

    /**
     * 对应 error 事件
     *
     * @param session
     * @param exception
     * @throws Exception
     */
    @Override
    public void handleTransportError(WebSocketSession session, Throwable exception) throws Exception {
        log.info("[handleTransportError][session({}) 发生异常]", session, exception);
    }

    @Override
    public void afterPropertiesSet() throws Exception {
        // 通过 ApplicationContext 获得所有 MessageHandler Bean
        // 获得所有 MessageHandler Bean
        // 添加到 handlers 中
        applicationContext.getBeansOfType(MessageHandler.class).values()
                .forEach(messageHandler -> HANDLERS.put(messageHandler.getType(), messageHandler));
        log.info("[afterPropertiesSet][消息处理器数量：{}]", HANDLERS.size());
    }

    private Class<? extends Message> getMessageClass(MessageHandler handler) {
        // 获得 Bean 对应的 Class 类名。因为有可能被 AOP 代理过。
        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);
        // 获得接口的 Type 数组
        Type[] interfaces = targetClass.getGenericInterfaces();
        Class<?> superclass = targetClass.getSuperclass();
        // 此处，是以父类的接口为准
        while ((Objects.isNull(interfaces) || 0 == interfaces.length) && Objects.nonNull(superclass)) {
            interfaces = superclass.getGenericInterfaces();
            superclass = targetClass.getSuperclass();
        }
        if (Objects.nonNull(interfaces)) {
            // 遍历 interfaces 数组
            for (Type type : interfaces) {
                // 要求 type 是泛型参数
                if (type instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType) type;
                    // 要求是 MessageHandler 接口
                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {
                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
                        // 取首个元素
                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {
                            return (Class<Message>) actualTypeArguments[0];
                        } else {
                            throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
                        }
                    }
                }
            }
        }
        throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
    }

}
```

#### 3.4 WebSocketConfiguration

```java
/**
 * description:@EnableWebSocket：开启Spring WebSocket
 *
 * @author Corona
 * @date 2021-01-02
 */
@Configuration
@EnableWebSocket
public class SpringWebSocketConfiguration implements WebSocketConfigurer {

    @Override
    public void registerWebSocketHandlers(WebSocketHandlerRegistry registry) {
        // 配置处理器
        // 配置拦截器
        // 解决跨域问题
        registry.addHandler(this.springWebSocketHandler(), "/")
                .addInterceptors(new SpringWebSocketShakeInterceptor())
                .setAllowedOrigins(CorsConfiguration.ALL);
    }

    @Bean
    public SpringWebSocketHandler springWebSocketHandler() {
        return new SpringWebSocketHandler();
    }

    @Bean
    public SpringWebSocketShakeInterceptor springWebSocketShakeInterceptor() {
        return new SpringWebSocketShakeInterceptor();
    }
}
```

### 4. Stomp WebSocket

#### 4.1 SockJS的定义

SockJS是一个JavaScript库，为了应对许多浏览器不支持WebSocket协议的问题，设计了备选SockJs。SockJS 是 WebSocket 技术的一种模拟。SockJS会尽可能对应 WebSocket API，但如果WebSocket 技术不可用的话，会自动降为轮询的方式。SockJS会优先选择WebSocket进行连接，但是当服务器或客户端不支持WebSocket时，会自动在 XHR流、XDR流、iFrame事件源、iFrame HTML文件、XHR轮询、XDR轮询、iFrame XHR轮询、JSONP轮询 这几个方案中择优进行连接。

#### 4.2 StompJS的定义

STOMP—— Simple Text Oriented Message Protocol——面向消息的简单文本协议。

SockJS 为 WebSocket 提供了 备选方案。但无论哪种场景，对于实际应用来说，这种通信形式层级过低。 STOMP协议，来为浏览器 和 server 间的 通信增加适当的消息语义。

#### 4.3 WebSocket、SockJS、STOMP三者关系

简而言之，WebSocket 是底层协议，SockJS 是WebSocket 的备选方案，也是底层协议，而 STOMP 是基于 WebSocket（SockJS）的上层协议。

1、HTTP协议解决了 web 浏览器发起请求以及 web 服务器响应请求的细节，假设 HTTP 协议 并不存在，只能使用 TCP 套接字来 编写 web 应用。

2、直接使用 WebSocket（SockJS） 就很类似于 使用 TCP 套接字来编写 web 应用，因为没有高层协议，就需要我们定义应用间所发送消息的语义，还需要确保连接的两端都能遵循这些语义；

3、同HTTP在TCP 套接字上添加请求-响应模型层一样，STOMP在WebSocket 之上提供了一个基于帧的线路格式层，用来定义消息语义；

#### 4.4 @SendTo 与 @SendToUser 是Spring的STOMP协议中注解的标签。

@SendTo

会将接收到的消息发送到指定的路由目的地，所有订阅该消息的用户都能收到，属于广播。

@SendToUser

消息目的地有UserDestinationMessageHandler来处理，会将消息路由到发送者对应的目的地。默认该注解前缀为/user。如：用户订阅/user/hi ，在@SendToUser('/hi')查找目的地时，会将目的地的转化为/user/{name}/hi, 这个name就是principal的name值，该操作是认为用户登录并且授权认证，使用principal的name作为目的地标识。发给消息来源的那个用户。（就是谁请求给谁，不会发给所有用户，区分就是依照principal-name来区分的)。

此外该注解还有个broadcast属性，表明是否广播。就是当有同一个用户登录多个session时，是否都能收到。取值true/false.

#### 4.5 StompWebSocketConfiguration

```java
/**
 * 开启 Spring WebSocket 对 Stomp 的支持
 *
 * @EnableWebSocketMessageBroker注解表示开启使用STOMP协议来传输基于代理的消息，Broker就是代理的意思。
 */
@Configuration
@EnableWebSocketMessageBroker
public class StompWebSocketConfiguration implements WebSocketMessageBrokerConfigurer {

    /**
     * registerStompEndpoints方法表示注册STOMP协议的节点，并指定映射的URL
     *
     * @param registry
     */
    @Override
    public void registerStompEndpoints(StompEndpointRegistry registry) {
        //用来注册STOMP协议节点，同时指定使用SockJS
        registry.addEndpoint("/websocket/stomp/")
                .setAllowedOrigins("*")
                .withSockJS();
    }

    /**
     * configureMessageBroker方法用来配置消息代理，由于我们是实现推送功能，这里的消息代理是/topic
     * @param registry
     */
    @Override
    public void configureMessageBroker(MessageBrokerRegistry registry) {
        registry.enableSimpleBroker("/topic");
        registry.setApplicationDestinationPrefixes("/app");
    }

}
```

#### 4.6 StompController

```java
/**
 * 类似于Tomcat WebSocketServerEndPoint
 *
 * @author Corona
 * @date 2020-01-02
 */
@Slf4j
@Controller
public class StompController {

    @Autowired
    private SimpMessagingTemplate messagingTemplate;

    @MessageMapping("/send_to_all")
    @SendTo(value = "/topic/send_to_all")
    public String sendToAll(String message) {
        log.info("[sendToAll],message:{}", message);
        return message;
    }

    @MessageMapping("/send_to_user")
    @SendToUser(value = "/topic/send_to_user",broadcast = true)
    public String sendToUser(String message){
        log.info("[sendToUser],message:{}", message);
        return message;
    }

    @SubscribeMapping("/topic/send_to_all")
    public void subSendToAll(String message) {
        log.info("[subSendToAll],message:{}", message);
    }

    /**
     * 定时推送消息
     */
    @Scheduled(fixedRate = 1000)
    public void callback() {
        // 发现消息
        DateFormat df = new SimpleDateFormat("yyyy-MM-dd HH:mm:ss");
        messagingTemplate.convertAndSend("/topic/callback", "定时推送消息时间: " + df.format(new Date()));
    }
}
```

### 5. Netty WebSocket快速入门

#### 5.1 netty

##### 5.1.1 Netty简述

Netty 是一个高性能、异步事件驱动的 NIO 框架，基于 JAVA NIO 提供的 API 实现。它提供了对TCP、 UDP 和文件传输的支持，作为一个异步 NIO 框架， Netty 的所有 IO 操作都是异步非阻塞的， 通过 Future-Listener 机制，用户可以方便的主动获取或者通过通知机制获得 IO 操作结果。

##### 5.1.2 Netty 特性

1. 支持多种传输类型（阻塞、非阻塞），统一的API，易于使用。
2. 高性能，单线程、IO多路复用、池化技术、直接内存零拷贝。
3. 安全性，支持SSL/TLS。

##### 5.1.3 Netty 核心组件

###### 5.1.3.1 Channel

Channel 是 Java NIO 的一个基本构造。它代表一个到实体（ 如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O操作的程序组件） 的开放连接，如读操作和写操作。

###### 5.1.3.2 ChannelFuture

Future 提供了另一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。

Netty实现的ChannelFuture提供了几种额外的方法，这些方法使得我们能够注册一个或者多个ChannelFutureListener实例。监听器的回调方法operationComplete()， 将会在对应的操作完成时被调用。然后监听器可以判断该操作是成功地完成了还是出错了。如果是后者，我们可以检索产生的Throwable。

简而言之，由ChannelFutureListener提供的通知机制消除了手动检查对应的操作是否完成的必要。

另外，我们还可以通过 ChannelFuture 接口的 sync()方法让异步的操作变成同步的。

###### 5.1.3.3 ChannelHandler

Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事件来触发适当的动作。

入站事件：

- 连接被激活或失活
- 数据读取
- 用户事件
- 错误事件

出站事件：

- 打开或关闭到远程节点的连接
- 将数据写入或冲刷到socket

事件将流过整个ChannelPipeline。ChannelHandler 是消息的具体处理器，负责处理读写操作、客户端连接等事情。

ChannelPipeline是ChannelHandler的链，提供了一个容器并定义了用于沿着链传播入站和出站事件流的 API 。当 Channel 被创建时，它会被自动地分配到它专属的 ChannelPipeline。

###### 5.1.3.4 EventLoop

EventLoop 的主要作用实际就是负责监听网络事件并调用事件处理器进行相关 I/O 操作的处理。

Channel 为 Netty 网络操作(读写等操作)抽象类，EventLoop 负责处理注册到其上的Channel 处理 I/O 操作，两者配合参与 I/O 操作。

###### 5.1.3.5 EventLoopGroup

EventLoopGroup 包含多个 EventLoop（每一个 EventLoop 通常内部包含一个线程）。

并且 EventLoop 处理的 I/O 事件都将在它专有的 Thread 上被处理，即 Thread 和 EventLoop 属于 1 : 1 的关系，从而保证线程安全。

服务端的EventLoopGroup 通常包含两个，一个BossEventLoopGroup，一个WorkerEventLoopGroup。

BossEventLoopGroup 处理客户端的连接，处理完成后交由WorkerEventLoopGroup 处理。

WorkerEventLoopGroup 负责处理与客户端之间的 IO 操作。

###### 5.1.3.6 Bootstrap/ServerBootstrap

Bootstrap 是客户端引导类。ServerBootstrap 是服务端引导类。

Bootstrap 主要用于设置EventLoopGroup ，channel，远程主机地址，ChannelInitializer 以及连接远程主机。

```java
public void start() throws InterruptedException {
    //事件处理
    EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
    try {
        //用于引导和初始化客户端
        Bootstrap bootstrap = new Bootstrap();
        bootstrap.group(eventLoopGroup)
            .channel(NioSocketChannel.class)
            .remoteAddress(new InetSocketAddress(host, port))
            .handler(new ChannelInitializer<SocketChannel>() {
                protected void initChannel(SocketChannel socketChannel) throws Exception {
                    socketChannel.pipeline().addLast(new EchoClientHandler());
                }
            });
        //连接到服务器
        ChannelFuture future = bootstrap.connect().sync();
        future.channel().closeFuture().sync();
    } finally {
        eventLoopGroup.shutdownGracefully().sync();
    }
}
123456789101112131415161718192021
```

ServerBootstrap 主要用于设置EventLoopGroup ，channel，本地监听端口，ChannelInitializer 以及绑定本地端口。

```java
public void start() throws InterruptedException {
    //事件处理
    EventLoopGroup eventLoopGroup = new NioEventLoopGroup();
    try {
        //用于引导和绑定服务器
        ServerBootstrap bootstrap = new ServerBootstrap();
        bootstrap.group(eventLoopGroup)
            .channel(NioServerSocketChannel.class)
            .localAddress(new InetSocketAddress(port))
            .childHandler(new ChannelInitializer<SocketChannel>() {
                @Override
                public void initChannel(SocketChannel socketChannel) throws Exception {
                    socketChannel.pipeline().addLast(new EchoServerHandler());
                }
            });
        //绑定服务器
        ChannelFuture future = bootstrap.bind().sync();
        future.channel().closeFuture().sync();
    } finally {
        eventLoopGroup.shutdownGracefully().sync();
    }
}
12345678910111213141516171819202122
```

##### 5.1.4 Netty 线程模型

大部分网络框架都是基于 Reactor 模式设计开发的，Netty 也不例外。

> Reactor 模式基于事件驱动，采用多路复用将事件分发给相应的 Handler 处理，非常适合处理海量 IO 的场景。

常用的 Reactor 线程模型有三种， Reactor 单线程模型, Reactor 多线程模型, 主从 Reactor 多线程模型。

###### 5.1.4.1 Reactor 单线程模型

Reactor 单线程模型，指的是所有的 IO 操作都在同一个 NIO 线程上面完成， NIO 线程的职责如下：

1. 作为 NIO 服务端，接收客户端的 TCP 连接；
2. 作为 NIO 客户端，向服务端发起 TCP 连接；
3. 读取通信对端的请求或者应答消息；
4. 向通信对端发送消息请求或者应答消息。

总结：连接服务端（处理客户端连接）的工作和与远程节点进行其他请求响应操作（数据读写、编解码）都由一个线程完成。

![Reactor单线程模型](https://img-blog.csdnimg.cn/img_convert/5a1da3642b4ece76cd5ce94bf24536cf.png)

Reactor模式使用的是同步非阻塞IO(NIO)，所有的IO操作都不会导致阻塞，理论上一个线程可以独立的处理所有的IO操作(selector会主动去轮询哪些IO操作就绪)。从架构层次看，一个NIO线程确实可以完成其承担的职责，比如上图的Acceptor类接收客户端的TCP请求消息，当链路建立成功之后，通过Dispatch将对应的ByteBuffer转发到指定的handler上，进行消息的处理。

但是不适合高负载、大并发的应用场景，主要原因如下：

- 一个NIO线程处理成千上万的链路，性能无法支撑
- 当NIO线程负载过重，处理性能就会变慢，导致大量客户端连接超时然后重发请求，导致更多堆积未处理的请求
- 可靠性低，只有一个NIO线程，万一线程假死或则进入死循环，就完全不可用了

###### 5.1.4.2 Reactor 多线程模型

Rector 多线程模型与单线程模型最大的区别就是有一组 NIO 线程处理 IO 操作。 有专门一个NIO 线程-Acceptor 线程用于监听服务端，接收客户端的 TCP 连接请求；网络 IO 操作-读、写等由一个 NIO 线程池负责， 线程池可以采用标准的 JDK 线程池实现，它包含一个任务队列和 N个可用的线程，由这些 NIO 线程负责消息的读取、解码、编码和发送。

![Reactor多线程模型](https://img-blog.csdnimg.cn/img_convert/9c6d007575964a91196c59bd8cfac8c5.png)

但如果连接请求包含安全认证的需求，在高负载的情况下可能导致Acceptor 线程性能无法支撑。

###### 5.1.4.3 主从 Reactor 多线程模型

服务端用于接收客户端连接的不再是个 1 个单独的 NIO 线程，而是一个独立的 NIO 线程池。Acceptor 接收到客户端 TCP 连接请求处理完成后（可能包含接入认证等），将新创建的SocketChannel 注册到 IO 线程池（sub reactor 线程池）的某个 IO 线程上，由它负责SocketChannel 的读写和编解码工作。 Acceptor 线程池仅仅只用于客户端的登陆、握手和安全认证，一旦链路建立成功，就将链路注册到后端 subReactor 线程池的 IO 线程上，由 IO 线程负责后续的 IO 操作。

![主从Reactor多线程模型](https://img-blog.csdnimg.cn/img_convert/ee54bf8c0357a3bd9afeebf476ef4780.png)

##### 5.1.5 Netty 高性能

Netty 高性能主要体现在以下几个方面：

###### 5.1.5.1 IO多路复用和NIO

Netty 通过Reactor 模式进行线程的设计和实现。Netty 的 IO 线程 NioEventLoop 由于聚合了多路复用器 Selector，可以同时并发处理成百上千个客户端 Channel，由于读写操作都是非阻塞的，这就可以充分提升 IO 线程的运行效率，避免由于频繁 IO 阻塞导致的线程挂起。

###### 5.1.5.2 零拷贝

1. Netty 的接收和发送 ByteBuf 支持 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。
2. Netty 提供了组合 Buffer 对象（CompositeByteBuf ），可以聚合多个 ByteBuf 对象，用户可以像操作一个 Buffer 那样方便的对组合 Buffer 进行操作，避免了传统通过内存拷贝的方式将几个小 Buffer 合并成一个大的Buffer。
3. Netty的文件传输采用了FileChannel.transferTo方法，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。

###### 5.1.5.3 无锁设计、线程绑定

Netty 采用了串行无锁化设计，在 IO 线程内部进行串行操作，避免多线程竞争导致的性能下降。

表面上看，串行化设计似乎 CPU 利用率不高，并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串行化的线程并行运行，这种局部无锁化的串行线程设计相比一个队列-多个工作线程模型性能更优。

Netty 的 NioEventLoop 读取到消息之后，直接调用 ChannelPipeline 的fireChannelRead(Object msg)，只要用户不主动切换线程，一直会由 NioEventLoop 调用到用户的 Handler，期间不进行线程切换，这种串行化处理方式避免了多线程操作导致的锁的竞争，从性能角度看是最优的。

###### 5.1.5.4 高性能序列化

Netty 默认提供了对 Google Protobuf 的支持，通过扩展 Netty 的编解码接口，用户可以实现其它的高性能序列化框架，例如 Thrift 的压缩二进制编解码框架。

> protocol buffer 是 google 的一个开源项目,它是用于结构化数据串行化的灵活、高效、自动的方法，例如 XML， 不过它比 XML 更小、更快、也更简单。你可以定义自己的数据结构，然后使用代码生成器生成的代码来读写这个数据结构。你甚至可以在无需重新部署程序的情况下更新数据结构。

#### 5.2 引入依赖

```xml
<!-- 引入netty依赖 -->
<dependency>
    <groupId>io.netty</groupId>
    <artifactId>netty-all</artifactId>
    <version>4.1.6.Final</version>
</dependency>
```

#### 5.3 NettyWebSocketServer

```java
/**
 * NettyWebSocketServer
 *
 * @author Corona
 * @date 2021-01-02
 */
@Slf4j
@Component
public class NettyWebSocketServer {

    @Value("${netty.server.port}")
    private Integer serverPort;

    private static class SingletonHolder {
        private static final NettyWebSocketServer INSTANCE = new NettyWebSocketServer();
    }

    public static final NettyWebSocketServer getInstance() {
        return SingletonHolder.INSTANCE;
    }

    private EventLoopGroup mainGroup;
    private EventLoopGroup subGroup;
    private ServerBootstrap server;
    private ChannelFuture future;

    public NettyWebSocketServer() {
        mainGroup = new NioEventLoopGroup();
        subGroup = new NioEventLoopGroup();
        server = new ServerBootstrap();
        server.group(mainGroup, subGroup)
                .channel(NioServerSocketChannel.class)
                .childHandler(new NettyWSServerInitialize());
    }

    public void start() {
        this.future = server.bind(serverPort);
        log.info("Netty websocket start finish.");
    }
}
```

#### 5.4 NettyWSServerInitialize

```java
/**
 * Netty WebSocket Server初始化器
 *
 * @author Corona
 * @date 2021-01-02
 */
public class NettyWSServerInitialize extends ChannelInitializer<SocketChannel> {

    @Override
    protected void initChannel(SocketChannel ch) throws Exception {
        ChannelPipeline pipeline = ch.pipeline();

        //WebSocket 基于http协议，所以要有http解码器
        pipeline.addLast(new HttpServerCodec());
        //对写大数据流的支持
        pipeline.addLast(new ChunkedWriteHandler());
        //对httpMessage进行聚合，聚合成FullHttpRequest或FullHttpResponse
        //几乎在netty中的编程都会使用到此handler
        pipeline.addLast(new HttpObjectAggregator(1024 * 64));

        /**
         * websocket 服务器处理协议，用于指定给客户端访问的路由: /ws
         * 本handler会帮你处理一些繁重而复杂的事情
         * 会帮你处理握手动作：handshaking(ping、pong、close)ping + pong = 心跳
         * 对于websocket来讲，都是通过frames进行传输的，不同的数据类型对应的frames也不同
         */
        pipeline.addLast(new WebSocketServerProtocolHandler("/websocket/netty/"));

        //自定义的handler
        pipeline.addLast(new ChatHandler());
    }
}
```

#### 5.5 自定义Handler

```java
/**
 * 自定义Handler
 *
 * @author Corona
 * @date 2021-01-02
 */
@Slf4j
public class ChatHandler extends SimpleChannelInboundHandler<TextWebSocketFrame> {

    /**
     * 用于记录和管理所有的客户端的channel
     */
    private static ChannelGroup clients = new DefaultChannelGroup(GlobalEventExecutor.INSTANCE);

    @Override
    protected void channelRead0(ChannelHandlerContext channelHandlerContext, TextWebSocketFrame msg) {
        //获取客户端传输过来的消息
        String content = msg.text();
        log.info("接收到数据:{}", content);
        for (Channel channel : clients) {
            channel.writeAndFlush(new TextWebSocketFrame("服务端在[" + LocalDateTime.now() + "]"
                    + "接收到消息，消息为：" + content));
        }
    }

    /**
     * 当客户端连接服务端之后（打开链接）
     * 获取客户端的channel，并且放到channelGroup中去管理
     *
     * @param ctx
     */
    @Override
    public void handlerAdded(ChannelHandlerContext ctx) {
        clients.add(ctx.channel());
    }

    /**
     * 当触发handlerRemoved之后，
     * ChannelGroup会自动移除对应客户端的clients.remove(ctx.channel());
     *
     * @param ctx
     */
    @Override
    public void handlerRemoved(ChannelHandlerContext ctx) {
        log.info("客户端断开，channel对应的长ID为：{}", ctx.channel().id().asLongText());
        log.info("客户端断开，channel对应的短ID为：{}", ctx.channel().id().asShortText());
    }

```

#### 5.6 监听Spring Boot工程的启动

```java
/**
 * 监听spring boot工程的启动
 *
 * @author Corona
 * @date 2021-01-02
 */
@Slf4j
@Component
public class NettyBoot implements ApplicationListener<ContextRefreshedEvent> {

    @Override
    public void onApplicationEvent(ContextRefreshedEvent event) {
        if (event.getApplicationContext().getParent() == null) {
            try {
                NettyWebSocketServer.getInstance().start();
            } catch (Exception e) {
                log.error("netty server启动失败，失败原因是:{}", e.getMessage());
            }
        }
    }
}
```

#### 5.7 前端代码

```html
<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<title>hello</title>
</head>
<body>
	<div>发送消息</div>
	<input type="text" id="msgContent">
	<input type="button" value="点我发送" onclick="CHAT.chat();">
	<div>接收消息：</div>
	<div id="receiveMsg" style="background-color: yellow;"></div>

	<script type="text/javascript">
		window.CHAT = {
			socket: null,
			init: function() {
				if (window.WebSocket) {
					CHAT.socket = new WebSocket("ws://127.0.0.1:8081/websocket/netty/");
					CHAT.socket.onopen = function() {
						console.log("connect success...");
					},
					CHAT.socket.onclose = function() {
						console.log("connect close...");
					},
					CHAT.socket.onerror = function() {
						console.log("connect error...");
					},
					CHAT.socket.onmessage = function(e) {
						console.log("receive msg: " + e.data);
						var receiveMsg = document.getElementById("receiveMsg");
						var html = receiveMsg.innerHTML;
						receiveMsg.innerHTML = html + "<br />" + e.data;
					}
				} else {
					alert("do not support websocket..");
				}
			},
			chat: function() {
				var msgContent = document.getElementById("msgContent");
				CHAT.socket.send(msgContent.value);
			}
		}
		CHAT.init();
	</script>
</body>
</html>
```

### 6.  Netty-Socketio WebSocket

#### 6.1 概述

netty-socketio是一个开源的Socket.io服务器端的一个java的实现，它基于Netty框架，可用于服务端推送消息给客户端。

说到服务端推送技术，一般会涉及WebSocket，WebSocket是HTML5最新提出的规范，虽然主流浏览器都已经支持，但仍然可能有不兼容的情况，为了兼容所有浏览器，给程序员提供一致的编程体验，SocketIO将WebSocket、AJAX和其它的通信方式全部封装成了统一的通信接口，也就是说，使用SocketIO时不用担心兼容问题，底层会自动选用最佳的通信方式。

netty-socketio 框架事件流程

![img](https://img2018.cnblogs.com/blog/1385364/201903/1385364-20190328110501222-1323630390.png)

#### 6.2 引入依赖

```xml
<!-- netty-socket.io依赖 -->
<dependency>
    <groupId>com.corundumstudio.socketio</groupId>
    <artifactId>netty-socketio</artifactId>
    <version>1.7.17</version>
</dependency>
```

#### 6.3 配置文件

```yaml
socketio:
  host: 0.0.0.0
  port: 999
  maxFramePayloadLength: 1048576
  maxHttpContentLength: 1048576
  bossCount: 1
  workCount: 100
  allowCustomRequests: true
  upgradeTimeout: 1000000
  pingTimeout: 6000000
  pingInterval: 25000
```

#### 6.4 SocketIO配置类

```java
/**
 * SocketIO WebSocket配置类
 *
 * @author Corona
 * @date 2020-01-02
 */
@Configuration
public class SocketIOConfig {

    @Value("${socketio.host}")
    private String host;

    @Value("${socketio.port}")
    private Integer port;

    @Value("${socketio.bossCount}")
    private int bossCount;

    @Value("${socketio.workCount}")
    private int workCount;

    @Value("${socketio.allowCustomRequests}")
    private boolean allowCustomRequests;

    @Value("${socketio.upgradeTimeout}")
    private int upgradeTimeout;

    @Value("${socketio.pingTimeout}")
    private int pingTimeout;

    @Value("${socketio.pingInterval}")
    private int pingInterval;

    /**
     * 以下配置在application.yaml
     *
     * @return
     */
    @Bean
    public SocketIOServer socketIOServer() {
        SocketConfig socketConfig = new SocketConfig();
        socketConfig.setTcpNoDelay(true);
        socketConfig.setSoLinger(0);
        com.corundumstudio.socketio.Configuration config = new com.corundumstudio.socketio.Configuration();
        config.setSocketConfig(socketConfig);
        config.setHostname(host);
        config.setPort(port);
        config.setTransports(Transport.POLLING, Transport.WEBSOCKET);
        config.setBossThreads(bossCount);
        config.setWorkerThreads(workCount);
        config.setAllowCustomRequests(allowCustomRequests);
        config.setUpgradeTimeout(upgradeTimeout);
        config.setPingTimeout(pingTimeout);
        config.setPingInterval(pingInterval);
        return new SocketIOServer(config);
    }

}
```

#### 6.5 SocketIOServer启动器SocketIOServerRunner

```java
/**
 * SocketIOServer启动器
 *
 * @author Corona
 * @date 2021-01-02
 */
@Slf4j
@Component
@Order(value = 1)
public class SocketIOServerRunner implements CommandLineRunner {

    @Autowired
    private SocketIOServer server;

    @Override
    public void run(String... args) throws Exception {
        log.info("SocketIOServer启动了");
        server.start();
    }
}
```

#### 6.6 SocketIOService

```java
/**
 * SocketIOService
 *
 * @author Corona
 * @date 2020-01-02
 */
@Slf4j
@Service
public class SocketIOService {

    @Autowired
    private SocketIOServer server;

    private static Map<String, SocketIOClient> clientsMap = new HashMap<>();

    /**
     * 添加connect事件，当客户端发起连接时调用，本文中将clientid与sessionid存入数据库
     * //方便后面发送消息时查找到对应的目标client,
     *
     * @param client
     */
    @OnConnect
    public void onConnect(SocketIOClient client) {
        String uuid = client.getSessionId().toString();
        clientsMap.put(uuid, client);
        log.debug("IP: " + client.getRemoteAddress().toString() + " UUID: " + uuid + " 设备建立连接");
    }

    /**
     * 添加@OnDisconnect事件，客户端断开连接时调用，刷新客户端信息
     */
    @OnDisconnect
    public void onDisconnect(SocketIOClient client) {
        String uuid = client.getSessionId().toString();
        clientsMap.remove(uuid);
        log.debug("IP: " + client.getRemoteAddress().toString() + " UUID: " + uuid + " 设备断开连接");
    }

    /**
     * 给所有连接客户端推送消息
     *
     * @param eventType 推送的事件类型
     * @param message   推送的内容
     */
    public void sendMessageToAllClient(String eventType, String message) {
        Collection<SocketIOClient> clients = server.getAllClients();
        for (SocketIOClient client : clients) {
            client.sendEvent(eventType, message);
        }
    }

}
```



### 7. 总结

实际场景下，我们在使用 WebSocket 还是原生 Socket 也好，都需要考虑，**如何保证消息一定送达给用户**？

大家肯定能够想到的是，如果用户不处于在线的时候，消息持久化到 MySQL、MongoDB 等等数据库中。这个是正确，且是必须要做的。

我们在一起考虑下边界场景，客户端网络环境较差，特别是在移动端场景下，出现网络**闪断**，可能会出现连接实际已经断开，而服务端以为客户端处于在线的情况。此时，服务端会将消息发给客户端，那么消息实际就发送到“空气”中，产生丢失的情况。要解决这种情况下的问题，需要引入客户端的 ACK 消息机制。目前，主流的有两种做法。

第一种，基于每一条消息编号 ACK 。整体流程如下：

- 无论客户端是否在线，服务端都先把接收到的消息持久化到数据库中。如果客户端此时在线，服务端将**完整消息**推送给客户端。
- 客户端在接收到消息之后，发送 ACK 消息编号给服务端，告知已经收到该消息。服务端在收到 ACK 消息编号的时候，标记该消息已经发送成功。
- 服务端定时轮询，在线的客户端，是否有超过 N 秒未 ACK 的消息。如果有，则重新发送消息给对应的客户端。

这种方案，因为客户端逐条 ACK 消息编号，所以会导致客户端和服务端交互次数过多。当然，客户端可以异步批量 ACK 多条消息，从而减少次数。

不过因为服务端仍然需要定时轮询，也会导致服务端压力较大。所以，这种方案基本已经不采用了。

第二种，基于滑动窗口 ACK 。整体流程如下：

- 无论客户端是否在线，服务端都先把接收到的消息持久化到数据库中。如果客户端此时在线，服务端将**消息编号**推送给客户端。
- 客户端在接收到**消息编号**之后，和本地的消息编号进行比对。如果比本地的小，说明该消息已经收到，忽略不处理；如果比本地的大，使用**本地的**消息编号，向服务端拉取**大于**本地的消息编号的消息列表，即增量消息列表。拉取完成后，更新消息列表中最大的消息编号为**新的本地的**消息编号。
- 服务端在收到客户端拉取增量的消息列表时，将请求的编号记录到数据库中，用于知道客户端此时本地的最新消息编号。
- 考虑到服务端将**消息编号**推送给客户端，也会存在丢失的情况，所以客户端会每 N 秒定时向服务端拉取**大于**本地的消息编号的消息列表。

这种方式，在业务被称为**推拉结合**的方案，在分布式消息队列、配置中心、注册中心实现实时的数据同步，经常被采用。

并且，采用这种方案的情况下，客户端和服务端不一定需要使用**长连接**，也可以使用**长轮询**所替代。客户端发送带有消息版本号的 HTTP 请求到服务端。

- 如果服务端**已有**比客户端新的消息编号，则直接返回增量的消息列表。
- 如果服务端**没有**比客户端新的消息编号，则 HOLD 住请求，直到有新的消息列表可以返回，或者 HTTP 请求超时。
- 客户端在收到 HTTP 请求超时时，立即又重新发起带有消息版本号的 HTTP 请求到服务端。如此反复循环，通过消息编号作为**增量标识**，达到实时获取消息的目的。

如果胖友对这块感兴趣，可以看看 [《IM 消息送达保证机制实现》](http://www.52im.net/thread-294-1-1.html) 文章。毕竟，艿艿这里写的有点简略哈~

### 8.扩展

mqtt也是一种方式。

## 第十章 性能测试——Tomcat、Jetty、Undertow基准测试

### 1. 概述

在Spring Boot中，内置了三种Servlet容器：Tomcat、Jetty、Undetow。

### 2. 性能指标

吞吐量（TPS）、QPS、并发数、响应时间（RT）几个概念做下了解

#### 2.1 响应时间(RT) 

　　响应时间是指系统对请求作出响应的时间。直观上看，这个指标与人对软件性能的主观感受是非常一致的，因为它完整地记录了整个计算机系统处理请求的时间。由于一个系统通常会提供许多功能，而不同功能的处理逻辑也千差万别，因而不同功能的响应时间也不尽相同，甚至同一功能在不同输入数据的情况下响应时间也不相同。所以，在讨论一个系统的响应时间时，人们通常是指该系统所有功能的平均时间或者所有功能的最大响应时间。当然，往往也需要对每个或每组功能讨论其平均响应时间和最大响应时间。 
　　对于单机的没有并发操作的应用系统而言，人们普遍认为响应时间是一个合理且准确的性能指标。需要指出的是，响应时间的绝对值并不能直接反映软件的性能的高低，软件性能的高低实际上取决于用户对该响应时间的接受程度。对于一个游戏软件来说，响应时间小于100毫秒应该是不错的，响应时间在1秒左右可能属于勉强可以接受，如果响应时间达到3秒就完全难以接受了。而对于编译系统来说，完整编译一个较大规模软件的源代码可能需要几十分钟甚至更长时间，但这些响应时间对于用户来说都是可以接受的。 

#### 2.2 吞吐量(Throughput) 

   吞吐量是指系统在单位时间内处理请求的数量。对于无并发的应用系统而言，吞吐量与响应时间成严格的反比关系，实际上此时吞吐量就是响应时间的倒数。前面已经说过，对于单用户的系统，响应时间（或者系统响应时间和应用延迟时间）可以很好地度量系统的性能，但对于并发系统，通常需要用吞吐量作为性能指标。 
　　对于一个多用户的系统，如果只有一个用户使用时系统的平均响应时间是t，当有你n个用户使用时，每个用户看到的响应时间通常并不是n×t，而往往比n×t小很多（当然，在某些特殊情况下也可能比n×t大，甚至大很多）。这是因为处理每个请求需要用到很多资源，由于每个请求的处理过程中有许多不走难以并发执行，这导致在具体的一个时间点，所占资源往往并不多。也就是说在处理单个请求时，在每个时间点都可能有许多资源被闲置，当处理多个请求时，如果资源配置合理，每个用户看到的平均响应时间并不随用户数的增加而线性增加。实际上，不同系统的平均响应时间随用户数增加而增长的速度也不大相同，这也是采用吞吐量来度量并发系统的性能的主要原因。一般而言，吞吐量是一个比较通用的指标，两个具有不同用户数和用户使用模式的系统，如果其最大吞吐量基本一致，则可以判断两个系统的处理能力基本一致。 

#### 2.3 并发用户数 

　　并发用户数是指系统可以同时承载的正常使用系统功能的用户的数量。与吞吐量相比，并发用户数是一个更直观但也更笼统的性能指标。实际上，并发用户数是一个非常不准确的指标，因为用户不同的使用模式会导致不同用户在单位时间发出不同数量的请求。一网站系统为例，假设用户只有注册后才能使用，但注册用户并不是每时每刻都在使用该网站，因此具体一个时刻只有部分注册用户同时在线，在线用户就在浏览网站时会花很多时间阅读网站上的信息，因而具体一个时刻只有部分在线用户同时向系统发出请求。这样，对于网站系统我们会有三个关于用户数的统计数字：注册用户数、在线用户数和同时发请求用户数。由于注册用户可能长时间不登陆网站，使用注册用户数作为性能指标会造成很大的误差。而在线用户数和同事发请求用户数都可以作为性能指标。相比而言，以在线用户作为性能指标更直观些，而以同时发请求用户数作为性能指标更准确些。 

#### 2.4 QPS每秒查询率(Query Per Second) 

　　每秒查询率QPS是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准，在因特网上，作为域名系统服务器的机器的性能经常用每秒查询率来衡量。对应fetches/sec，即每秒的响应请求数，也即是最大吞吐能力。 （看来是类似于TPS，只是应用于特定场景的吞吐量）

#### 2.5 Servlet容器版本

和 [《性能测试 —— Nginx 基准测试》](http://www.iocoder.cn/Performance-Testing/Nginx-benchmark/self) 保持一致，我们还是以 **QPS** 作为性能的指标。

在 https://github.com/YunaiV/SpringBoot-Labs/tree/master/lab-05-benchmark-tomcat-jetty-undertow 中，我们提供了四个示例，分别是：

- lab-05-tomcat ：Tomcat 9.0.16 NIO 模式。
- lab-05-tomcat-apr ：Tomcat 9.0.16 APR 模式。
- lab-05-jetty ：Jetty 9.4.14.v20181114 。
- lab-05-undertow ：Undertow 2.0.17.Final 。

胖友可以使用 `mvn package` 命令，打包出不同的示例，进行压力测试。

另外，上述示例，我们在 Controller 提供了简单的 HTTP Restful API 接口，返回简单的字符串。如下：

```java
@RestController
public class Controller {

    @GetMapping("/hello")
    public String hello() {
        return "world";
    }

}
```

#### 2.6 测试环境

有一点要注意，JVM 本身有[预热](https://codeday.me/bug/20180203/128666.html)的过程，Tomcat、Jetty、Undertow 本也有预热的过程（例如说，线程的初始化），所以需要多次测试，取平均值。

本文，我们使用 wrk 如下命令进行测试：

```shell
./wrk -t50 -c400 -d30s http://127.0.0.1:8080
```

- `-t50` 参数，设置 50 并发线程。
- `-c400` 参数，设置 400 连接。
- `-d30s` 参数，设置执行 30s 的时长的 HTTP 请求。
- `http://127.0.0.1:8080` 参数，请求本地的 Web 服务。
- 和 [《性能测试 —— Nginx 基准测试》](http://www.iocoder.cn/Performance-Testing/Nginx-benchmark/self) 基本保持一致。
- 因为偷懒，所以没有跑多种并发( `-c` 设置成不同)的情况。严格来说，胖友可以去尝试下，不同的并发量的情况下，各个 Web 服务的 QPS 上升还是下滑。

### 3. Tomcat NIO

> FROM [《Java 应用服务器 Tomcat》](https://www.oschina.net/p/tomcat)
>
> Tomcat 是一个小型的轻量级应用服务器，在中小型系统和并发访问用户不是很多的场合下被普遍使用，是开发和调试JSP 程序的首选。对于一个初学者来说，可以这样认为，当在一台机器上配置好Apache 服务器，可利用它响应对HTML 页面的访问请求。实际上Tomcat 部分是Apache 服务器的扩展，但它是独立运行的，所以当你运行tomcat 时，它实际上作为一个与Apache 独立的进程单独运行的。

可能会有胖友有疑惑，Tomcat 为什么还分不同的模式。实际上，Tomcat 一共分成三种模式：

> 参考资料 [《tomcat bio nio apr 模式性能测试与个人看法》](http://www.iocoder.cn/Performance-Testing/Tomcat-Jetty-Undertow-benchmark/tomcat bio nio apr 模式性能测试与个人看法) 文章。

- BIO (blocking I/O)模式：阻塞式 I/O 操作，表示 Tomcat 使用的是传统的 Java I/O 操作（即 `java.io` 包）。在 Tomcat 7 以及以前版本，默认使用 BIO 模式运行。一般情况下，BIO 模式是三种运行模式中性能最低的。

  > 也因为 BIO 模式，基本是性能最低的，所以本文我们也不进行测试，节约时间。

- NIO (Non-blocking I/O)模式：非阻塞时 I/O 操作，表示 Tomcat 使用的是 JDK 1.4 后新提供的 I/O 操作（即 `java.nio` 包）。在 Tomcat 8 以及到目前最新版本的 Tomcat 9 ，默认使用的都是 NIO 模式运行。相比 BIO 模式来说，它能提供更好的并发性能。

- APR (Apache Portable Runtime/Apache 可移植运行库) 模式：APR 是 [Apache](https://httpd.apache.org/) HTTP 服务器的支持库。我们可以理解成，Tomcat 将以 [JNI](https://zh.wikipedia.org/zh-hans/Java本地接口) 的方式，调用 Apache HTTP 服务器的核心动态链接库来处理文件或网络传输，从而大大的提升 Tomcat 对静态文件的处理性能。Tomcat APR 模式，也是 Tomcat 上运行高并发应用的首选模式。

  > 按照这个说法，现在前后端分离后，我们使用 Tomcat + SpringMVC 提供 Restful API ，所以 APR 模式，处理静态文件的能力，未必能带来性能上的提升。当然，还是测试出真知。

下面，我们开始正式的测试。启动 Tomcat 服务比较简单。如下：

```shell
java -jar lab-05-tomcat-1.0-SNAPSHOT.jar -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k
```

然后，执行 wrk 进行性能测试，结果如下：

```shell
$ ./wrk -t50 -c400 -d30s http://127.0.0.1:8080/hello

Running 30s test @ http://127.0.0.1:8080/hello
  50 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    13.81ms    7.09ms 159.52ms   86.27%
    Req/Sec   594.55     62.11     1.98k    78.31%
  890078 requests in 30.09s, 100.32MB read
Requests/sec:  29575.99
Transfer/sec:      3.33MB
```

- QPS 为 29575.99 。
- 平均延迟为 13.81ms。

### 4. Tomcat APR

相比 Tomcat NIO 来说，Tomcat APR 会相对麻烦一些，需要多三个步骤：

> 参考自 [《Apache Tomcat Native Library》](http://tomcat.apache.org/native-doc/) 文章。

- 1、安装 APR 。

  > 这个就是我们说到的 Apache Portable Runtime/Apache 可移植运行库 。

  ```shell
  yum install apr-devel -f
  ```

  - 安装的版本是，1.4.8-3.el7_4.1 。

- 2、安装 Tomcat Native 。

  > 这个就是我们说到的 Tomcat 将以 JNI 的方式调用 APR 的实现库。

  ```shell
  yum install tomcat-native
  ```

  - 安装的版本是，1.2.17-1.el7 。

- 3、设置 Tomcat 使用 APR 。如果在 Spring Boot 使用 Tomcat 内嵌服务器，可以参考 [TomcatAprApplication](https://github.com/YunaiV/SpringBoot-Labs/blob/master/lab-05-benchmark-tomcat-jetty-undertow/lab-05-tomcat-apr/src/main/java/cn/iocoder/springboot/labs/lab05/tomcat/TomcatAprApplication.java) 。

下面，我们开始正式的测试。启动 Tomcat 服务比较简单。如下：

```shell
java -jar lab-05-tomcat-apr-1.0-SNAPSHOT.jar -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k
```

然后，执行 wrk 进行性能测试，结果如下：

```shell
$ ./wrk -t50 -c400 -d30s http://127.0.0.1:8080

Running 30s test @ http://127.0.0.1:8080/hello
  50 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    12.15ms    5.12ms 229.46ms   87.59%
    Req/Sec   667.77     62.65     2.01k    80.34%
  999673 requests in 30.10s, 112.67MB read
Requests/sec:  33213.47
Transfer/sec:      3.74MB
```

- QPS 为 33213.47 。
- 平均延迟为 12.15ms。

相比 Tomcat NIO 模式，大概有 3500 QPS 左右的提升，12% 左右的性能提升。

当然，生产环境，我们实际使用 Tomcat NIO 模式，已经能够满足我们的诉求，不一定需要修改成 Tomcat APR 模式，因为相对麻烦一些。

### 5. Jetty

> FROM [《Servlet 容器 Jetty》](https://www.oschina.net/p/jetty)
>
> Jetty 是一个开源的 servlet 容器，它为基于 Java 的 web 内容，例如 JSP 和 servlet 提供运行环境。Jetty 是使用 Java 语言编写的，它的 API 以一组 JAR 包的形式发布。开发人员可以将 Jetty 容器实例化成一个对象，可以迅速为一些独立运行（stand-alone）的 Java 应用提供网络和 web 连接。

下面，我们开始正式的测试。启动 Jetty 服务比较简单。如下：

```shell
java -jar lab-05-jetty-apr-1.0-SNAPSHOT.jar -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k
```

然后，执行 wrk 进行性能测试，结果如下：

```shell
$ ./wrk -t50 -c400 -d30s http://127.0.0.1:8080

Running 30s test @ http://127.0.0.1:8080/hello
  50 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency     9.61ms    4.82ms 110.04ms   73.24%
    Req/Sec   849.00    167.82     5.16k    87.43%
  1270290 requests in 30.11s, 145.37MB read
Requests/sec:  42193.37
Transfer/sec:      4.83MB
```

- QPS 为 42193.37 。
- 平均延迟为 9.61ms 毫秒。

相比 Tomcat NIO 模式，大概有 12617.38 QPS 提升，43% 左右的性能提升。牛逼闪电啊！！！

### 6. Undertow

> FROM [《嵌入式 Web 服务器 Undertow》](https://www.oschina.net/p/undertow)
>
> Undertow 是一个采用 Java 开发的灵活的高性能 Web 服务器，提供包括阻塞和基于 NIO 的非堵塞机制。Undertow 是红帽公司的开源产品，是 Wildfly 默认的 Web 服务器。
>
> Undertow 提供一个基础的架构用来构建 Web 服务器，这是一个完全为嵌入式设计的项目，提供易用的构建器 API，完全兼容 Java EE Servlet 3.1 和低级非堵塞的处理器。

下面，我们开始正式的测试。启动 Undertow 服务比较简单。如下：

```shell
java -jar lab-05-undertow-1.0.0.jar -Xms2g -Xmx2g -Xmn1g -XX:MaxMetaspaceSize=256m -Xss256k
```

然后，执行 wrk 进行性能测试，结果如下：

```shell
$ ./wrk -t50 -c400 -d30s http://127.0.0.1:8080

Running 30s test @ http://127.0.0.1:8080/hello
  50 threads and 400 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    10.09ms    4.36ms 207.32ms   74.34%
    Req/Sec   802.76     99.60     2.16k    73.54%
  1198795 requests in 30.10s, 164.63MB read
Requests/sec:  39822.02
Transfer/sec:      5.47MB
```

- QPS 为 39822.02 。
- 平均延迟为 18.46 毫秒。

相比 Tomcat NIO 模式，大概有 10246.03 QPS 提升，34% 左右的性能提升。也牛逼闪电啊！！！

## 第十一章 Spring Boot Netty入门

### 1. 概述

Netty 是什么，这里简单介绍下：

> Netty 是一个 Java 开源框架。
>
> Netty 提供异步的、事件驱动的网络应用程序框架和工具，用以快速开发高性能、高可靠性的网络服务器和客户端程序。
>
> 也就是说，Netty 是一个基于 NIO 的客户、服务器端编程框架，使用Netty 可以确保你快速和简单的开发出一个网络应用，例如实现了某种协议的客户，服务端应用。
>
> Netty 相当简化和流线化了网络应用的编程开发过程，例如，TCP 和 UDP 的 Socket 服务开发。

### 2. 构建Netty服务端与客户端

#### 2.1 构建Netty服务端

##### 2.1.1 NettyServer

```java
/**
 * Netty服务端
 *
 * @author Corona
 * @date 2021-01-03
 */
@Slf4j
@Component
public class NettyServer {

    @Value("${netty.server.port}")
    private Integer port;

    @Autowired
    private NettyServerHandlerInitializer nettyServerHandlerInitializer;

    /**
     * boss 线程组，用于服务端接受客户端的连接
     */
    private EventLoopGroup bossGroup = new NioEventLoopGroup();
    /**
     * worker 线程组，用于服务端接受客户端的数据读写
     */
    private EventLoopGroup workerGroup = new NioEventLoopGroup();
    /**
     * Netty Server Channel
     */
    private Channel channel;

    /**
     * 启动 Netty Server
     */
    @PostConstruct
    public void start() throws InterruptedException {
        // <2.1> 创建 ServerBootstrap 对象，用于 Netty Server 启动
        ServerBootstrap bootstrap = new ServerBootstrap();
        // <2.2> 设置 ServerBootstrap 的各种属性
        bootstrap.group(bossGroup, workerGroup) // <2.2.1> 设置两个 EventLoopGroup 对象
                .channel(NioServerSocketChannel.class)  // <2.2.2> 指定 Channel 为服务端 NioServerSocketChannel
                .localAddress(new InetSocketAddress(port)) // <2.2.3> 设置 Netty Server 的端口
                .option(ChannelOption.SO_BACKLOG, 1024) // <2.2.4> 服务端 accept 队列的大小
                .childOption(ChannelOption.SO_KEEPALIVE, true) // <2.2.5> TCP Keepalive 机制，实现 TCP 层级的心跳保活功能
                .childOption(ChannelOption.TCP_NODELAY, true) // <2.2.6> 允许较小的数据包的发送，降低延迟
                .childHandler(nettyServerHandlerInitializer);
        // <2> 绑定端口，并同步等待成功，即启动服务端
        ChannelFuture future = bootstrap.bind().sync();
        if (future.isSuccess()) {
            channel = future.channel();
            log.info("[start][Netty Server 启动在 {} 端口]", port);
        }
    }

    /**
     * 关闭 Netty Server
     */
    @PreDestroy
    public void shutdown() {
        // <3.1> 关闭 Netty Server
        if (channel != null) {
            channel.close();
        }
        // <3.2> 优雅关闭两个 EventLoopGroup 对象
        bossGroup.shutdownGracefully();
        workerGroup.shutdownGracefully();
    }

}
```

##### 2.1.2 NettyServerHandler

```java
/**
 * 在类上添加 @ChannelHandler.Sharable 注解，标记这个 ChannelHandler 可以被多个 Channel 使用。
 */
@Slf4j
@Component
@ChannelHandler.Sharable
public class NettyServerHandler extends ChannelInboundHandlerAdapter {

    /**
     * channelManager 属性，是我们实现的客户端 Channel 的管理器。
     */
    @Autowired
    private NettyChannelManager channelManager;

    /**
     * #channelActive(ChannelHandlerContext ctx) 方法，在客户端和服务端建立连接完成时，
     * 调用 NettyChannelManager 的 #add(Channel channel) 方法，添加到其中。
     *
     * @param ctx
     */
    @Override
    public void channelActive(ChannelHandlerContext ctx) {
        // 从管理器中添加
        channelManager.add(ctx.channel());
    }

    /**
     * #channelUnregistered(ChannelHandlerContext ctx) 方法，在客户端和服务端断开连接时，
     * 调用 NettyChannelManager 的 #add(Channel channel) 方法，从其中移除。
     *
     * @param ctx
     */
    @Override
    public void channelUnregistered(ChannelHandlerContext ctx) {
        // 从管理器中移除
        channelManager.remove(ctx.channel());
    }

    /**
     * #exceptionCaught(ChannelHandlerContext ctx, Throwable cause) 方法，在处理 Channel 的事件发生异常时，
     * 调用 Channel 的 #close() 方法，断开和客户端的连接。
     *
     * @param ctx
     * @param cause
     */
    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        log.error("[exceptionCaught][连接({}) 发生异常]", ctx.channel().id(), cause);
        // 断开连接
        ctx.channel().close();
    }
}
```

##### 2.1.3 NettyServerHandlerInitializer

```java
@Component
public class NettyServerHandlerInitializer extends ChannelInitializer<Channel> {

    /**
     * 心跳超时时间
     */
    private static final Integer READ_TIMEOUT_SECONDS = 3 * 60;

    @Autowired
    private MessageDispatcher messageDispatcher;
    @Autowired
    private NettyServerHandler nettyServerHandler;

    @Override
    protected void initChannel(Channel ch) {
        // <1> 获得 Channel 对应的 ChannelPipeline
        ChannelPipeline channelPipeline = ch.pipeline();
        // <2> 添加一堆 NettyServerHandler 到 ChannelPipeline 中
        channelPipeline
                // 空闲检测
                .addLast(new ReadTimeoutHandler(READ_TIMEOUT_SECONDS, TimeUnit.SECONDS))
                // 编码器
                .addLast(new InvocationEncoder())
                // 解码器
                .addLast(new InvocationDecoder())
                // 消息分发器
                .addLast(messageDispatcher)
                // 服务端处理器
                .addLast(nettyServerHandler)
        ;
    }
}
```

##### 2.1.4 NettyChannelManager

```java
@Slf4j
@Component
public class NettyChannelManager {

    /**
     * {@link io.netty.channel.Channel#attr(io.netty.util.AttributeKey)} 属性中，表示 Channel 对应的用户
     */
    private static final AttributeKey<String> CHANNEL_ATTR_KEY_USER = AttributeKey.newInstance("user");

    /**
     * Channel 映射
     */
    private ConcurrentMap<ChannelId, Channel> channels = new ConcurrentHashMap<>();
    /**
     * 用户与 Channel 的映射。
     * <p>
     * 通过它，可以获取用户对应的 Channel。这样，我们可以向指定用户发送消息。
     */
    private ConcurrentMap<String, Channel> userChannels = new ConcurrentHashMap<>();

    /**
     * 添加 Channel 到 {@link #channels} 中
     *
     * @param channel Channel
     */
    public void add(Channel channel) {
        channels.put(channel.id(), channel);
        log.info("[add][一个连接({})加入]", channel.id());
    }

    /**
     * 添加指定用户到 {@link #userChannels} 中
     *
     * @param channel Channel
     * @param user    用户
     */
    public void addUser(Channel channel, String user) {
        Channel existChannel = channels.get(channel.id());
        if (existChannel == null) {
            log.error("[addUser][连接({}) 不存在]", channel.id());
            return;
        }
        // 设置属性
        channel.attr(CHANNEL_ATTR_KEY_USER).set(user);
        // 添加到 userChannels
        userChannels.put(user, channel);
    }

    /**
     * 将 Channel 从 {@link #channels} 和 {@link #userChannels} 中移除
     *
     * @param channel Channel
     */
    public void remove(Channel channel) {
        // 移除 channels
        channels.remove(channel.id());
        // 移除 userChannels
        if (channel.hasAttr(CHANNEL_ATTR_KEY_USER)) {
            userChannels.remove(channel.attr(CHANNEL_ATTR_KEY_USER).get());
        }
        log.info("[remove][一个连接({})离开]", channel.id());
    }

    /**
     * 向指定用户发送消息
     *
     * @param user       用户
     * @param invocation 消息体
     */
    public void send(String user, Invocation invocation) {
        // 获得用户对应的 Channel
        Channel channel = userChannels.get(user);
        if (channel == null) {
            log.error("[send][连接不存在]");
            return;
        }
        if (!channel.isActive()) {
            log.error("[send][连接({})未激活]", channel.id());
            return;
        }
        // 发送消息
        channel.writeAndFlush(invocation);
    }

    /**
     * 向所有用户发送消息
     *
     * @param invocation 消息体
     */
    public void sendAll(Invocation invocation) {
        for (Channel channel : channels.values()) {
            if (!channel.isActive()) {
                log.error("[send][连接({})未激活]", channel.id());
                return;
            }
            // 发送消息
            channel.writeAndFlush(invocation);
        }
    }

}
```

#### 2.2 构建Netty客户端

##### 2.2.1 NettyClient

```java
@Slf4j
@Component
public class NettyClient {

    /**
     * 重连频率，单位：秒
     */
    private static final Integer RECONNECT_SECONDS = 20;

    @Value("${netty.server.host}")
    private String serverHost;
    @Value("${netty.server.port}")
    private Integer serverPort;

    @Autowired
    private NettyClientHandlerInitializer nettyClientHandlerInitializer;

    /**
     * 线程组，用于客户端对服务端的链接、数据读写
     */
    private EventLoopGroup eventGroup = new NioEventLoopGroup();
    /**
     * Netty Client Channel
     */
    private volatile Channel channel;

    /**
     * 启动 Netty Client
     */
    @PostConstruct
    public void start() throws InterruptedException {
        // 创建 Bootstrap 对象，用于 Netty Client 启动
        Bootstrap bootstrap = new Bootstrap();
        // 设置 Bootstrap 的各种属性。
        bootstrap.group(eventGroup) // 设置一个 EventLoopGroup 对象
                .channel(NioSocketChannel.class)  // 指定 Channel 为客户端 NioSocketChannel
                .remoteAddress(serverHost, serverPort) // 指定链接服务器的地址
                .option(ChannelOption.SO_KEEPALIVE, true) // TCP Keepalive 机制，实现 TCP 层级的心跳保活功能
                .option(ChannelOption.TCP_NODELAY, true) // 允许较小的数据包的发送，降低延迟
                .handler(nettyClientHandlerInitializer);
        // 链接服务器，并异步等待成功，即启动客户端
        bootstrap.connect().addListener(new ChannelFutureListener() {

            @Override
            public void operationComplete(ChannelFuture future) throws Exception {
                // 连接失败
                if (!future.isSuccess()) {
                    log.error("[start][Netty Client 连接服务器({}:{}) 失败]", serverHost, serverPort);
                    reconnect();
                    return;
                }
                // 连接成功
                channel = future.channel();
                log.info("[start][Netty Client 连接服务器({}:{}) 成功]", serverHost, serverPort);
            }

        });
    }

    public void reconnect() {
        eventGroup.schedule(new Runnable() {
            @Override
            public void run() {
                log.info("[reconnect][开始重连]");
                try {
                    start();
                } catch (InterruptedException e) {
                    log.error("[reconnect][重连失败]", e);
                }
            }
        }, RECONNECT_SECONDS, TimeUnit.SECONDS);
        log.info("[reconnect][{} 秒后将发起重连]", RECONNECT_SECONDS);
    }

    /**
     * 关闭 Netty Server
     */
    @PreDestroy
    public void shutdown() {
        // 关闭 Netty Client
        if (channel != null) {
            channel.close();
        }
        // 优雅关闭一个 EventLoopGroup 对象
        eventGroup.shutdownGracefully();
    }

    /**
     * 发送消息
     *
     * @param invocation 消息体
     */
    public void send(Invocation invocation) {
        if (channel == null) {
            log.error("[send][连接不存在]");
            return;
        }
        if (!channel.isActive()) {
            log.error("[send][连接({})未激活]", channel.id());
            return;
        }
        // 发送消息
        channel.writeAndFlush(invocation);
    }

}
```

##### 2.2.2 NettyClientHandler

```java
@Slf4j
@Component
@ChannelHandler.Sharable
public class NettyClientHandler extends ChannelInboundHandlerAdapter {

    @Autowired
    private NettyClient nettyClient;

    @Override
    public void channelInactive(ChannelHandlerContext ctx) throws Exception {
        // 发起重连
        nettyClient.reconnect();
        // 继续触发事件
        super.channelInactive(ctx);
    }

    @Override
    public void exceptionCaught(ChannelHandlerContext ctx, Throwable cause) {
        log.error("[exceptionCaught][连接({}) 发生异常]", ctx.channel().id(), cause);
        // 断开连接
        ctx.channel().close();
    }

    @Override
    public void userEventTriggered(ChannelHandlerContext ctx, Object event) throws Exception {
        // 空闲时，向服务端发起一次心跳
        if (event instanceof IdleStateEvent) {
            log.info("[userEventTriggered][发起一次心跳]");
            HeartbeatRequest heartbeatRequest = new HeartbeatRequest();
            ctx.writeAndFlush(new Invocation(HeartbeatRequest.TYPE, heartbeatRequest))
                    .addListener(ChannelFutureListener.CLOSE_ON_FAILURE);
        } else {
            super.userEventTriggered(ctx, event);
        }
    }

}
```

##### 2.2.3 NettyClientHandlerInitializer

```java
@Component
public class NettyClientHandlerInitializer extends ChannelInitializer<Channel> {

    /**
     * 心跳超时时间
     */
    private static final Integer READ_TIMEOUT_SECONDS = 60;

    @Autowired
    private MessageDispatcher messageDispatcher;

    @Autowired
    private NettyClientHandler nettyClientHandler;

    @Override
    protected void initChannel(Channel ch) {
        ch.pipeline()
                // 空闲检测
                .addLast(new IdleStateHandler(READ_TIMEOUT_SECONDS, 0, 0))
                .addLast(new ReadTimeoutHandler(3 * READ_TIMEOUT_SECONDS))
                // 编码器
                .addLast(new InvocationEncoder())
                // 解码器
                .addLast(new InvocationDecoder())
                // 消息分发器
                .addLast(messageDispatcher)
                // 客户端处理器
                .addLast(nettyClientHandler)
        ;
    }

}
```

##### 2.2.4 TestController

```java
@RestController
@RequestMapping("/test")
public class TestController {

    @Autowired
    private NettyClient nettyClient;

    @PostMapping("/mock")
    public String mock(String type, String message) {
        // 创建 Invocation 对象
        Invocation invocation = new Invocation(type, message);
        // 发送消息
        nettyClient.send(invocation);
        return "success";
    }

}
```

#### 2.3 common

##### 2.3.1 编解码器（codec）

###### 2.3.1.1 Invocation（通信协议的消息体）

```java
/**
 * 通信协议的消息体
 */
public class Invocation {

    /**
     * 类型
     */
    private String type;
    /**
     * 消息，JSON 格式
     */
    private String message;

    // 空构造方法
    public Invocation() {
    }

    public Invocation(String type, String message) {
        this.type = type;
        this.message = message;
    }

    public Invocation(String type, Message message) {
        this.type = type;
        this.message = JSON.toJSONString(message);
    }

    public String getType() {
        return type;
    }

    public Invocation setType(String type) {
        this.type = type;
        return this;
    }

    public String getMessage() {
        return message;
    }

    public Invocation setMessage(String message) {
        this.message = message;
        return this;
    }

    @Override
    public String toString() {
        return "Invocation{" +
                "type='" + type + '\'' +
                ", message='" + message + '\'' +
                '}';
    }

}
```

###### 2.3.1.2 InvocationDecoder(解码器)

```java
/**
 * {@link Invocation} 解码器
 */
@Slf4j
public class InvocationDecoder extends ByteToMessageDecoder {

    @Override
    protected void decode(ChannelHandlerContext ctx, ByteBuf in, List<Object> out) {
        // 标记当前读取位置
        in.markReaderIndex();
        // 判断是否能够读取 length 长度
        if (in.readableBytes() <= 4) {
            return;
        }
        // 读取长度
        int length = in.readInt();
        if (length < 0) {
            throw new CorruptedFrameException("negative length: " + length);
        }
        // 如果 message 不够可读，则退回到原读取位置
        if (in.readableBytes() < length) {
            in.resetReaderIndex();
            return;
        }
        // 读取内容
        byte[] content = new byte[length];
        in.readBytes(content);
        // 解析成 Invocation
        Invocation invocation = JSON.parseObject(content, Invocation.class);
        out.add(invocation);
        log.info("[decode][连接({}) 解析到一条消息({})]", ctx.channel().id(), invocation.toString());
    }

}
```

###### 2.3.1.3 InvocationEncoder（编码器）

```java
/**
 * {@link Invocation} 编码器
 */
@Slf4j
public class InvocationEncoder extends MessageToByteEncoder<Invocation> {

    @Override
    protected void encode(ChannelHandlerContext ctx, Invocation invocation, ByteBuf out) {
        // 将 Invocation 转换成 byte[] 数组
        byte[] content = JSON.toJSONBytes(invocation);
        // 写入 length
        out.writeInt(content.length);
        // 写入内容
        out.writeBytes(content);
        log.info("[encode][连接({}) 编码了一条消息({})]", ctx.channel().id(), invocation.toString());
    }

}
```

##### 2.3.2 消息分发（dispatcher）

###### 2.3.2.1 Message（统一消息接口）

```java
/**
 * 消息接口
 */
public interface Message {
}
```

###### 2.3.2.2 MessageHandler（统一消息处理器）

```java
public interface MessageHandler<T extends Message> {

    /**
     * 执行处理消息
     *
     * @param channel 通道
     * @param message 消息
     */
    void execute(Channel channel, T message);

    /**
     * @return 消息类型，即每个 Message 实现类上的 TYPE 静态字段
     */
    String getType();

}
```

###### 2.3.2.3 MessageHandlerContainer（消息处理器容器）

```java
@Slf4j
@Component
public class MessageHandlerContainer implements InitializingBean {

    /**
     * 消息类型与 MessageHandler 的映射
     */
    private final Map<String, MessageHandler> handlers = new HashMap<>();

    @Autowired
    private ApplicationContext applicationContext;

    @Override
    public void afterPropertiesSet() throws Exception {
        // 通过 ApplicationContext 获得所有 MessageHandler Bean
        applicationContext.getBeansOfType(MessageHandler.class).values() // 获得所有 MessageHandler Bean
                .forEach(messageHandler -> handlers.put(messageHandler.getType(), messageHandler)); // 添加到 handlers 中
        log.info("[afterPropertiesSet][消息处理器数量：{}]", handlers.size());
    }

    /**
     * 获得类型对应的 MessageHandler
     *
     * @param type 类型
     * @return MessageHandler
     */
    MessageHandler getMessageHandler(String type) {
        MessageHandler handler = handlers.get(type);
        if (handler == null) {
            throw new IllegalArgumentException(String.format("类型(%s) 找不到匹配的 MessageHandler 处理器", type));
        }
        return handler;
    }

    /**
     * 获得 MessageHandler 处理的消息类
     *
     * @param handler 处理器
     * @return 消息类
     */
    static Class<? extends Message> getMessageClass(MessageHandler handler) {
        // 获得 Bean 对应的 Class 类名。因为有可能被 AOP 代理过。
        Class<?> targetClass = AopProxyUtils.ultimateTargetClass(handler);
        // 获得接口的 Type 数组
        Type[] interfaces = targetClass.getGenericInterfaces();
        Class<?> superclass = targetClass.getSuperclass();
        while ((Objects.isNull(interfaces) || 0 == interfaces.length) && Objects.nonNull(superclass)) { // 此处，是以父类的接口为准
            interfaces = superclass.getGenericInterfaces();
            superclass = targetClass.getSuperclass();
        }
        if (Objects.nonNull(interfaces)) {
            // 遍历 interfaces 数组
            for (Type type : interfaces) {
                // 要求 type 是泛型参数
                if (type instanceof ParameterizedType) {
                    ParameterizedType parameterizedType = (ParameterizedType) type;
                    // 要求是 MessageHandler 接口
                    if (Objects.equals(parameterizedType.getRawType(), MessageHandler.class)) {
                        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();
                        // 取首个元素
                        if (Objects.nonNull(actualTypeArguments) && actualTypeArguments.length > 0) {
                            return (Class<Message>) actualTypeArguments[0];
                        } else {
                            throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
                        }
                    }
                }
            }
        }
        throw new IllegalStateException(String.format("类型(%s) 获得不到消息类型", handler));
    }

}
```

###### 2.3.2.4 MessageDispatcher（消息分发器）

```java
@Component
@ChannelHandler.Sharable
public class MessageDispatcher extends SimpleChannelInboundHandler<Invocation> {

    @Autowired
    private MessageHandlerContainer messageHandlerContainer;

    private final ExecutorService executor = Executors.newFixedThreadPool(200);

    @Override
    protected void channelRead0(ChannelHandlerContext ctx, Invocation invocation) {
        // 获得 type 对应的 MessageHandler 处理器
        MessageHandler messageHandler = messageHandlerContainer.getMessageHandler(invocation.getType());
        // 获得  MessageHandler 处理器 的消息类
        Class<? extends Message> messageClass = MessageHandlerContainer.getMessageClass(messageHandler);
        // 解析消息
        Message message = JSON.parseObject(invocation.getMessage(), messageClass);
        // 执行逻辑
        executor.submit(new Runnable() {

            @Override
            public void run() {
                // noinspection unchecked
                messageHandler.execute(ctx.channel(), message);
            }

        });
    }

}
```

##### 2.3.3 消息处理

###### 2.3.3.1 认证消息（auth）

```java
/**
 * 用户认证请求
 * 
 * @author Corona
 */
@Data
@Accessors(chain = true)
public class AuthRequest implements Message {

    public static final String TYPE = "AUTH_REQUEST";

    /**
     * 认证 Token
     */
    private String accessToken;
}
```

```java
/**
 * 用户认证响应
 *
 * @author Corona
 */
@Data
@Accessors(chain = true)
public class AuthResponse implements Message {

    public static final String TYPE = "AUTH_RESPONSE";

    /**
     * 响应状态码
     */
    private Integer code;
    /**
     * 响应提示
     */
    private String message;

}
```

###### 2.3.3.2 聊天消息（chat）

```java
/**
 * 转发消息给一个用户的 Message
 */
@Data
@Accessors(chain = true)
public class ChatRedirectToUserRequest implements Message {

    public static final String TYPE = "CHAT_REDIRECT_TO_USER_REQUEST";

    /**
     * 消息编号
     */
    private String msgId;
    /**
     * 内容
     */
    private String content;

}
```

```java
/**
 * 聊天发送消息结果的 Response
 */
@Data
@Accessors(chain = true)
public class ChatSendResponse implements Message {

    public static final String TYPE = "CHAT_SEND_RESPONSE";

    /**
     * 消息编号
     */
    private String msgId;
    /**
     * 响应状态码
     */
    private Integer code;
    /**
     * 响应提示
     */
    private String message;
}
```

```java
/**
 * 发送给所有人的群聊消息的 Message
 */
@Data
@Accessors(chain = true)
public class ChatSendToAllRequest implements Message {

    public static final String TYPE = "CHAT_SEND_TO_ALL_REQUEST";

    /**
     * 消息编号
     */
    private String msgId;
    /**
     * 内容
     */
    private String content;
}
```

```java
/**
 * 发送给指定人的私聊消息 Request
 */
@Data
@Accessors(chain = true)
public class ChatSendToOneRequest implements Message {

    public static final String TYPE = "CHAT_SEND_TO_ONE_REQUEST";

    /**
     * 发送给的用户
     */
    private String toUser;
    /**
     * 消息编号
     */
    private String msgId;
    /**
     * 内容
     */
    private String content;

}
```

###### 2.3.3.3 心跳消息（heartbeat）

```java
/**
 * 消息 - 心跳请求
 */
public class HeartbeatRequest implements Message {

    /**
     * 类型 - 心跳请求
     */
    public static final String TYPE = "HEARTBEAT_REQUEST";

    @Override
    public String toString() {
        return "HeartbeatRequest{}";
    }

}
```

```java
/**
 * 消息 - 心跳响应
 */
public class HeartbeatResponse implements Message {

    /**
     * 类型 - 心跳响应
     */
    public static final String TYPE = "HEARTBEAT_RESPONSE";

    @Override
    public String toString() {
        return "HeartbeatResponse{}";
    }

}

```

###### 2.3.3.4 认证处理器（AuthRequestHandler）

```java
@Component
public class AuthRequestHandler implements MessageHandler<AuthRequest> {

    @Autowired
    private NettyChannelManager nettyChannelManager;

    @Override
    public void execute(Channel channel, AuthRequest authRequest) {
        // 如果未传递 accessToken
        if (StringUtils.isEmpty(authRequest.getAccessToken())) {
            AuthResponse authResponse = new AuthResponse().setCode(1).setMessage("认证 accessToken 未传入");
            channel.writeAndFlush(new Invocation(AuthResponse.TYPE, authResponse));
            return;
        }

        // ... 此处应有一段

        // 将用户和 Channel 绑定
        // 考虑到代码简化，我们先直接使用 accessToken 作为 User
        nettyChannelManager.addUser(channel, authRequest.getAccessToken());

        // 响应认证成功
        AuthResponse authResponse = new AuthResponse().setCode(0);
        channel.writeAndFlush(new Invocation(AuthResponse.TYPE, authResponse));
    }

    @Override
    public String getType() {
        return AuthRequest.TYPE;
    }

}
```

###### 2.3.3.5 私聊处理器（ChatSendToOneHandler）

```java
@Component
public class ChatSendToOneHandler implements MessageHandler<ChatSendToOneRequest> {

    @Autowired
    private NettyChannelManager nettyChannelManager;

    @Override
    public void execute(Channel channel, ChatSendToOneRequest message) {
        // 这里，假装直接成功
        ChatSendResponse sendResponse = new ChatSendResponse().setMsgId(message.getMsgId()).setCode(0);
        channel.writeAndFlush(new Invocation(ChatSendResponse.TYPE, sendResponse));

        // 创建转发的消息，发送给指定用户
        ChatRedirectToUserRequest sendToUserRequest = new ChatRedirectToUserRequest().setMsgId(message.getMsgId())
                .setContent(message.getContent());
        nettyChannelManager.send(message.getToUser(), new Invocation(ChatRedirectToUserRequest.TYPE, sendToUserRequest));
    }

    @Override
    public String getType() {
        return ChatSendToOneRequest.TYPE;
    }

}
```

###### 2.3.3.6 群聊处理器（ChatSendToAllHandler）

```java
@Component
public class ChatSendToAllHandler implements MessageHandler<ChatSendToAllRequest> {

    @Autowired
    private NettyChannelManager nettyChannelManager;

    @Override
    public void execute(Channel channel, ChatSendToAllRequest message) {
        // 这里，假装直接成功
        ChatSendResponse sendResponse = new ChatSendResponse().setMsgId(message.getMsgId()).setCode(0);
        channel.writeAndFlush(new Invocation(ChatSendResponse.TYPE, sendResponse));

        // 创建转发的消息，并广播发送
        ChatRedirectToUserRequest sendToUserRequest = new ChatRedirectToUserRequest().setMsgId(message.getMsgId())
                .setContent(message.getContent());
        nettyChannelManager.sendAll(new Invocation(ChatRedirectToUserRequest.TYPE, sendToUserRequest));
    }

    @Override
    public String getType() {
        return ChatSendToAllRequest.TYPE;
    }

}
```

###### 2.3.3.7 心跳包处理器

```java
@Slf4j
@Component
public class HeartbeatRequestHandler implements MessageHandler<HeartbeatRequest> {

    @Override
    public void execute(Channel channel, HeartbeatRequest message) {
        log.info("[execute][收到连接({}) 的心跳请求]", channel.id());
        // 响应心跳
        HeartbeatResponse response = new HeartbeatResponse();
        channel.writeAndFlush(new Invocation(HeartbeatResponse.TYPE, response));
    }

    @Override
    public String getType() {
        return HeartbeatRequest.TYPE;
    }

}
```

### 3.扩展

- 想要了解 Netty **源码**的，可以阅读[《Netty 实现原理与源码解析系统 —— 精品合集》](http://www.iocoder.cn/Netty/Netty-collection/?self)文章。
- 想要入门 Netty **基础**的，可以阅读[《Netty Bootstrap（图解）》](http://www.iocoder.cn/Fight/crazymakercircle/Netty-Bootstrap/?self)文章。

## 第十二章 Spring Boot Dubbo入门

### 1.概述

Apache Dubbo **|ˈdʌbəʊ|** 是一款高性能、轻量级的开源 Java RPC 框架，它提供了三大核心能力：面向接口的远程方法调用，智能容错和负载均衡，以及服务自动注册和发现。

一共涉及到 5 个角色：

- Registry 注册中心，用于服务的注册与发现。
- Provider 服务提供者，通过向 Registry 注册服务。
- Consumer 服务消费者，通过从 Registry 发现服务。后续直接调用 Provider ，无需经过 Registry 。
- Monitor 监控中心，统计服务的调用次数和调用时间。
- Container 服务运行容器。

> FROM [《Dubbo 文档 —— 架构》](http://dubbo.apache.org/zh-cn/docs/user/preface/architecture.html)
>
> 调用关系说明（注意，和上图的数字，和下面的步骤是一一对应的）：
>
> - 1. 服务容器负责启动，加载，运行服务提供者。
> - 1. 服务提供者在启动时，向注册中心注册自己提供的服务。
> - 1. 服务消费者在启动时，向注册中心订阅自己所需的服务。
> - 1. 注册中心返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者。
> - 1. 服务消费者，从提供者地址列表中，基于软负载均衡算法，选一台提供者进行调用，如果调用失败，再选另一台调用。
> - 1. 服务消费者和提供者，在内存中累计调用次数和调用时间，定时每分钟发送一次统计数据到监控中心。

## 第十三章 Spring Boot 声明式调用Feign入门

### 1.概述

[Feign](https://github.com/OpenFeign/feign) 是由 Netflix 开源的**声明式的 HTTP 客户端**，目前已经捐献给 [OpenFeign](https://github.com/OpenFeign) 社区。

## 第十四章 Spring Boot gPRC入门

### 1.概述

[gRPC](https://grpc.io/) 是一个高性能、开源和通用的 RPC 框架，面向移动和 HTTP/2 设计。目前其提供了 C、Java、Go 等等语言的支持，

gRPC 基于 HTTP/2 标准设计，带来诸如双向流、流控、头部压缩、单 TCP 连接上的多复用请求等特。这些特性使得其在移动设备上表现更好，更省电和节省空间占用。

目前，有非常多优秀的开源项目采用 gRPC 作为通信方式，例如说 [Kubernetes](http://www.iocoder.cn/Books/Kubernetes-books-recommended/?self)、[SkyWalking](http://www.iocoder.cn/categories/SkyWalking/?self)、[istio](https://github.com/istio/istio) 等等。甚至说，Dubbo 自 2.7.5 版本之后，开始提供对 gRPC 协议的支持，具体可见[《Dubbo 官方文档 —— grpc://》](http://dubbo.apache.org/zh-cn/docs/user/references/protocol/gRPC.html)。.

## 第十五章 Spring Boot Web Services入门

### 1.概述

[Spring Web Services](https://github.com/spring-projects/spring-ws) 项目，是由 **Spring** 社区开源，专注于**文档驱动**的方式，构建 Web Services 服务的框架

Spring Web Services 基于**契约优先**理念开发 SOAP 服务，可以非常灵活的创建 Web Services 服务，并且提供多种方式处理 XML Payload。

Spring Web Services 是基于 Spring 之上，所以我们可以很方便的使用 Spring 依赖注入等等功能。

## 第十六章 Spring Boot SOFARPC入门

### 1.概述

[SOFARPC](https://github.com/sofastack/sofa-rpc) 是蚂蚁金服开源的一款基于 Java 实现的 RPC 服务框架，为应用之间提供远程服务调用能力，具有高可伸缩性，高容错性。目前，蚂蚁金服所有的业务的相互间的 RPC 调用都是采用 SOFARPC。

- SOFARPC 为用户提供了负载均衡，流量转发，链路追踪，链路数据透传，故障剔除等功能。

- SOFARPC 还支持不同的协议，目前包括 [bolt](https://www.sofastack.tech/projects/sofa-rpc/bolt)，[RESTful](https://www.sofastack.tech/projects/sofa-rpc/restful)，[dubbo](https://www.sofastack.tech/projects/sofa-rpc/dubbo)，[H2C](https://www.sofastack.tech/projects/sofa-rpc/h2c) 协议进行通信。

  > 旁白君：[SOFABolt](https://github.com/sofastack/sofa-bolt) 是一套基于 Netty 实现的网络通信框架。

## 第十七章 Spring Boot Motan入门

### 1.概述

[Motan](https://github.com/weibocom/motan) 是一套高性能、易于使用的分布式远程服务调用(RPC)框架。Motan 由**微博**开源，已支撑其内部千亿级调用。

> 旁白君：Motan 在设计上参考了 Dubbo，所以整体架构会比较接近。

## 第十八章 Spring Boot 数据库连接池入门

